<?xml version="1.0"?>
<doc>
    <assembly>
        <name>DotNetty.Buffers</name>
    </assembly>
    <members>
        <member name="T:DotNetty.Buffers.AbstractByteBuffer">
            <summary>
                Abstract base class implementation of a <see cref="T:DotNetty.Buffers.IByteBuffer" />
            </summary>
        </member>
        <member name="T:DotNetty.Buffers.AbstractByteBufferAllocator">
            <inheritdoc />
            <summary>
                Abstract base class for <see cref="T:DotNetty.Buffers.IByteBufferAllocator" /> instances
            </summary>
        </member>
        <member name="T:DotNetty.Buffers.AbstractDerivedByteBuffer">
            <inheritdoc />
            <summary>
                Abstract base class for <see cref="T:DotNetty.Buffers.IByteBuffer" /> implementations that wrap another
                <see cref="T:DotNetty.Buffers.IByteBuffer" />.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.AbstractReferenceCountedByteBuffer.SetReferenceCount(System.Int32)">
            <summary>
            An unsafe operation intended for use by a subclass that sets the reference count of the buffer directly
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:DotNetty.Buffers.AbstractReferenceCountedByteBuffer.ResetReferenceCount">
            <summary>
            An unsafe operation intended for use by a subclass that resets the reference count of the buffer to 1
            </summary>
        </member>
        <member name="T:DotNetty.Buffers.ArrayPooled">
            <summary>Utility class for managing and creating unpooled buffers</summary>
        </member>
        <member name="M:DotNetty.Buffers.ArrayPooled.WrappedBuffer(System.Byte[])">
            <summary>Creates a new big-endian buffer which wraps the specified array. A modification on the
            specified array's content will be visible to the returned buffer.</summary>
        </member>
        <member name="M:DotNetty.Buffers.ArrayPooled.WrappedBuffer(System.Byte[],System.Int32,System.Int32)">
            <summary>Creates a new big-endian buffer which wraps the sub-region of the specified array. A
            modification on the specified array's content will be visible to the returned buffer.</summary>
        </member>
        <member name="M:DotNetty.Buffers.ArrayPooled.WrappedBuffer(DotNetty.Buffers.IByteBuffer)">
            <summary>Creates a new buffer which wraps the specified buffer's readable bytes. A modification on
            the specified buffer's content will be visible to the returned buffer.</summary>
            <param name="buffer">The buffer to wrap. Reference count ownership of this variable is transferred to this method.</param>
            <returns>The readable portion of the buffer, or an empty buffer if there is no readable portion.</returns>
        </member>
        <member name="M:DotNetty.Buffers.ArrayPooled.WrappedBuffer(DotNetty.Buffers.IByteBuffer[])">
            <summary>Creates a new big-endian composite buffer which wraps the readable bytes of the specified
            buffers without copying them. A modification on the content of the specified buffers will
            be visible to the returned buffer.</summary>
            <param name="buffers">The buffers to wrap. Reference count ownership of all variables is transferred to this method.</param>
            <returns>The readable portion of the buffers. The caller is responsible for releasing this buffer.</returns>
        </member>
        <member name="M:DotNetty.Buffers.ArrayPooled.WrappedBuffer(System.Int32,DotNetty.Buffers.IByteBuffer[])">
            <summary>Creates a new big-endian composite buffer which wraps the readable bytes of the specified
            buffers without copying them. A modification on the content of the specified buffers will
            be visible to the returned buffer.</summary>
            <param name="maxNumComponents">Advisement as to how many independent buffers are allowed to exist before consolidation occurs.</param>
            <param name="buffers">The buffers to wrap. Reference count ownership of all variables is transferred to this method.</param>
            <returns>The readable portion of the buffers. The caller is responsible for releasing this buffer.</returns>
        </member>
        <member name="M:DotNetty.Buffers.ArrayPooled.CopiedBuffer(System.Byte[])">
            <summary>Creates a new big-endian buffer whose content is a copy of the specified array The new
            buffer's <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex"/> and <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex"/>
            are <c>0</c> and <see cref="P:System.Array.Length"/> respectively.</summary>
            <param name="array">A buffer we're going to copy.</param>
            <returns>The new buffer that copies the contents of array.</returns>
        </member>
        <member name="M:DotNetty.Buffers.ArrayPooled.CopiedBuffer(System.Byte[],System.Int32,System.Int32)">
            <summary>Creates a new big-endian buffer whose content is a copy of the specified array. The new
            buffer's <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex"/> and <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex"/>
            are <c>0</c> and <see cref="P:System.Array.Length"/> respectively.</summary>
            <param name="array">A buffer we're going to copy.</param>
            <param name="offset">The index offset from which we're going to read array.</param>
            <param name="length">The number of bytes we're going to read from array beginning from position offset.</param>
            <returns>The new buffer that copies the contents of array.</returns>
        </member>
        <member name="M:DotNetty.Buffers.ArrayPooled.CopiedBuffer(DotNetty.Buffers.IByteBuffer)">
            <summary>Creates a new big-endian buffer whose content is a copy of the specified <see
            cref="T:System.Array"/>. The new buffer's <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex"/> and <see
            cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex"/> are <c>0</c> and <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity"/> respectively.</summary>
            <param name="buffer">A buffer we're going to copy.</param>
            <returns>The new buffer that copies the contents of buffer.</returns>
        </member>
        <member name="M:DotNetty.Buffers.ArrayPooled.CopiedBuffer(DotNetty.Buffers.IByteBuffer[])">
            <summary>Creates a new big-endian buffer whose content is a merged copy of the specified <see
            cref="T:System.Array"/>. The new buffer's <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex"/> and <see
            cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex"/> are <c>0</c> and <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity"/> respectively.</summary>
            <param name="buffers">Buffers we're going to copy.</param>
            <returns>The new buffer that copies the contents of buffers.</returns>
        </member>
        <member name="M:DotNetty.Buffers.ArrayPooled.CopyInt(System.Int32)">
            <summary>Creates a new 4-byte big-endian buffer that holds the specified 32-bit integer.</summary>
        </member>
        <member name="M:DotNetty.Buffers.ArrayPooled.CopyInt(System.Int32[])">
            <summary>Create a big-endian buffer that holds a sequence of the specified 32-bit integers.</summary>
        </member>
        <member name="M:DotNetty.Buffers.ArrayPooled.CopyShort(System.Int32)">
            <summary>Creates a new 2-byte big-endian buffer that holds the specified 16-bit integer.</summary>
        </member>
        <member name="M:DotNetty.Buffers.ArrayPooled.CopyShort(System.Int16[])">
            <summary>Create a new big-endian buffer that holds a sequence of the specified 16-bit integers.</summary>
        </member>
        <member name="M:DotNetty.Buffers.ArrayPooled.CopyShort(System.Int32[])">
            <summary>Create a new big-endian buffer that holds a sequence of the specified 16-bit integers.</summary>
        </member>
        <member name="M:DotNetty.Buffers.ArrayPooled.CopyMedium(System.Int32)">
            <summary>Creates a new 3-byte big-endian buffer that holds the specified 24-bit integer.</summary>
        </member>
        <member name="M:DotNetty.Buffers.ArrayPooled.CopyMedium(System.Int32[])">
            <summary>Create a new big-endian buffer that holds a sequence of the specified 24-bit integers.</summary>
        </member>
        <member name="M:DotNetty.Buffers.ArrayPooled.CopyLong(System.Int64)">
            <summary>Creates a new 8-byte big-endian buffer that holds the specified 64-bit integer.</summary>
        </member>
        <member name="M:DotNetty.Buffers.ArrayPooled.CopyLong(System.Int64[])">
            <summary>Create a new big-endian buffer that holds a sequence of the specified 64-bit integers.</summary>
        </member>
        <member name="M:DotNetty.Buffers.ArrayPooled.CopyBoolean(System.Boolean)">
            <summary>Creates a new single-byte big-endian buffer that holds the specified boolean value.</summary>
        </member>
        <member name="M:DotNetty.Buffers.ArrayPooled.CopyBoolean(System.Boolean[])">
            <summary>Create a new big-endian buffer that holds a sequence of the specified boolean values.</summary>
        </member>
        <member name="M:DotNetty.Buffers.ArrayPooled.CopyFloat(System.Single)">
            <summary>Creates a new 4-byte big-endian buffer that holds the specified 32-bit floating point number.</summary>
        </member>
        <member name="M:DotNetty.Buffers.ArrayPooled.CopyFloat(System.Single[])">
            <summary>Create a new big-endian buffer that holds a sequence of the specified 32-bit floating point numbers.</summary>
        </member>
        <member name="M:DotNetty.Buffers.ArrayPooled.CopyDouble(System.Double)">
            <summary>Creates a new 8-byte big-endian buffer that holds the specified 64-bit floating point number.</summary>
        </member>
        <member name="M:DotNetty.Buffers.ArrayPooled.CopyDouble(System.Double[])">
            <summary>Create a new big-endian buffer that holds a sequence of the specified 64-bit floating point numbers.</summary>
        </member>
        <member name="M:DotNetty.Buffers.ArrayPooled.EncodeString(System.String,System.Text.Encoding,System.Int32)">
            <summary>Encode the given <see cref="T:System.String" /> using the given <see cref="T:System.Text.Encoding" /> into a new
            <see cref="T:DotNetty.Buffers.IByteBuffer" /> which is allocated via the <see cref="T:DotNetty.Buffers.IByteBufferAllocator" />.</summary>
            <param name="src">src The <see cref="T:System.String" /> to encode.</param>
            <param name="encoding">charset The specified <see cref="T:System.Text.Encoding" /></param>
            <param name="extraCapacity">the extra capacity to alloc except the space for decoding.</param>
        </member>
        <member name="M:DotNetty.Buffers.ArrayPooled.ReadBytes(DotNetty.Buffers.IByteBuffer,System.Int32)">
            <summary>Read the given amount of bytes into a new <see cref="T:DotNetty.Buffers.IByteBuffer"/> that is allocated from the <see cref="T:DotNetty.Buffers.IByteBufferAllocator"/>.</summary>
        </member>
        <member name="M:DotNetty.Buffers.ArrayPooledByteBuffer.Reuse(DotNetty.Buffers.ArrayPooledByteBufferAllocator,System.Buffers.ArrayPool{System.Byte},System.Int32,System.Int32)">
            <summary>Method must be called before reuse this {@link ArrayPooledByteBufAllocator}.</summary>
            <param name="allocator"></param>
            <param name="initialCapacity"></param>
            <param name="maxCapacity"></param>
            <param name="arrayPool"></param>
        </member>
        <member name="T:DotNetty.Buffers.ArrayPooledByteBufferAllocator">
            <summary>
                Unpooled implementation of <see cref="T:DotNetty.Buffers.IByteBufferAllocator" />.
            </summary>
        </member>
        <member name="P:DotNetty.Buffers.ByteBufferStream.Position">
            <summary>Only for reader position</summary>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferStream.MarkPosition">
            <summary>Only for reader position</summary>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferStream.ResetPosition">
            <summary>Only for reader position</summary>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>Only for reader position</summary>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferStream.ValidateCopyToArgs(System.IO.Stream)">
            <summary>Validate the arguments to CopyTo, as would Stream.CopyTo.</summary>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferUtil.Compare(DotNetty.Buffers.IByteBuffer,DotNetty.Buffers.IByteBuffer)">
            <summary>
            Compares the two specified buffers as described in {@link ByteBuf#compareTo(ByteBuf)}.
            This method is useful when implementing a new buffer type.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferUtil.ReadBytes(DotNetty.Buffers.IByteBufferAllocator,DotNetty.Buffers.IByteBuffer,System.Int32)">
            <summary>
                Read the given amount of bytes into a new <see cref="T:DotNetty.Buffers.IByteBuffer"/> that is allocated from the <see cref="T:DotNetty.Buffers.IByteBufferAllocator"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferUtil.GetBytes(DotNetty.Buffers.IByteBuffer)">
            <summary>
            Create a copy of the underlying storage from <paramref name="buf"/> into a byte array.
            The copy will start at <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex"/> and copy <see cref="P:DotNetty.Buffers.IByteBuffer.ReadableBytes"/> bytes.
            </summary>
            <param name="buf"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferUtil.GetBytes(DotNetty.Buffers.IByteBuffer,System.Int32,System.Int32)">
            <summary>
            Create a copy of the underlying storage from <paramref name="buf"/> into a byte array.
            The copy will start at <paramref name="start"/> and copy <paramref name="length"/> bytes.
            </summary>
            <param name="buf"></param>
            <param name="start"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferUtil.GetBytes(DotNetty.Buffers.IByteBuffer,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Return an array of the underlying storage from <paramref name="buf"/> into a byte array.
            The copy will start at {@code start} and copy {@code length} bytes.
            If <paramref name="copy"/> is true a copy will be made of the memory.
            If <paramref name="copy"/> is false the underlying storage will be shared, if possible.
            </summary>
            <param name="buf"></param>
            <param name="start"></param>
            <param name="length"></param>
            <param name="copy"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferUtil.SwapLong(System.Int64)">
            <summary>
                Toggles the endianness of the specified 64-bit long integer.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferUtil.SwapInt(System.Int32)">
            <summary>
                Toggles the endianness of the specified 32-bit integer.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferUtil.SwapShort(System.Int16)">
            <summary>
                Toggles the endianness of the specified 16-bit integer.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferUtil.HexDump(DotNetty.Buffers.IByteBuffer)">
            <summary>
                Returns a <a href="http://en.wikipedia.org/wiki/Hex_dump">hex dump</a>
                of the specified buffer's sub-region.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferUtil.HexDump(DotNetty.Buffers.IByteBuffer,System.Int32,System.Int32)">
            <summary>
                Returns a <a href="http://en.wikipedia.org/wiki/Hex_dump">hex dump</a>
                of the specified buffer's sub-region.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferUtil.HexDump(System.Byte[])">
            <summary>
                Returns a <a href="http://en.wikipedia.org/wiki/Hex_dump">hex dump</a>
                of the specified buffer's sub-region.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferUtil.HexDump(System.Byte[],System.Int32,System.Int32)">
            <summary>
                Returns a <a href="http://en.wikipedia.org/wiki/Hex_dump">hex dump</a>
                of the specified buffer's sub-region.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferUtil.PrettyHexDump(DotNetty.Buffers.IByteBuffer)">
            <summary>
                Returns a multi-line hexadecimal dump of the specified {@link ByteBuf} that is easy to read by humans.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferUtil.PrettyHexDump(DotNetty.Buffers.IByteBuffer,System.Int32,System.Int32)">
            <summary>
                Returns a multi-line hexadecimal dump of the specified {@link ByteBuf} that is easy to read by humans,
                starting at the given {@code offset} using the given {@code length}.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferUtil.AppendPrettyHexDump(System.Text.StringBuilder,DotNetty.Buffers.IByteBuffer)">
            <summary>
                Appends the prettified multi-line hexadecimal dump of the specified {@link ByteBuf} to the specified
                {@link StringBuilder} that is easy to read by humans.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferUtil.AppendPrettyHexDump(System.Text.StringBuilder,DotNetty.Buffers.IByteBuffer,System.Int32,System.Int32)">
            <summary>
                Appends the prettified multi-line hexadecimal dump of the specified {@link ByteBuf} to the specified
                {@link StringBuilder} that is easy to read by humans, starting at the given {@code offset} using
                the given {@code length}.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferUtil.Equals(DotNetty.Buffers.IByteBuffer,System.Int32,DotNetty.Buffers.IByteBuffer,System.Int32,System.Int32)">
            <summary>
                Returns <c>true</c> if and only if the two specified buffers are
                identical to each other for {@code length} bytes starting at {@code aStartIndex}
                index for the {@code a} buffer and {@code bStartIndex} index for the {@code b} buffer.
                A more compact way to express this is:
                <p />
                {@code a[aStartIndex : aStartIndex + length] == b[bStartIndex : bStartIndex + length]}
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferUtil.Equals(DotNetty.Buffers.IByteBuffer,DotNetty.Buffers.IByteBuffer)">
            <summary>
                Returns <c>true</c> if and only if the two specified buffers are
                identical to each other as described in {@link ByteBuf#equals(Object)}.
                This method is useful when implementing a new buffer type.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferUtil.HashCode(DotNetty.Buffers.IByteBuffer)">
            <summary>
                Calculates the hash code of the specified buffer.  This method is
                useful when implementing a new buffer type.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferUtil.IndexOf(DotNetty.Buffers.IByteBuffer,DotNetty.Buffers.IByteBuffer)">
            <summary>Returns the reader index of needle in haystack, or -1 if needle is not in haystack.</summary>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferUtil.IndexOf(System.ReadOnlySpan{System.Byte}@,DotNetty.Buffers.IByteBuffer)">
            <summary>Returns the reader index of needle in haystack, or -1 if needle is not in haystack.</summary>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferUtil.EncodeString(DotNetty.Buffers.IByteBufferAllocator,System.String,System.Text.Encoding)">
            <summary>
                Encode the given <see cref="T:System.String" /> using the given <see cref="T:System.Text.Encoding" /> into a new
                <see cref="T:DotNetty.Buffers.IByteBuffer" /> which
                is allocated via the <see cref="T:DotNetty.Buffers.IByteBufferAllocator" />.
            </summary>
            <param name="alloc">The <see cref="T:DotNetty.Buffers.IByteBufferAllocator" /> to allocate {@link IByteBuffer}.</param>
            <param name="src">src The <see cref="T:System.String" /> to encode.</param>
            <param name="encoding">charset The specified <see cref="T:System.Text.Encoding" /></param>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferUtil.EncodeString(DotNetty.Buffers.IByteBufferAllocator,System.String,System.Text.Encoding,System.Int32)">
            <summary>
                Encode the given <see cref="T:System.String" /> using the given <see cref="T:System.Text.Encoding" /> into a new
                <see cref="T:DotNetty.Buffers.IByteBuffer" /> which
                is allocated via the <see cref="T:DotNetty.Buffers.IByteBufferAllocator" />.
            </summary>
            <param name="alloc">The <see cref="T:DotNetty.Buffers.IByteBufferAllocator" /> to allocate {@link IByteBuffer}.</param>
            <param name="src">src The <see cref="T:System.String" /> to encode.</param>
            <param name="encoding">charset The specified <see cref="T:System.Text.Encoding" /></param>
            <param name="extraCapacity">the extra capacity to alloc except the space for decoding.</param>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferUtil.ReserveAndWriteUtf8(DotNetty.Buffers.IByteBuffer,System.ReadOnlySpan{System.Char}@,System.Int32)">
            <summary>
             Encode a string in http://en.wikipedia.org/wiki/UTF-8 and write it into reserveBytes of 
             a byte buffer. The reserveBytes must be computed (ie eagerly using {@link #utf8MaxBytes(string)}
             or exactly with #utf8Bytes(string)}) to ensure this method not to not: for performance reasons
             the index checks will be performed using just reserveBytes.
             </summary>
             <returns> This method returns the actual number of bytes written.</returns>
        </member>
        <member name="F:DotNetty.Buffers.ByteOrder.LittleEndian">
            <summary>
                Default on most Windows systems
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.CompositeByteBuffer.AddComponent(DotNetty.Buffers.IByteBuffer)">
            <summary>
                Add the given {@link IByteBuffer}.
                Be aware that this method does not increase the {@code writerIndex} of the {@link CompositeByteBuffer}.
                If you need to have it increased you need to handle it by your own.
                @param buffer the {@link IByteBuffer} to add
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.CompositeByteBuffer.AddComponents(DotNetty.Buffers.IByteBuffer[])">
            <summary>
                Add the given {@link IByteBuffer}s.
                Be aware that this method does not increase the {@code writerIndex} of the {@link CompositeByteBuffer}.
                If you need to have it increased you need to handle it by your own.
                @param buffers the {@link IByteBuffer}s to add
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.CompositeByteBuffer.AddComponents(System.Collections.Generic.IEnumerable{DotNetty.Buffers.IByteBuffer})">
            <summary>
                Add the given {@link IByteBuffer}s.
                Be aware that this method does not increase the {@code writerIndex} of the {@link CompositeByteBuffer}.
                If you need to have it increased you need to handle it by your own.
                @param buffers the {@link IByteBuffer}s to add
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.CompositeByteBuffer.AddComponent(System.Int32,DotNetty.Buffers.IByteBuffer)">
            <summary>
                Add the given {@link IByteBuffer} on the specific index.
                Be aware that this method does not increase the {@code writerIndex} of the {@link CompositeByteBuffer}.
                If you need to have it increased you need to handle it by your own.
                @param cIndex the index on which the {@link IByteBuffer} will be added
                @param buffer the {@link IByteBuffer} to add
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.CompositeByteBuffer.AddComponent0(System.Boolean,System.Int32,DotNetty.Buffers.IByteBuffer)">
            <summary>
            Precondition is that <code>buffer != null</code>.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.CompositeByteBuffer.AddComponents(System.Int32,DotNetty.Buffers.IByteBuffer[])">
            <summary>
                Add the given {@link IByteBuffer}s on the specific index
                Be aware that this method does not increase the {@code writerIndex} of the {@link CompositeByteBuffer}.
                If you need to have it increased you need to handle it by your own.
                @param cIndex the index on which the {@link IByteBuffer} will be added.
                @param buffers the {@link IByteBuffer}s to add
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.CompositeByteBuffer.AddComponents(System.Int32,System.Collections.Generic.IEnumerable{DotNetty.Buffers.IByteBuffer})">
            <summary>
                Add the given {@link ByteBuf}s on the specific index
                Be aware that this method does not increase the {@code writerIndex} of the {@link CompositeByteBuffer}.
                If you need to have it increased you need to handle it by your own.
                @param cIndex the index on which the {@link IByteBuffer} will be added.
                @param buffers the {@link IByteBuffer}s to add
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.CompositeByteBuffer.AddFlattenedComponents(System.Boolean,DotNetty.Buffers.IByteBuffer)">
            <summary>
            Add the given <see cref="T:DotNetty.Buffers.IByteBuffer"/> and increase the <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex"/> if <paramref name="increaseWriterIndex"/> is
            <c>true</c>. If the provided buffer is a <see cref="T:DotNetty.Buffers.CompositeByteBuffer"/> itself, a "shallow copy" of its
            readable components will be performed. Thus the actual number of new components added may vary
            and in particular will be zero if the provided buffer is not readable.
            </summary>
            <param name="increaseWriterIndex"></param>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Buffers.CompositeByteBuffer.ConsolidateIfNeeded">
            <summary>
                This should only be called as last operation from a method as this may adjust the underlying
                array of components and so affect the index etc.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.CompositeByteBuffer.RemoveComponent(System.Int32)">
            <summary>
                Remove the {@link IByteBuffer} from the given index.
                @param cIndex the index on from which the {@link IByteBuffer} will be remove
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.CompositeByteBuffer.RemoveComponents(System.Int32,System.Int32)">
            <summary>
                Remove the number of {@link IByteBuffer}s starting from the given index.
                @param cIndex the index on which the {@link IByteBuffer}s will be started to removed
                @param numComponents the number of components to remove
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.CompositeByteBuffer.Decompose(System.Int32,System.Int32)">
            <summary>
                Same with {@link #slice(int, int)} except that this method returns a list.
            </summary>
        </member>
        <member name="P:DotNetty.Buffers.CompositeByteBuffer.NumComponents">
            <summary>
                Return the current number of {@link IByteBuffer}'s that are composed in this instance
            </summary>
        </member>
        <member name="P:DotNetty.Buffers.CompositeByteBuffer.MaxNumComponents">
            <summary>
                Return the max number of {@link IByteBuffer}'s that are composed in this instance
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.CompositeByteBuffer.ToComponentIndex(System.Int32)">
            <summary>
                Return the index for the given offset
            </summary>
        </member>
        <member name="P:DotNetty.Buffers.CompositeByteBuffer.Item(System.Int32)">
            <summary>
                Return the {@link IByteBuffer} on the specified index
                @param cIndex the index for which the {@link IByteBuffer} should be returned
                @return buffer the {@link IByteBuffer} on the specified index
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.CompositeByteBuffer.ComponentAtOffset(System.Int32)">
            <summary>
                Return the {@link IByteBuffer} on the specified index
                @param offset the offset for which the {@link IByteBuffer} should be returned
                @return the {@link IByteBuffer} on the specified index
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.CompositeByteBuffer.InternalComponent(System.Int32)">
            <summary>
                Return the internal {@link IByteBuffer} on the specified index. Note that updating the indexes of the returned
                buffer will lead to an undefined behavior of this buffer.
                @param cIndex the index for which the {@link IByteBuffer} should be returned
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.CompositeByteBuffer.InternalComponentAtOffset(System.Int32)">
            <summary>
                Return the internal {@link IByteBuffer} on the specified offset. Note that updating the indexes of the returned
                buffer will lead to an undefined behavior of this buffer.
                @param offset the offset for which the {@link IByteBuffer} should be returned
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.CompositeByteBuffer.Consolidate">
            <summary>
                Consolidate the composed {@link IByteBuffer}s
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.CompositeByteBuffer.Consolidate(System.Int32,System.Int32)">
            <summary>
                Consolidate the composed {@link IByteBuffer}s
                @param cIndex the index on which to start to compose
                @param numComponents the number of components to compose
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.CompositeByteBuffer.DiscardReadComponents">
            <summary>
                Discard all {@link IByteBuffer}s which are read.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.DefaultByteBufferHolder.Equals(System.Object)">
            <summary>
            This implementation of the <see cref="M:DotNetty.Buffers.DefaultByteBufferHolder.Equals(System.Object)"/> operation is restricted to
            work only with instances of the same class. The reason for that is that
            Netty library already has a number of classes that extend <see cref="T:DotNetty.Buffers.DefaultByteBufferHolder"/> and
            override <see cref="M:DotNetty.Buffers.DefaultByteBufferHolder.Equals(System.Object)"/> method with an additional comparison logic and we
            need the symmetric property of the <see cref="M:DotNetty.Buffers.DefaultByteBufferHolder.Equals(System.Object)"/> operation to be preserved.
            </summary>
            <param name="obj">the reference object with which to compare.</param>
            <returns><c>true</c> if this object is the same as the <paramref name="obj"/>
            argument; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:DotNetty.Buffers.DefaultByteBufferHolder.Equals(DotNetty.Buffers.IByteBufferHolder)">
            <summary>
            This implementation of the <see cref="M:DotNetty.Buffers.DefaultByteBufferHolder.Equals(DotNetty.Buffers.IByteBufferHolder)"/> operation is restricted to
            work only with instances of the same class. The reason for that is that
            Netty library already has a number of classes that extend <see cref="T:DotNetty.Buffers.DefaultByteBufferHolder"/> and
            override <see cref="M:DotNetty.Buffers.DefaultByteBufferHolder.Equals(DotNetty.Buffers.IByteBufferHolder)"/> method with an additional comparison logic and we
            need the symmetric property of the <see cref="M:DotNetty.Buffers.DefaultByteBufferHolder.Equals(DotNetty.Buffers.IByteBufferHolder)"/> operation to be preserved.
            </summary>
            <param name="other">the reference object with which to compare.</param>
            <returns><c>true</c> if this object is the same as the <paramref name="other"/>
            argument; <c>false</c> otherwise.</returns>
        </member>
        <member name="T:DotNetty.Buffers.EmptyByteBuffer">
            <inheritdoc />
            <summary>
                Represents an empty byte buffer
            </summary>
        </member>
        <member name="T:DotNetty.Buffers.FixedCompositeByteBuf">
            <summary>
            <see cref="T:DotNetty.Buffers.IByteBuffer"/> implementation which allows to wrap an array of <see cref="T:DotNetty.Buffers.IByteBuffer"/> in a read-only mode.
            This is useful to write an array of <see cref="T:DotNetty.Buffers.IByteBuffer"/>s.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.FixedCompositeByteBuf.Buffer(System.Int32)">
            <summary>
            Return the <see cref="T:DotNetty.Buffers.IByteBuffer"/> stored at the given index of the array.
            </summary>
        </member>
        <member name="T:DotNetty.Buffers.IByteBuffer">
            <summary>
                Inspired by the Netty ByteBuffer implementation
                (https://github.com/netty/netty/blob/master/buffer/src/main/java/io/netty/buffer/ByteBuf.java)
                Provides circular-buffer-esque security around a byte array, allowing reads and writes to occur independently.
                In general, the <see cref="T:DotNetty.Buffers.IByteBuffer" /> guarantees:
                /// <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> LESS THAN OR EQUAL TO <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> LESS THAN OR EQUAL TO
                <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />.
            </summary>
        </member>
        <member name="P:DotNetty.Buffers.IByteBuffer.Capacity">
            <summary>
            Returns the number of bytes (octets) this buffer can contain.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.AdjustCapacity(System.Int32)">
            <summary>
            Adjusts the capacity of this buffer.  If the <paramref name="newCapacity"/> is less than the current
            capacity, the content of this buffer is truncated.  If the <paramref name="newCapacity"/> is greater
            than the current capacity, the buffer is appended with unspecified data whose length is
            <code>newCapacity - currentCapacity</code>
            </summary>
        </member>
        <member name="P:DotNetty.Buffers.IByteBuffer.MaxCapacity">
            <summary>
            Returns the maximum allowed capacity of this buffer. This value provides an upper bound on <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity"/>
            </summary>
        </member>
        <member name="P:DotNetty.Buffers.IByteBuffer.Allocator">
            <summary>
            Returns the <see cref="T:DotNetty.Buffers.IByteBufferAllocator"/> which created this buffer.
            </summary>
        </member>
        <member name="P:DotNetty.Buffers.IByteBuffer.IsDirect">
            <summary>
            Returns <c>true</c> if and only if this buffer is backed by an direct buffer.
            </summary>
        </member>
        <member name="P:DotNetty.Buffers.IByteBuffer.IsReadOnly">
            <summary>
            Returns <c>true</c> if and only if this buffer is read-only.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.AsReadOnly">
            <summary>
            Returns a read-only version of this buffer.
            </summary>
            <returns></returns>
        </member>
        <member name="P:DotNetty.Buffers.IByteBuffer.ReaderIndex">
            <summary>
            Returns the <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex"/> of this buffer.
            </summary>
        </member>
        <member name="P:DotNetty.Buffers.IByteBuffer.WriterIndex">
            <summary>
            Returns the <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex"/> of this buffer.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.SetWriterIndex(System.Int32)">
            <summary>
                Sets the <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> of this buffer
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">thrown if <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> exceeds the length of the buffer</exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.SetReaderIndex(System.Int32)">
            <summary>
                Sets the <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> of this buffer
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                thrown if <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> is greater than
                <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> or less than <c>0</c>.
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.SetIndex(System.Int32,System.Int32)">
            <summary>
                Sets both indexes
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                thrown if <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> or <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> exceeds
                the length of the buffer
            </exception>
        </member>
        <member name="P:DotNetty.Buffers.IByteBuffer.ReadableBytes">
            <summary>
            Returns the number of readable bytes which is equal to
            <code>(this.writerIndex - this.readerIndex)</code>
            </summary>
        </member>
        <member name="P:DotNetty.Buffers.IByteBuffer.WritableBytes">
            <summary>
            Returns the number of writable bytes which is equal to
            <code>(this.capacity - this.writerIndex)</code>
            </summary>
        </member>
        <member name="P:DotNetty.Buffers.IByteBuffer.MaxWritableBytes">
            <summary>
            Returns the maximum possible number of writable bytes, which is equal to
            <code>(this.maxCapacity - this.writerIndex)</code>
            </summary>
        </member>
        <member name="P:DotNetty.Buffers.IByteBuffer.MaxFastWritableBytes">
            <summary>
            Returns the maximum number of bytes which can be written for certain without involving
            an internal reallocation or data-copy. The returned value will be &gt; <see cref="P:DotNetty.Buffers.IByteBuffer.WritableBytes"/>
            and &lt; <see cref="P:DotNetty.Buffers.IByteBuffer.MaxWritableBytes"/>.
            </summary>
        </member>
        <member name="P:DotNetty.Buffers.IByteBuffer.IsAccessible">
            <summary>
            Used internally by <see cref="M:DotNetty.Buffers.AbstractByteBuffer.EnsureAccessible"/> to try to guard
            against using the buffer after it was released (best-effort).
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.IsReadable">
            <summary>
                Returns true if <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> - <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> is greater than <c>0</c>.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.IsReadable(System.Int32)">
            <summary>
                Is the buffer readable if and only if the buffer contains equal or more than the specified number of elements
            </summary>
            <param name="size">The number of elements we would like to read</param>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.IsWritable">
            <summary>
                Returns true if and only if <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" /> - <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> is greater than zero.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.IsWritable(System.Int32)">
            <summary>
                Returns true if and only if the buffer has enough <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" /> to accomodate <paramref name="size" />
                additional bytes.
            </summary>
            <param name="size">The number of additional elements we would like to write.</param>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.Clear">
            <summary>
                Sets the <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> and <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> to <c>0</c>. Does not erase any of the data
                written into the buffer already,
                but it will overwrite that data.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.MarkReaderIndex">
            <summary>
                Marks the current <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> in this buffer. You can reposition the current
                <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" />
                to the marked <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> by calling <see cref="M:DotNetty.Buffers.IByteBuffer.ResetReaderIndex" />.
                The initial value of the marked <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> is <c>0</c>.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.ResetReaderIndex">
            <summary>
                Repositions the current <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> to the marked <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> in this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                is thrown if the current <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> is less than the
                marked <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.MarkWriterIndex">
            <summary>
                Marks the current <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> in this buffer. You can reposition the current
                <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" />
                to the marked <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> by calling <see cref="M:DotNetty.Buffers.IByteBuffer.ResetWriterIndex" />.
                The initial value of the marked <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> is <c>0</c>.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.ResetWriterIndex">
            <summary>
                Repositions the current <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> to the marked <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> in this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                is thrown if the current <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> is greater than the
                marked <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.DiscardReadBytes">
            <summary>
                Discards the bytes between the 0th index and <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" />.
                It moves the bytes between <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> and <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> to the 0th index,
                and sets <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> and <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> to <c>0</c> and
                <c>oldWriterIndex - oldReaderIndex</c> respectively.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.DiscardSomeReadBytes">
            <summary>
                Similar to <see cref="M:DotNetty.Buffers.IByteBuffer.DiscardReadBytes" /> except that this method might discard
                some, all, or none of read bytes depending on its internal implementation to reduce
                overall memory bandwidth consumption at the cost of potentially additional memory
                consumption.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.EnsureWritable(System.Int32)">
            <summary>
                Makes sure the number of <see cref="P:DotNetty.Buffers.IByteBuffer.WritableBytes" /> is equal to or greater than
                the specified value (<paramref name="minWritableBytes" />.) If there is enough writable bytes in this buffer,
                the method returns with no side effect. Otherwise, it raises an <see cref="T:System.ArgumentOutOfRangeException" />.
            </summary>
            <param name="minWritableBytes">The expected number of minimum writable bytes</param>
            <exception cref="T:System.IndexOutOfRangeException">
                if <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> + <paramref name="minWritableBytes" /> >
                <see cref="P:DotNetty.Buffers.IByteBuffer.MaxCapacity" />.
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.EnsureWritable(System.Int32,System.Boolean)">
            <summary>
                Tries to make sure the number of <see cref="P:DotNetty.Buffers.IByteBuffer.WritableBytes" />
                is equal to or greater than the specified value. Unlike <see cref="M:DotNetty.Buffers.IByteBuffer.EnsureWritable(System.Int32)" />,
                this method does not raise an exception but returns a code.
            </summary>
            <param name="minWritableBytes">the expected minimum number of writable bytes</param>
            <param name="force">
                When <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> + <c>minWritableBytes</c> > <see cref="P:DotNetty.Buffers.IByteBuffer.MaxCapacity" />:
                <ul>
                    <li><c>true</c> - the capacity of the buffer is expanded to <see cref="P:DotNetty.Buffers.IByteBuffer.MaxCapacity" /></li>
                    <li><c>false</c> - the capacity of the buffer is unchanged</li>
                </ul>
            </param>
            <returns>
                <c>0</c> if the buffer has enough writable bytes, and its capacity is unchanged.
                <c>1</c> if the buffer does not have enough bytes, and its capacity is unchanged.
                <c>2</c> if the buffer has enough writable bytes, and its capacity has been increased.
                <c>3</c> if the buffer does not have enough bytes, but its capacity has been increased to its maximum.
            </returns>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.GetBoolean(System.Int32)">
            <summary>
                Gets a boolean at the specified absolute <paramref name="index" /> in this buffer.
                This method does not modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" />
                of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index" /> is less than <c>0</c> or
                <c>index + 1</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.GetByte(System.Int32)">
            <summary>
                Gets a byte at the specified absolute <paramref name="index" /> in this buffer.
                This method does not modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" />
                of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index" /> is less than <c>0</c> or
                <c>index + 1</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.GetShort(System.Int32)">
            <summary>
                Gets a short at the specified absolute <paramref name="index" /> in this buffer.
                This method does not modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" />
                of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index" /> is less than <c>0</c> or
                <c>index + 2</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.GetShortLE(System.Int32)">
            <summary>
                Gets a short at the specified absolute <paramref name="index" /> in this buffer 
                in Little Endian Byte Order. This method does not modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> 
                or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index" /> is less than <c>0</c> or
                <c>index + 2</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.GetInt(System.Int32)">
            <summary>
                Gets an integer at the specified absolute <paramref name="index" /> in this buffer.
                This method does not modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" />
                of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index" /> is less than <c>0</c> or
                <c>index + 4</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.GetIntLE(System.Int32)">
            <summary>
                Gets an integer at the specified absolute <paramref name="index" /> in this buffer
                in Little Endian Byte Order. This method does not modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> 
                or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index" /> is less than <c>0</c> or
                <c>index + 4</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.GetLong(System.Int32)">
            <summary>
                Gets a long integer at the specified absolute <paramref name="index" /> in this buffer.
                This method does not modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" />
                of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index" /> is less than <c>0</c> or
                <c>index + 8</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.GetLongLE(System.Int32)">
            <summary>
                Gets a long integer at the specified absolute <paramref name="index" /> in this buffer
                in Little Endian Byte Order. This method does not modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> or 
                <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index" /> is less than <c>0</c> or
                <c>index + 8</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.GetUnsignedMedium(System.Int32)">
            <summary>
                Gets an unsigned 24-bit medium integer at the specified absolute index in this buffer.
                This method does not modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" />
                of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <param name="index"/> is less than <c>0</c> or
                <c>index + 3</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.GetUnsignedMediumLE(System.Int32)">
            <summary>
                Gets an unsigned 24-bit medium integer at the specified absolute index in this buffer
                in Little Endian Byte Order. This method does not modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> 
                or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <param name="index"/> is less than <c>0</c> or
                <c>index + 3</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.GetBytes(System.Int32,DotNetty.Buffers.IByteBuffer,System.Int32,System.Int32)">
            <summary>
                Transfers this buffers data to the specified <paramref name="destination" /> buffer starting at the specified
                absolute <paramref name="index" /> until the destination becomes non-writable.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index" /> is less than <c>0</c> or
                <c>index + 1</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.GetBytes(System.Int32,System.Byte[])">
            <summary>
                Transfers this buffers data to the specified <paramref name="destination" /> buffer starting at the specified
                absolute <paramref name="index" /> until the destination becomes non-writable.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index" /> is less than <c>0</c> or
                <c>index + 1</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.GetBytes(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
                Transfers this buffers data to the specified <paramref name="destination" /> buffer starting at the specified
                absolute <paramref name="index" /> until the destination becomes non-writable.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index" /> is less than <c>0</c> or
                <c>index + 1</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.GetBytes(System.Int32,System.IO.Stream,System.Int32)">
            <summary>
                Transfers this buffer's data to the specified stream starting at the
                specified absolute <c>index</c>.
            </summary>
            <remarks>
                This method does not modify <c>readerIndex</c> or <c>writerIndex</c> of
                this buffer.
            </remarks>
            <param name="index">absolute index in this buffer to start getting bytes from</param>
            <param name="destination">destination stream</param>
            <param name="length">the number of bytes to transfer</param>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <c>index</c> is less than <c>0</c> or
                if <c>index + length</c> is greater than
                <c>this.capacity</c>
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.GetCharSequence(System.Int32,System.Int32,System.Text.Encoding)">
            <summary>
            Gets a <see cref="T:DotNetty.Common.Utilities.ICharSequence"/> with the given length at the given index.
            </summary>
            <param name="index"></param>
            <param name="length">the length to read</param>
            <param name="encoding">that should be used</param>
            <returns>the sequence</returns>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.GetString(System.Int32,System.Int32,System.Text.Encoding)">
            <summary>
                Gets a string with the given length at the given index.
            </summary>
            <param name="index"></param>
            <param name="length">length the length to read</param>
            <param name="encoding">charset that should be use</param>
            <returns>the string value.</returns>
            <exception cref="T:System.IndexOutOfRangeException">
                if length is greater than readable bytes.
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.SetBoolean(System.Int32,System.Boolean)">
            <summary>
                Sets the specified boolean at the specified absolute <paramref name="index" /> in this buffer.
                This method does not directly modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index" /> is less than <c>0</c> or
                <c>index + 1</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.SetByte(System.Int32,System.Int32)">
            <summary>
                Sets the specified byte at the specified absolute <paramref name="index" /> in this buffer.
                This method does not directly modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index" /> is less than <c>0</c> or
                <c>index + 1</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.SetShort(System.Int32,System.Int32)">
            <summary>
                Sets the specified short at the specified absolute <paramref name="index" /> in this buffer.
                This method does not directly modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index" /> is less than <c>0</c> or
                <c>index + 2</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.SetShortLE(System.Int32,System.Int32)">
            <summary>
                Sets the specified short at the specified absolute <paramref name="index" /> in this buffer
                in the Little Endian Byte Order. This method does not directly modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> 
                or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index" /> is less than <c>0</c> or
                <c>index + 2</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.SetInt(System.Int32,System.Int32)">
            <summary>
                Sets the specified integer at the specified absolute <paramref name="index" /> in this buffer.
                This method does not directly modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index" /> is less than <c>0</c> or
                <c>index + 4</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.SetIntLE(System.Int32,System.Int32)">
            <summary>
                Sets the specified integer at the specified absolute <paramref name="index" /> in this buffer
                in the Little Endian Byte Order. This method does not directly modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> 
                or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index" /> is less than <c>0</c> or
                <c>index + 4</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.SetMedium(System.Int32,System.Int32)">
            <summary>
                Sets the specified 24-bit medium integer at the specified absolute <paramref name="index" /> in this buffer.
                Note that the most significant byte is ignored in the specified value.
                This method does not directly modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index" /> is less than <c>0</c> or
                <c>index + 3</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.SetMediumLE(System.Int32,System.Int32)">
            <summary>
                Sets the specified 24-bit medium integer at the specified absolute <paramref name="index" /> in this buffer.
                Note that the most significant byte is ignored in the specified value.
                This method does not directly modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index" /> is less than <c>0</c> or
                <c>index + 3</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.SetLong(System.Int32,System.Int64)">
            <summary>
                Sets the specified long integer at the specified absolute <paramref name="index" /> in this buffer.
                This method does not directly modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index" /> is less than <c>0</c> or
                <c>index + 8</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.SetLongLE(System.Int32,System.Int64)">
            <summary>
                Sets the specified long integer at the specified absolute <paramref name="index" /> in this buffer
                in the Little Endian Byte Order. This method does not directly modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> or 
                <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index" /> is less than <c>0</c> or
                <c>index + 8</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.SetBytes(System.Int32,DotNetty.Buffers.IByteBuffer,System.Int32)">
            <summary>
                Transfers the <paramref name="src" /> byte buffer's contents starting at the specified absolute <paramref name="index" />.
                This method does not directly modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index"/> is less than <c>0</c> or
                <paramref name="length"/> is less than <c>0</c> or
                <c><paramref name="index"/> + <paramref name="length"/></c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.SetBytes(System.Int32,DotNetty.Buffers.IByteBuffer,System.Int32,System.Int32)">
            <summary>
                Transfers the <paramref name="src" /> byte buffer's contents starting at the specified absolute <paramref name="index" />.
                This method does not directly modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index"/> is less than <c>0</c> or
                <paramref name="srcIndex"/> is less than <c>0</c> or
                <paramref name="length"/> is less than <c>0</c> or
                <c><paramref name="index"/> + <paramref name="length"/></c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" /> or
                <c><paramref name="srcIndex"/> + <paramref name="length"/></c> greater than <c><paramref name="src" />.Capacity</c>
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.SetBytes(System.Int32,System.Byte[])">
            <summary>
                Transfers the <paramref name="src" /> byte buffer's contents starting at the specified absolute <paramref name="index" />.
                This method does not directly modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index" /> is less than <c>0</c> or
                <c><paramref name="index"/> + <paramref name="src"/>.Length</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.SetBytes(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
                Transfers the <paramref name="src" /> byte buffer's contents starting at the specified absolute <paramref name="index" />.
                This method does not directly modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index"/> is less than <c>0</c> or
                <paramref name="srcIndex"/> is less than <c>0</c> or
                <paramref name="length"/> is less than <c>0</c> or
                <c><paramref name="index"/> + <paramref name="length"/></c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" /> or
                <c><paramref name="srcIndex"/> + <paramref name="length"/></c> greater than <c><paramref name="src" />.Length</c>
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.SetBytesAsync(System.Int32,System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
            <summary>
                Transfers the content of the specified source stream to this buffer
                starting at the specified absolute <paramref name="index"/>.
                This method does not modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex"/> or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex"/> of
                this buffer.
            </summary>
            <param name="index">absolute index in this byte buffer to start writing to</param>
            <param name="src"></param>
            <param name="length">number of bytes to transfer</param>
            <param name="cancellationToken">cancellation token</param>
            <returns>the actual number of bytes read in from the specified channel.</returns>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <c>index</c> is less than <c>0</c> or
                if <c>index + length</c> is greater than <c>this.capacity</c>
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.SetZero(System.Int32,System.Int32)">
            <summary>
                Fills this buffer with NULL (0x00) starting at the specified
                absolute index. This method does not modify reader index
                or writer index of this buffer
            </summary>
            <param name="index">absolute index in this byte buffer to start writing to</param>
            <param name="length">length the number of <tt>NUL</tt>s to write to the buffer</param>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified index is less than 0 or if index + length
                is greater than capacity.
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.SetCharSequence(System.Int32,DotNetty.Common.Utilities.ICharSequence,System.Text.Encoding)">
            <summary>
            Writes the specified <see cref="T:DotNetty.Common.Utilities.ICharSequence"/> at the current <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex"/> and increases
            the <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex"/> by the written bytes.
            </summary>
            <param name="index">on which the sequence should be written</param>
            <param name="sequence">to write</param>
            <param name="encoding">that should be used.</param>
            <returns>the written number of bytes.</returns>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.SetString(System.Int32,System.String,System.Text.Encoding)">
            <summary>
                Writes the specified string at the current writer index and increases
                the  writer index by the written bytes.
            </summary>
            <param name="index">Index on which the string should be written</param>
            <param name="value">The string value.</param>
            <param name="encoding">Encoding that should be used.</param>
            <returns>The written number of bytes.</returns>
            <exception cref="T:System.IndexOutOfRangeException">
               if writable bytes is not large enough to write the whole string.
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.ReadBoolean">
            <summary>
                Gets a boolean at the current <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> and increases the <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" />
                by <c>1</c> in this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if <see cref="P:DotNetty.Buffers.IByteBuffer.ReadableBytes" /> is less than <c>1</c></exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.ReadByte">
            <summary>
                Gets a byte at the current <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> and increases the <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" />
                by <c>1</c> in this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if <see cref="P:DotNetty.Buffers.IByteBuffer.ReadableBytes" /> is less than <c>1</c></exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.ReadShort">
            <summary>
                Gets a short at the current <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> and increases the <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" />
                by <c>2</c> in this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if <see cref="P:DotNetty.Buffers.IByteBuffer.ReadableBytes" /> is less than <c>2</c></exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.ReadShortLE">
            <summary>
                Gets a short at the current <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> in the Little Endian Byte Order and increases 
                the <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> by <c>2</c> in this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if <see cref="P:DotNetty.Buffers.IByteBuffer.ReadableBytes" /> is less than <c>2</c></exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.ReadMedium">
            <summary>
                Gets a 24-bit medium integer at the current <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> and increases the <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" />
                by <c>3</c> in this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if <see cref="P:DotNetty.Buffers.IByteBuffer.ReadableBytes" /> is less than <c>3</c></exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.ReadMediumLE">
            <summary>
                Gets a 24-bit medium integer at the current <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> in the Little Endian Byte Order and 
                increases the <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> by <c>3</c> in this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if <see cref="P:DotNetty.Buffers.IByteBuffer.ReadableBytes" /> is less than <c>3</c></exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.ReadUnsignedMedium">
            <summary>
                Gets an unsigned 24-bit medium integer at the current <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> and increases the <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" />
                by <c>3</c> in this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if <see cref="P:DotNetty.Buffers.IByteBuffer.ReadableBytes" /> is less than <c>3</c></exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.ReadUnsignedMediumLE">
            <summary>
                Gets an unsigned 24-bit medium integer at the current <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> in the Little Endian Byte Order 
                and increases the <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> by <c>3</c> in this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if <see cref="P:DotNetty.Buffers.IByteBuffer.ReadableBytes" /> is less than <c>3</c></exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.ReadInt">
            <summary>
                Gets an integer at the current <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> and increases the <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" />
                by <c>4</c> in this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if <see cref="P:DotNetty.Buffers.IByteBuffer.ReadableBytes" /> is less than <c>4</c></exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.ReadIntLE">
            <summary>
                Gets an integer at the current <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> in the Little Endian Byte Order and increases 
                the <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" />  by <c>4</c> in this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if <see cref="P:DotNetty.Buffers.IByteBuffer.ReadableBytes" /> is less than <c>4</c></exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.ReadLong">
            <summary>
                Gets an long at the current <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> and increases the <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> 
                by <c>8</c> in this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if <see cref="P:DotNetty.Buffers.IByteBuffer.ReadableBytes" /> is less than <c>4</c></exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.ReadLongLE">
            <summary>
                Gets an long at the current <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> in the Little Endian Byte Order and
                increases the <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> by <c>8</c> in this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if <see cref="P:DotNetty.Buffers.IByteBuffer.ReadableBytes" /> is less than <c>4</c></exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.ReadBytes(System.Int32)">
            <summary>
                Reads <paramref name="length" /> bytes from this buffer into a new destination buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if <see cref="P:DotNetty.Buffers.IByteBuffer.ReadableBytes" /> is less than <paramref name="length" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.ReadBytes(DotNetty.Buffers.IByteBuffer,System.Int32)">
            <summary>
            Transfers this buffer's data to the specified destination starting at
            the current <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex"/> and increases the <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex"/>
            by the number of the transferred bytes (= <paramref name="length"/>).  This method
            is basically same with <see cref="M:DotNetty.Buffers.IByteBuffer.ReadBytes(DotNetty.Buffers.IByteBuffer,System.Int32,System.Int32)"/>,
            except that this method increases the <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex"/> of the
            destination by the number of the transferred bytes (= <paramref name="length"/>)
            while <see cref="M:DotNetty.Buffers.IByteBuffer.ReadBytes(DotNetty.Buffers.IByteBuffer,System.Int32,System.Int32)"/> does not.
            </summary>
            <param name="destination"></param>
            <param name="length">the number of bytes to transfer</param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.ReadBytes(DotNetty.Buffers.IByteBuffer,System.Int32,System.Int32)">
            <summary>
            Transfers this buffer's data to the specified destination starting at
            the current <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex"/> and increases the <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex"/>
            by the number of the transferred bytes (= <paramref name="length"/>).
            </summary>
            <param name="destination"></param>
            <param name="dstIndex">the first index of the destination</param>
            <param name="length">the number of bytes to transfer</param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.ReadBytes(System.Byte[])">
            <summary>
            Transfers this buffer's data to the specified destination starting at
            the current <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex"/> and increases the <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex"/>
            by the number of the transferred bytes (= <see cref="P:System.Array.Length"/> of <paramref name="destination"/>).
            </summary>
            <param name="destination"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.ReadBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Transfers this buffer's data to the specified destination starting at
            the current <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex"/> and increases the <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex"/>
            by the number of the transferred bytes (= <paramref name="length"/>).
            </summary>
            <param name="destination"></param>
            <param name="dstIndex">the first index of the destination</param>
            <param name="length">the number of bytes to transfer</param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.ReadBytes(System.IO.Stream,System.Int32)">
            <summary>
            Transfers this buffer's data to the specified stream starting at the
            current <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex"/>.
            </summary>
            <param name="destination"></param>
            <param name="length">the number of bytes to transfer</param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.ReadCharSequence(System.Int32,System.Text.Encoding)">
            <summary>
            Gets a <see cref="T:DotNetty.Common.Utilities.ICharSequence"/> with the given length at the current <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex"/>
            and increases the <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex"/> by the given length.
            </summary>
            <param name="length">the length to read</param>
            <param name="encoding">that should be used</param>
            <returns>the sequence</returns>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.ReadString(System.Int32,System.Text.Encoding)">
            <summary>
                Gets a string with the given length at the current reader index
                and increases the reader index by the given length.
            </summary>
            <param name="length">The length to read</param>
            <param name="encoding">Encoding that should be used</param>
            <returns>The string value</returns>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.SkipBytes(System.Int32)">
            <summary>
                Increases the current <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> by the specified <paramref name="length" /> in this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException"> if <paramref name="length" /> is greater than <see cref="P:DotNetty.Buffers.IByteBuffer.ReadableBytes" />.</exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.WriteBoolean(System.Boolean)">
            <summary>
            Sets the specified boolean at the current <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex"/>
            and increases the <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex"/> by <c>1</c> in this buffer.
            If <see cref="P:DotNetty.Buffers.IByteBuffer.WritableBytes"/> is less than <c>1</c>, <see cref="M:DotNetty.Buffers.IByteBuffer.EnsureWritable(System.Int32)"/>
            will be called in an attempt to expand capacity to accommodate.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:DotNetty.Buffers.IByteBuffer.IsSingleIoBuffer">
            <summary>Checks if the specified <see cref="T:DotNetty.Buffers.IByteBuffer"/> is a direct buffer and is composed of a single NIO buffer.</summary>
            <remarks>We check this because otherwise we need to make it a non-composite buffer.</remarks>
        </member>
        <member name="P:DotNetty.Buffers.IByteBuffer.IoBufferCount">
            <summary>
                Returns the maximum <see cref="T:System.ArraySegment`1" /> of <see cref="T:System.Byte" /> that this buffer holds. Note that
                <see cref="M:DotNetty.Buffers.IByteBufferExtensions.GetIoBuffers(DotNetty.Buffers.IByteBuffer)" />
                or <see cref="M:DotNetty.Buffers.IByteBuffer.GetIoBuffers(System.Int32,System.Int32)" /> might return a less number of <see cref="T:System.ArraySegment`1" />s of
                <see cref="T:System.Byte" />.
            </summary>
            <returns>
                <c>-1</c> if this buffer cannot represent its content as <see cref="T:System.ArraySegment`1" /> of <see cref="T:System.Byte" />.
                the number of the underlying <see cref="T:DotNetty.Buffers.IByteBuffer"/>s if this buffer has at least one underlying segment.
                Note that this method does not return <c>0</c> to avoid confusion.
            </returns>
            <seealso cref="M:DotNetty.Buffers.IByteBufferExtensions.GetIoBuffer(DotNetty.Buffers.IByteBuffer)" />
            <seealso cref="M:DotNetty.Buffers.IByteBuffer.GetIoBuffer(System.Int32,System.Int32)" />
            <seealso cref="M:DotNetty.Buffers.IByteBufferExtensions.GetIoBuffers(DotNetty.Buffers.IByteBuffer)" />
            <seealso cref="M:DotNetty.Buffers.IByteBuffer.GetIoBuffers(System.Int32,System.Int32)" />
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.GetIoBuffer(System.Int32,System.Int32)">
            <summary>
                Exposes this buffer's sub-region as an <see cref="T:System.ArraySegment`1" /> of <see cref="T:System.Byte" />. Returned segment
                shares the content with this buffer. This method does not
                modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> of this buffer. Please note that the
                returned segment will not see the changes of this buffer if this buffer is a dynamic
                buffer and it adjusted its capacity.
            </summary>
            <exception cref="T:System.NotSupportedException">
                if this buffer cannot represent its content as <see cref="T:System.ArraySegment`1" />
                of <see cref="T:System.Byte" />
            </exception>
            <seealso cref="P:DotNetty.Buffers.IByteBuffer.IoBufferCount" />
            <seealso cref="M:DotNetty.Buffers.IByteBufferExtensions.GetIoBuffers(DotNetty.Buffers.IByteBuffer)" />
            <seealso cref="M:DotNetty.Buffers.IByteBuffer.GetIoBuffers(System.Int32,System.Int32)" />
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.GetIoBuffers(System.Int32,System.Int32)">
            <summary>
                Exposes this buffer's bytes as an array of <see cref="T:System.ArraySegment`1" /> of <see cref="T:System.Byte" /> for the specified
                index and length.
                Returned segments share the content with this buffer. This method does
                not modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> of this buffer. Please note that
                returned segments will not see the changes of this buffer if this buffer is a dynamic
                buffer and it adjusted its capacity.
            </summary>
            <exception cref="T:System.NotSupportedException">
                if this buffer cannot represent its content with <see cref="T:System.ArraySegment`1" />
                of <see cref="T:System.Byte" />
            </exception>
            <seealso cref="P:DotNetty.Buffers.IByteBuffer.IoBufferCount" />
            <seealso cref="M:DotNetty.Buffers.IByteBufferExtensions.GetIoBuffer(DotNetty.Buffers.IByteBuffer)" />
            <seealso cref="M:DotNetty.Buffers.IByteBuffer.GetIoBuffer(System.Int32,System.Int32)" />
        </member>
        <member name="P:DotNetty.Buffers.IByteBuffer.HasArray">
            <summary>
                Flag that indicates if this <see cref="T:DotNetty.Buffers.IByteBuffer" /> is backed by a byte array or not
            </summary>
        </member>
        <member name="P:DotNetty.Buffers.IByteBuffer.Array">
            <summary>
                Grabs the underlying byte array for this buffer
            </summary>
        </member>
        <member name="P:DotNetty.Buffers.IByteBuffer.HasMemoryAddress">
            <summary>
            Returns <c>true</c> if and only if this buffer has a reference to the low-level memory address that points
            to the backing data.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.GetPinnableMemoryAddress">
            <summary>
             Returns the low-level memory address that point to the first byte of ths backing data.
            </summary>
            <returns>The low-level memory address</returns>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.AddressOfPinnedMemory">
            <summary>
            Returns the pointer address of the buffer if the memory is pinned.
            </summary>
            <returns>IntPtr.Zero if not pinned.</returns>
        </member>
        <member name="P:DotNetty.Buffers.IByteBuffer.IsContiguous">
            <summary>
            Returns <c>true</c> if this <see cref="T:DotNetty.Buffers.IByteBuffer"/> implementation is backed by a single memory region.
            Composite buffer implementations must return false even if they currently hold &lt; 1 components.
            For buffers that return <c>true</c>, it's guaranteed that a successful call to <see cref="M:DotNetty.Buffers.IByteBuffer.DiscardReadBytes"/>
            will increase the value of <see cref="P:DotNetty.Buffers.IByteBuffer.MaxFastWritableBytes"/> by the current <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex"/>.
            
            <para>This method will return <c>false</c> by default, and a <c>false</c> return value does not necessarily
            mean that the implementation is composite or that it is <i>not</i> backed by a single memory region.</para>
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.Duplicate">
            <summary>
                Creates a deep clone of the existing byte array and returns it
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.Unwrap">
            <summary>
            Return the underlying buffer instance if this buffer is a wrapper of another buffer.
            </summary>
            <remarks>return <code>null</code> if this buffer is not a wrapper</remarks>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.Copy(System.Int32,System.Int32)">
            <summary>
            Returns a copy of this buffer's sub-region.  Modifying the content of
            the returned buffer or this buffer does not affect each other at all.
            This method does not modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex"/> or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex"/> of
            this buffer.
            </summary>
            <param name="index"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.Slice">
            <summary>
            Returns a slice of this buffer's readable bytes. Modifying the content
            of the returned buffer or this buffer affects each other's content
            while they maintain separate indexes and marks.  This method is
            identical to <code>buf.Slice(buf.ReaderIndex, buf.ReadableBytes)</code>.
            This method does not modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex"/> or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex"/> of
            this buffer.
            </summary>
            <remarks>
            Also be aware that this method will NOT call <see cref="M:DotNetty.Common.IReferenceCounted.Retain"/> and so the
            reference count will NOT be increased.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.RetainedSlice">
            <summary>
            Returns a retained slice of this buffer's readable bytes. Modifying the content
            of the returned buffer or this buffer affects each other's content
            while they maintain separate indexes and marks.  This method is
            identical to <code>buf.Slice(buf.ReaderIndex, buf.ReadableBytes)</code>.
            This method does not modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex"/> or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex"/> of
            this buffer.
            </summary>
            <remarks>
            Note that this method returns a {@linkplain #retain() retained} buffer unlike <see cref="M:DotNetty.Buffers.IByteBuffer.Slice"/>.
            This method behaves similarly to {@code slice().retain()} except that this method may return
            a buffer implementation that produces less garbage.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.Slice(System.Int32,System.Int32)">
            <summary>
            Returns a slice of this buffer's sub-region. Modifying the content of
            the returned buffer or this buffer affects each other's content while
            they maintain separate indexes and marks.
            This method does not modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex"/> or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex"/> of
            this buffer.
            </summary>
            <remarks>
            Also be aware that this method will NOT call <see cref="M:DotNetty.Common.IReferenceCounted.Retain"/> and so the
            reference count will NOT be increased.
            </remarks>
            <param name="index"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.RetainedSlice(System.Int32,System.Int32)">
            <summary>
            Returns a retained slice of this buffer's sub-region. Modifying the content of
            the returned buffer or this buffer affects each other's content while
            they maintain separate indexes and marks.
            This method does not modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex"/> or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex"/> of
            this buffer.
            </summary>
            <remarks>
            Note that this method returns a {@linkplain #retain() retained} buffer unlike <see cref="M:DotNetty.Buffers.IByteBuffer.Slice(System.Int32,System.Int32)"/>.
            This method behaves similarly to {@code slice(...).retain()} except that this method may return
            a buffer implementation that produces less garbage.
            </remarks>
            <param name="index"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.ReadSlice(System.Int32)">
            <summary>
            Returns a new slice of this buffer's sub-region starting at the current
            <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex"/> and increases the <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex"/> by the size
            of the new slice (= <paramref name="length"/>).
            </summary>
            <remarks>
            Also be aware that this method will NOT call <see cref="M:DotNetty.Common.IReferenceCounted.Retain"/> and so the
            reference count will NOT be increased.
            </remarks>
            <param name="length">the size of the new slice</param>
            <returns>the newly created slice</returns>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.ReadRetainedSlice(System.Int32)">
            <summary>
            Returns a new retained slice of this buffer's sub-region starting at the current
            <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex"/> and increases the <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex"/> by the size
            of the new slice (= <paramref name="length"/>).
            </summary>
            <remarks>
            Note that this method returns a {@linkplain #retain() retained} buffer unlike <see cref="M:DotNetty.Buffers.IByteBuffer.ReadSlice(System.Int32)"/>.
            This method behaves similarly to {@code readSlice(...).retain()} except that this method may return
            a buffer implementation that produces less garbage.
            </remarks>
            <param name="length">the size of the new slice</param>
            <returns>the newly created slice</returns>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.WriteZero(System.Int32)">
            <summary>
            Fills this buffer with <tt>NUL (0x00)</tt> starting at the current
            <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex"/> and increases the <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex"/> by the
            specified <paramref name="length"/>}.
            </summary>
            <remarks>If <see cref="P:DotNetty.Buffers.IByteBuffer.WritableBytes"/> is less than <paramref name="length"/>, <see cref="M:DotNetty.Buffers.IByteBuffer.EnsureWritable(System.Int32)"/>
            will be called in an attempt to expand capacity to accommodate.</remarks>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.WriteCharSequence(DotNetty.Common.Utilities.ICharSequence,System.Text.Encoding)">
            <summary>
            Writes the specified <see cref="T:DotNetty.Common.Utilities.ICharSequence"/> at the current <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex"/> and increases
            the <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex"/> by the written bytes.
            in this buffer.
            If {<see cref="P:DotNetty.Buffers.IByteBuffer.WritableBytes"/> is not large enough to write the whole sequence,
            <see cref="M:DotNetty.Buffers.IByteBuffer.EnsureWritable(System.Int32)"/> will be called in an attempt to expand capacity to accommodate.
            </summary>
            <param name="sequence">to write</param>
            <param name="encoding">that should be used</param>
            <returns>the written number of bytes</returns>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.WriteString(System.String,System.Text.Encoding)">
            <summary>
            Writes the specified <see cref="T:System.String"/> at the current <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex"/> and increases
            the <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex"/> by the written bytes.
            in this buffer.
            If {<see cref="P:DotNetty.Buffers.IByteBuffer.WritableBytes"/> is not large enough to write the whole sequence,
            <see cref="M:DotNetty.Buffers.IByteBuffer.EnsureWritable(System.Int32)"/> will be called in an attempt to expand capacity to accommodate.
            </summary>
            <param name="value">to write</param>
            <param name="encoding">that should be used</param>
            <returns>the written number of bytes</returns>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.ForEachByte(System.Int32,System.Int32,DotNetty.Common.Utilities.IByteProcessor)">
            <summary>
                Iterates over the specified area of this buffer with the specified <paramref name="processor"/> in ascending order.
                (i.e. <paramref name="index"/>, <c>(index + 1)</c>,  .. <c>(index + length - 1)</c>)
            </summary>
            <returns>
                <c>-1</c> if the processor iterated to or beyond the end of the specified area.
                The last-visited index If the <see cref="M:DotNetty.Common.Utilities.IByteProcessor.Process(System.Byte)"/> returned <c>false</c>.
            </returns>
            <param name="index">Index.</param>
            <param name="length">Length.</param>
            <param name="processor">Processor.</param>
        </member>
        <member name="M:DotNetty.Buffers.IByteBuffer.ForEachByteDesc(System.Int32,System.Int32,DotNetty.Common.Utilities.IByteProcessor)">
            <summary>
                Iterates over the specified area of this buffer with the specified <paramref name="processor"/> in descending order.
                (i.e. <c>(index + length - 1)</c>, <c>(index + length - 2)</c>, ... <paramref name="index"/>)
            </summary>
            <returns>
                <c>-1</c> if the processor iterated to or beyond the beginning of the specified area.
                The last-visited index If the <see cref="M:DotNetty.Common.Utilities.IByteProcessor.Process(System.Byte)"/> returned <c>false</c>.
            </returns>
            <param name="index">Index.</param>
            <param name="length">Length.</param>
            <param name="processor">Processor.</param>
        </member>
        <member name="T:DotNetty.Buffers.IByteBufferAllocator">
            <summary>
                Thread-safe interface for allocating <see cref="T:DotNetty.Buffers.IByteBuffer" />/.
            </summary>
        </member>
        <member name="P:DotNetty.Buffers.IByteBufferAllocatorMetric.UsedHeapMemory">
            <summary>
            Returns the number of bytes of heap memory used by a {@link ByteBufAllocator} or {@code -1} if unknown.
            </summary>
        </member>
        <member name="P:DotNetty.Buffers.IByteBufferAllocatorMetric.UsedDirectMemory">
            <summary>
             Returns the number of bytes of direct memory used by a {@link ByteBufAllocator} or {@code -1} if unknown.
            </summary>
        </member>
        <member name="P:DotNetty.Buffers.IByteBufferAllocatorMetricProvider.Metric">
            <summary>
            Returns a <see cref="T:DotNetty.Buffers.IByteBufferAllocatorMetric"/> for a <see cref="T:DotNetty.Buffers.IByteBufferAllocator"/>
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.IByteBufferExtensions.GetMedium(DotNetty.Buffers.IByteBuffer,System.Int32)">
            <summary>
                Gets a 24-bit medium integer at the specified absolute index in this buffer.
                This method does not modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" />
                of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index"/>  is less than <c>0</c> or
                <c>index + 3</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBufferExtensions.GetMediumLE(DotNetty.Buffers.IByteBuffer,System.Int32)">
            <summary>
                Gets a 24-bit medium integer at the specified absolute index in this buffer
                in Little Endian Byte Order. This method does not modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> 
                or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index"/> is less than <c>0</c> or
                <c>index + 3</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBufferExtensions.GetUnsignedShort(DotNetty.Buffers.IByteBuffer,System.Int32)">
            <summary>
                Gets an ushort at the specified absolute <paramref name="index" /> in this buffer.
                This method does not modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" />
                of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index" /> is less than <c>0</c> or
                <c>index + 2</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBufferExtensions.GetUnsignedShortLE(DotNetty.Buffers.IByteBuffer,System.Int32)">
            <summary>
                Gets an ushort at the specified absolute <paramref name="index" /> in this buffer 
                in Little Endian Byte Order. This method does not modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> 
                or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index" /> is less than <c>0</c> or
                <c>index + 2</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBufferExtensions.GetUnsignedInt(DotNetty.Buffers.IByteBuffer,System.Int32)">
            <summary>
                Gets an unsigned integer at the specified absolute <paramref name="index" /> in this buffer.
                This method does not modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" />
                of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index" /> is less than <c>0</c> or
                <c>index + 4</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBufferExtensions.GetUnsignedIntLE(DotNetty.Buffers.IByteBuffer,System.Int32)">
            <summary>
                Gets an unsigned integer at the specified absolute <paramref name="index" /> in this buffer
                in Little Endian Byte Order. This method does not modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> 
                or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index" /> is less than <c>0</c> or
                <c>index + 4</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBufferExtensions.GetChar(DotNetty.Buffers.IByteBuffer,System.Int32)">
            <summary>
                Gets a char at the specified absolute <paramref name="index" /> in this buffer.
                This method does not modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" />
                of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index" /> is less than <c>0</c> or
                <c>index + 2</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBufferExtensions.GetFloat(DotNetty.Buffers.IByteBuffer,System.Int32)">
            <summary>
                Gets a float at the specified absolute <paramref name="index"/> in this buffer.
                This method does not modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" />
                of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index"/> is less than <c>0</c> or
                <c>index + 4</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBufferExtensions.GetFloatLE(DotNetty.Buffers.IByteBuffer,System.Int32)">
            <summary>
                Gets a float at the specified absolute <paramref name="index"/> in this buffer
                in Little Endian Byte Order. This method does not modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> 
                or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index"/> is less than <c>0</c> or
                <c>index + 4</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBufferExtensions.GetDouble(DotNetty.Buffers.IByteBuffer,System.Int32)">
            <summary>
                Gets a double at the specified absolute <paramref name="index" /> in this buffer.
                This method does not modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" />
                of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index" /> is less than <c>0</c> or
                <c>index + 8</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBufferExtensions.GetDoubleLE(DotNetty.Buffers.IByteBuffer,System.Int32)">
            <summary>
                Gets a double at the specified absolute <paramref name="index" /> in this buffer
                in Little Endian Byte Order. This method does not modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> 
                or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index" /> is less than <c>0</c> or
                <c>index + 8</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBufferExtensions.GetBytes(DotNetty.Buffers.IByteBuffer,System.Int32,DotNetty.Buffers.IByteBuffer)">
            <summary>
                Transfers this buffers data to the specified <paramref name="destination" /> buffer starting at the specified
                absolute <paramref name="index" /> until the destination becomes non-writable.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index" /> is less than <c>0</c> or
                <c>index + 1</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBufferExtensions.GetBytes(DotNetty.Buffers.IByteBuffer,System.Int32,DotNetty.Buffers.IByteBuffer,System.Int32)">
            <summary>
                Transfers this buffers data to the specified <paramref name="destination" /> buffer starting at the specified
                absolute <paramref name="index" /> until the destination becomes non-writable.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index" /> is less than <c>0</c> or
                <c>index + 1</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBufferExtensions.ReadUnsignedShort(DotNetty.Buffers.IByteBuffer)">
            <summary>
                Gets an unsigned short at the current <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> and increases the <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" />
                by <c>2</c> in this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if <see cref="P:DotNetty.Buffers.IByteBuffer.ReadableBytes" /> is less than <c>2</c></exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBufferExtensions.ReadUnsignedShortLE(DotNetty.Buffers.IByteBuffer)">
            <summary>
                Gets an unsigned short at the current <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> in the Little Endian Byte Order and 
                increases the <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> by <c>2</c> in this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if <see cref="P:DotNetty.Buffers.IByteBuffer.ReadableBytes" /> is less than <c>2</c></exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBufferExtensions.ReadUnsignedInt(DotNetty.Buffers.IByteBuffer)">
            <summary>
                Gets an unsigned integer at the current <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> and increases the <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" />
                by <c>4</c> in this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if <see cref="P:DotNetty.Buffers.IByteBuffer.ReadableBytes" /> is less than <c>4</c></exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBufferExtensions.ReadUnsignedIntLE(DotNetty.Buffers.IByteBuffer)">
            <summary>
                Gets an unsigned integer at the current <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> in the Little Endian Byte Order and
                increases the <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> by <c>4</c> in this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if <see cref="P:DotNetty.Buffers.IByteBuffer.ReadableBytes" /> is less than <c>4</c></exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBufferExtensions.ReadChar(DotNetty.Buffers.IByteBuffer)">
            <summary>
                Gets a 2-byte UTF-16 character at the current <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> and increases the
                <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" />
                by <c>2</c> in this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if <see cref="P:DotNetty.Buffers.IByteBuffer.ReadableBytes" /> is less than <c>2</c></exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBufferExtensions.ReadFloat(DotNetty.Buffers.IByteBuffer)">
            <summary>
                Gets an 4-byte Decimaling integer at the current <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> and increases the
                <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" />
                by <c>4</c> in this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if <see cref="P:DotNetty.Buffers.IByteBuffer.ReadableBytes" /> is less than <c>4</c></exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBufferExtensions.ReadFloatLE(DotNetty.Buffers.IByteBuffer)">
            <summary>
                Gets an 4-byte Decimaling integer at the current <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> and increases the
                <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> by <c>4</c> in this buffer in Little Endian Byte Order.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if <see cref="P:DotNetty.Buffers.IByteBuffer.ReadableBytes" /> is less than <c>4</c></exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBufferExtensions.ReadDouble(DotNetty.Buffers.IByteBuffer)">
            <summary>
                Gets an 8-byte Decimaling integer at the current <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> and increases the
                <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" />
                by <c>8</c> in this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if <see cref="P:DotNetty.Buffers.IByteBuffer.ReadableBytes" /> is less than <c>8</c></exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBufferExtensions.ReadDoubleLE(DotNetty.Buffers.IByteBuffer)">
            <summary>
                Gets an 8-byte Decimaling integer at the current <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> and increases the
                <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> by <c>8</c> in this buffer in Little Endian Byte Order.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if <see cref="P:DotNetty.Buffers.IByteBuffer.ReadableBytes" /> is less than <c>8</c></exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBufferExtensions.ReadBytes(DotNetty.Buffers.IByteBuffer,DotNetty.Buffers.IByteBuffer)">
            <summary>
                Transfers bytes from this buffer's data into the specified destination buffer
                starting at the curent <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> until the destination becomes
                non-writable and increases the <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> by the number of transferred bytes.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if <c>destination.<see cref="P:DotNetty.Buffers.IByteBuffer.WritableBytes" /></c> is greater than
                <see cref="P:DotNetty.Buffers.IByteBuffer.ReadableBytes" />.
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBufferExtensions.SetUnsignedShort(DotNetty.Buffers.IByteBuffer,System.Int32,System.UInt16)">
            <summary>
                Sets the specified unsigned short at the specified absolute <paramref name="index" /> in this buffer.
                This method does not directly modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index" /> is less than <c>0</c> or
                <c>index + 2</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBufferExtensions.SetUnsignedShortLE(DotNetty.Buffers.IByteBuffer,System.Int32,System.UInt16)">
            <summary>
                Sets the specified unsigned short at the specified absolute <paramref name="index" /> in this buffer
                in the Little Endian Byte Order. This method does not directly modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> 
                or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index" /> is less than <c>0</c> or
                <c>index + 2</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBufferExtensions.SetChar(DotNetty.Buffers.IByteBuffer,System.Int32,System.Char)">
            <summary>
                Sets the specified UTF-16 char at the specified absolute <paramref name="index" /> in this buffer.
                This method does not directly modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index" /> is less than <c>0</c> or
                <c>index + 2</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBufferExtensions.SetUnsignedInt(DotNetty.Buffers.IByteBuffer,System.Int32,System.UInt32)">
            <summary>
                Sets the specified unsigned integer at the specified absolute <paramref name="index" /> in this buffer.
                This method does not directly modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index" /> is less than <c>0</c> or
                <c>index + 4</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBufferExtensions.SetUnsignedIntLE(DotNetty.Buffers.IByteBuffer,System.Int32,System.UInt32)">
            <summary>
                Sets the specified unsigned integer at the specified absolute <paramref name="index" /> in this buffer
                in the Little Endian Byte Order. This method does not directly modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> or 
                <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index" /> is less than <c>0</c> or
                <c>index + 4</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBufferExtensions.SetFloat(DotNetty.Buffers.IByteBuffer,System.Int32,System.Single)">
            <summary>
                Sets the specified float at the specified absolute <paramref name="index" /> in this buffer.
                This method does not directly modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index" /> is less than <c>0</c> or
                <c>index + 4</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBufferExtensions.SetFloatLE(DotNetty.Buffers.IByteBuffer,System.Int32,System.Single)">
            <summary>
                Sets the specified float at the specified absolute <paramref name="index" /> in this buffer
                in Little Endian Byte Order. This method does not directly modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> 
                or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index" /> is less than <c>0</c> or
                <c>index + 4</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBufferExtensions.SetDouble(DotNetty.Buffers.IByteBuffer,System.Int32,System.Double)">
            <summary>
                Sets the specified double at the specified absolute <paramref name="index" /> in this buffer.
                This method does not directly modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index" /> is less than <c>0</c> or
                <c>index + 8</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBufferExtensions.SetDoubleLE(DotNetty.Buffers.IByteBuffer,System.Int32,System.Double)">
            <summary>
                Sets the specified float at the specified absolute <paramref name="index" /> in this buffer
                in Little Endian Byte Order. This method does not directly modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> 
                or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index" /> is less than <c>0</c> or
                <c>index + 4</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBufferExtensions.SetBytes(DotNetty.Buffers.IByteBuffer,System.Int32,DotNetty.Buffers.IByteBuffer)">
            <summary>
                Transfers the <paramref name="src" /> byte buffer's contents starting at the specified absolute <paramref name="index" />.
                This method does not directly modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">
                if the specified <paramref name="index" /> is less than <c>0</c> or
                <c><paramref name="index"/> + <paramref name="src"/>.ReadableBytes</c> greater than <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" />
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.IByteBufferExtensions.Copy(DotNetty.Buffers.IByteBuffer)">
             <summary>
                 Returns a copy of this buffer's readable bytes. Modifying the content of the 
                 returned buffer or this buffer does not affect each other at all.This method is 
                 identical to {@code buf.copy(buf.readerIndex(), buf.readableBytes())}.
                 This method does not modify {@code readerIndex} or {@code writerIndex} of this buffer.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.IByteBufferExtensions.GetIoBuffer(DotNetty.Buffers.IByteBuffer)">
            <summary>
                Exposes this buffer's readable bytes as an <see cref="T:System.ArraySegment`1" /> of <see cref="T:System.Byte" />. Returned segment
                shares the content with this buffer. This method is identical
                to <c>buf.GetIoBuffer(buf.ReaderIndex, buf.ReadableBytes)</c>. This method does not
                modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> of this buffer.  Please note that the
                returned segment will not see the changes of this buffer if this buffer is a dynamic
                buffer and it adjusted its capacity.
            </summary>
            <exception cref="T:System.NotSupportedException">
                if this buffer cannot represent its content as <see cref="T:System.ArraySegment`1" />
                of <see cref="T:System.Byte" />
            </exception>
            <seealso cref="P:DotNetty.Buffers.IByteBuffer.IoBufferCount" />
            <seealso cref="M:DotNetty.Buffers.IByteBufferExtensions.GetIoBuffers(DotNetty.Buffers.IByteBuffer)" />
            <seealso cref="M:DotNetty.Buffers.IByteBuffer.GetIoBuffers(System.Int32,System.Int32)" />
        </member>
        <member name="M:DotNetty.Buffers.IByteBufferExtensions.GetIoBuffers(DotNetty.Buffers.IByteBuffer)">
            <summary>
                Exposes this buffer's readable bytes as an array of <see cref="T:System.ArraySegment`1" /> of <see cref="T:System.Byte" />. Returned
                segments
                share the content with this buffer. This method does not
                modify <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> or <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" /> of this buffer.  Please note that
                returned segments will not see the changes of this buffer if this buffer is a dynamic
                buffer and it adjusted its capacity.
            </summary>
            <exception cref="T:System.NotSupportedException">
                if this buffer cannot represent its content with <see cref="T:System.ArraySegment`1" />
                of <see cref="T:System.Byte" />
            </exception>
            <seealso cref="P:DotNetty.Buffers.IByteBuffer.IoBufferCount" />
            <seealso cref="M:DotNetty.Buffers.IByteBufferExtensions.GetIoBuffer(DotNetty.Buffers.IByteBuffer)" />
            <seealso cref="M:DotNetty.Buffers.IByteBuffer.GetIoBuffer(System.Int32,System.Int32)" />
        </member>
        <member name="M:DotNetty.Buffers.IByteBufferExtensions.ForEachByte(DotNetty.Buffers.IByteBuffer,DotNetty.Common.Utilities.IByteProcessor)">
            <summary>
                Iterates over the readable bytes of this buffer with the specified <c>processor</c> in ascending order.
            </summary>
            <returns>
                <c>-1</c> if the processor iterated to or beyond the end of the readable bytes.
                The last-visited index If the <see cref="M:DotNetty.Common.Utilities.IByteProcessor.Process(System.Byte)" /> returned <c>false</c>.
            </returns>
        </member>
        <member name="M:DotNetty.Buffers.IByteBufferExtensions.ForEachByteDesc(DotNetty.Buffers.IByteBuffer,DotNetty.Common.Utilities.IByteProcessor)">
            <summary>
                Iterates over the readable bytes of this buffer with the specified <paramref name="processor"/> in descending order.
            </summary>
            <returns>
                <c>-1</c> if the processor iterated to or beyond the beginning of the readable bytes.
                The last-visited index If the <see cref="M:DotNetty.Common.Utilities.IByteProcessor.Process(System.Byte)"/> returned <c>false</c>.
            </returns>
        </member>
        <member name="P:DotNetty.Buffers.IByteBufferHolder.Content">
            <summary>
                Return the data which is held by this {@link ByteBufHolder}.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.IByteBufferHolder.Copy">
            <summary>
                Create a deep copy of this {@link ByteBufHolder}.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.IByteBufferHolder.Duplicate">
            <summary>
                Duplicate the {@link ByteBufHolder}. Be aware that this will not automatically call {@link #retain()}.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.IByteBufferHolder.RetainedDuplicate">
            <summary>
                Duplicates this {@link ByteBufHolder}. This method returns a retained duplicate unlike {@link #duplicate()}.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.IByteBufferHolder.Replace(DotNetty.Buffers.IByteBuffer)">
            <summary>
               Returns a new {@link ByteBufHolder} which contains the specified {@code content}.
            </summary>
        </member>
        <member name="T:DotNetty.Buffers.Internal.Strings">
            <summary>
              一个强类型的资源类，用于查找本地化的字符串等。
            </summary>
        </member>
        <member name="P:DotNetty.Buffers.Internal.Strings.ResourceManager">
            <summary>
              返回此类使用的缓存的 ResourceManager 实例。
            </summary>
        </member>
        <member name="P:DotNetty.Buffers.Internal.Strings.Culture">
            <summary>
              重写当前线程的 CurrentUICulture 属性
              重写当前线程的 CurrentUICulture 属性。
            </summary>
        </member>
        <member name="T:DotNetty.Buffers.ExceptionArgument">
            <summary>The convention for this enum is using the argument name as the enum name</summary>
        </member>
        <member name="T:DotNetty.Buffers.ExceptionResource">
            <summary>The convention for this enum is using the resource name as the enum name</summary>
        </member>
        <member name="P:DotNetty.Buffers.IPoolArenaMetric.NumThreadCaches">
            Returns the number of thread caches backed by this arena.
        </member>
        <member name="P:DotNetty.Buffers.IPoolArenaMetric.NumTinySubpages">
            Returns the number of tiny sub-pages for the arena.
        </member>
        <member name="P:DotNetty.Buffers.IPoolArenaMetric.NumSmallSubpages">
            Returns the number of small sub-pages for the arena.
        </member>
        <member name="P:DotNetty.Buffers.IPoolArenaMetric.NumChunkLists">
            Returns the number of chunk lists for the arena.
        </member>
        <member name="P:DotNetty.Buffers.IPoolArenaMetric.TinySubpages">
            Returns an unmodifiable {@link List} which holds {@link PoolSubpageMetric}s for tiny sub-pages.
        </member>
        <member name="P:DotNetty.Buffers.IPoolArenaMetric.SmallSubpages">
            Returns an unmodifiable {@link List} which holds {@link PoolSubpageMetric}s for small sub-pages.
        </member>
        <member name="P:DotNetty.Buffers.IPoolArenaMetric.ChunkLists">
            Returns an unmodifiable {@link List} which holds {@link PoolChunkListMetric}s.
        </member>
        <member name="P:DotNetty.Buffers.IPoolArenaMetric.NumAllocations">
            Return the number of allocations done via the arena. This includes all sizes.
        </member>
        <member name="P:DotNetty.Buffers.IPoolArenaMetric.NumTinyAllocations">
            Return the number of tiny allocations done via the arena.
        </member>
        <member name="P:DotNetty.Buffers.IPoolArenaMetric.NumSmallAllocations">
            Return the number of small allocations done via the arena.
        </member>
        <member name="P:DotNetty.Buffers.IPoolArenaMetric.NumNormalAllocations">
            Return the number of normal allocations done via the arena.
        </member>
        <member name="P:DotNetty.Buffers.IPoolArenaMetric.NumHugeAllocations">
            Return the number of huge allocations done via the arena.
        </member>
        <member name="P:DotNetty.Buffers.IPoolArenaMetric.NumDeallocations">
            Return the number of deallocations done via the arena. This includes all sizes.
        </member>
        <member name="P:DotNetty.Buffers.IPoolArenaMetric.NumTinyDeallocations">
            Return the number of tiny deallocations done via the arena.
        </member>
        <member name="P:DotNetty.Buffers.IPoolArenaMetric.NumSmallDeallocations">
            Return the number of small deallocations done via the arena.
        </member>
        <member name="P:DotNetty.Buffers.IPoolArenaMetric.NumNormalDeallocations">
            Return the number of normal deallocations done via the arena.
        </member>
        <member name="P:DotNetty.Buffers.IPoolArenaMetric.NumHugeDeallocations">
            Return the number of huge deallocations done via the arena.
        </member>
        <member name="P:DotNetty.Buffers.IPoolArenaMetric.NumActiveAllocations">
            Return the number of currently active allocations.
        </member>
        <member name="P:DotNetty.Buffers.IPoolArenaMetric.NumActiveTinyAllocations">
            Return the number of currently active tiny allocations.
        </member>
        <member name="P:DotNetty.Buffers.IPoolArenaMetric.NumActiveSmallAllocations">
            Return the number of currently active small allocations.
        </member>
        <member name="P:DotNetty.Buffers.IPoolArenaMetric.NumActiveNormalAllocations">
            Return the number of currently active normal allocations.
        </member>
        <member name="P:DotNetty.Buffers.IPoolArenaMetric.NumActiveHugeAllocations">
            Return the number of currently active huge allocations.
        </member>
        <member name="P:DotNetty.Buffers.IPoolArenaMetric.NumActiveBytes">
            Return the number of active bytes that are currently allocated by the arena.
        </member>
        <member name="P:DotNetty.Buffers.IPoolChunkListMetric.MinUsage">
            Return the minum usage of the chunk list before which chunks are promoted to the previous list.
        </member>
        <member name="P:DotNetty.Buffers.IPoolChunkListMetric.MaxUsage">
            Return the minum usage of the chunk list after which chunks are promoted to the next list.
        </member>
        <member name="P:DotNetty.Buffers.IPoolChunkMetric.Usage">
            Return the percentage of the current usage of the chunk.
        </member>
        <member name="P:DotNetty.Buffers.IPoolChunkMetric.ChunkSize">
            Return the size of the chunk in bytes, this is the maximum of bytes that can be served out of the chunk.
        </member>
        <member name="P:DotNetty.Buffers.IPoolChunkMetric.FreeBytes">
            Return the number of free bytes in the chunk.
        </member>
        <member name="T:DotNetty.Buffers.IPoolMemoryOwner`1">
            <summary>A memory-owner that provides direct access to the root reference</summary>
        </member>
        <member name="P:DotNetty.Buffers.IPoolMemoryOwner`1.Origin">
            <summary>The root reference of the block, or a null-pointer if the data should not be considered pinned</summary>
        </member>
        <member name="P:DotNetty.Buffers.IPoolMemoryOwner`1.Length">
            <summary>Gets the size of the data</summary>
        </member>
        <member name="P:DotNetty.Buffers.IPoolSubpageMetric.MaxNumElements">
            Return the number of maximal elements that can be allocated out of the sub-page.
        </member>
        <member name="P:DotNetty.Buffers.IPoolSubpageMetric.NumAvailable">
            Return the number of available elements to be allocated.
        </member>
        <member name="P:DotNetty.Buffers.IPoolSubpageMetric.ElementSize">
            Return the size (in bytes) of the elements that will be allocated.
        </member>
        <member name="P:DotNetty.Buffers.IPoolSubpageMetric.PageSize">
            Return the size (in bytes) of this page.
        </member>
        <member name="T:DotNetty.Buffers.PoolChunk`1">
             <summary>
                 Description of algorithm for PageRun/PoolSubpage allocation from PoolChunk
                 Notation: The following terms are important to understand the code
                 > page  - a page is the smallest unit of memory chunk that can be allocated
                 > chunk - a chunk is a collection of pages
                 > in this code chunkSize = 2^{maxOrder} /// pageSize
                 To begin we allocate a byte array of size = chunkSize
                 Whenever a ByteBuf of given size needs to be created we search for the first position
                 in the byte array that has enough empty space to accommodate the requested size and
                 return a (long) handle that encodes this offset information, (this memory segment is then
                 marked as reserved so it is always used by exactly one ByteBuf and no more)
                 For simplicity all sizes are normalized according to PoolArena#normalizeCapacity method
                 This ensures that when we request for memory segments of size >= pageSize the normalizedCapacity
                 equals the next nearest power of 2
                 To search for the first offset in chunk that has at least requested size available we construct a
                 complete balanced binary tree and store it in an array (just like heaps) - memoryMap
                 The tree looks like this (the size of each node being mentioned in the parenthesis)
                 depth=0        1 node (chunkSize)
                 depth=1        2 nodes (chunkSize/2)
                 ..
                 ..
                 depth=d        2^d nodes (chunkSize/2^d)
                 ..
                 depth=maxOrder 2^maxOrder nodes (chunkSize/2^{maxOrder} = pageSize)
                 depth=maxOrder is the last level and the leafs consist of pages
                 With this tree available searching in chunkArray translates like this:
                 To allocate a memory segment of size chunkSize/2^k we search for the first node (from left) at height k
                 which is unused
                 Algorithm:
                 ----------
                 Encode the tree in memoryMap with the notation
                 memoryMap[id] = x => in the subtree rooted at id, the first node that is free to be allocated
                 is at depth x (counted from depth=0) i.e., at depths [depth_of_id, x), there is no node that is free
                 As we allocate and free nodes, we update values stored in memoryMap so that the property is maintained
                 Initialization -
                 In the beginning we construct the memoryMap array by storing the depth of a node at each node
                 i.e., memoryMap[id] = depth_of_id
                 Observations:
                 -------------
                 1) memoryMap[id] = depth_of_id  => it is free / unallocated
                 2) memoryMap[id] > depth_of_id  => at least one of its child nodes is allocated, so we cannot allocate it, but
                 some of its children can still be allocated based on their availability
                 3) memoryMap[id] = maxOrder + 1 => the node is fully allocated and thus none of its children can be allocated, it
                 is thus marked as unusable
                 Algorithm: [allocateNode(d) => we want to find the first node (from left) at height h that can be allocated]
                 ----------
                 1) start at root (i.e., depth = 0 or id = 1)
                 2) if memoryMap[1] > d => cannot be allocated from this chunk
                 3) if left node value &lt;= h; we can allocate from left subtree so move to left and repeat until found
                 4) else try in right subtree
                 Algorithm: [allocateRun(size)]
                 ----------
                 1) Compute d = log_2(chunkSize/size)
                 2) Return allocateNode(d)
                 Algorithm: [allocateSubpage(size)]
                 ----------
                 1) use allocateNode(maxOrder) to find an empty (i.e., unused) leaf (i.e., page)
                 2) use this handle to construct the PoolSubpage object or if it already exists just call init(normCapacity)
                 note that this PoolSubpage object is added to subpagesPool in the PoolArena when we init() it
                 Note:
                 -----
                 In the implementation for improving cache coherence,
                 we store 2 pieces of information depth_of_id and x as two byte values in memoryMap and depthMap respectively
            
                 memoryMap[id] = depth_of_id is defined above
                 depthMap[id] = x  indicates that the first node which is free to be allocated is at depth x(from root)
             </summary>
        </member>
        <member name="F:DotNetty.Buffers.PoolChunk`1._subpageOverflowMask">
            Used to determine if the requested capacity is equal to or greater than pageSize. 
        </member>
        <member name="F:DotNetty.Buffers.PoolChunk`1._unusable">
            Used to mark memory as unusable 
        </member>
        <member name="M:DotNetty.Buffers.PoolChunk`1.#ctor(DotNetty.Buffers.PoolArena{`0},`0,System.Int32,System.Int32,System.IntPtr)">
            Creates a special chunk that is not pooled. 
        </member>
        <member name="M:DotNetty.Buffers.PoolChunk`1.UpdateParentsAlloc(System.Int32)">
             Update method used by allocate
             This is triggered only when a successor is allocated and all its predecessors
             need to update their state
             The minimal depth at which subtree rooted at id has some free space
            
             @param id id
        </member>
        <member name="M:DotNetty.Buffers.PoolChunk`1.UpdateParentsFree(System.Int32)">
             Update method used by free
             This needs to handle the special case when both children are completely free
             in which case parent be directly allocated on request of size = child-size * 2
            
             @param id id
        </member>
        <member name="M:DotNetty.Buffers.PoolChunk`1.AllocateNode(System.Int32)">
             Algorithm to allocate an index in memoryMap when we query for a free node
             at depth d
            
             @param d depth
             @return index in memoryMap
        </member>
        <member name="M:DotNetty.Buffers.PoolChunk`1.AllocateRun(System.Int32)">
             Allocate a run of pages (>=1)
            
             @param normCapacity normalized capacity
             @return index in memoryMap
        </member>
        <member name="M:DotNetty.Buffers.PoolChunk`1.AllocateSubpage(System.Int32)">
             Create/ initialize a new PoolSubpage of normCapacity
             Any PoolSubpage created/ initialized here is added to subpage pool in the PoolArena that owns this PoolChunk
            
             @param normCapacity normalized capacity
             @return index in memoryMap
        </member>
        <member name="M:DotNetty.Buffers.PoolChunk`1.Free(System.Int64)">
             Free a subpage or a run of pages
             When a subpage is freed from PoolSubpage, it might be added back to subpage pool of the owning PoolArena
             If the subpage pool in PoolArena has at least one other PoolSubpage of given elemSize, we can
             completely free the owning Page so it is available for subsequent allocations
            
             @param handle handle to free
        </member>
        <member name="M:DotNetty.Buffers.PoolChunk`1.RunLength(System.Int32)">
            represents the size in #bytes supported by node 'id' in the tree
        </member>
        <member name="M:DotNetty.Buffers.PoolChunkList`1.CalculateMaxCapacity(System.Int32,System.Int32)">
            Calculates the maximum capacity of a buffer that will ever be possible to allocate out of the {@link PoolChunk}s
            that belong to the {@link PoolChunkList} with the given {@code minUsage} and {@code maxUsage} settings.
        </member>
        <member name="M:DotNetty.Buffers.PoolChunkList`1.Move0(DotNetty.Buffers.PoolChunk{`0})">
            Moves the {@link PoolChunk} down the {@link PoolChunkList} linked-list so it will end up in the right
            {@link PoolChunkList} that has the correct minUsage / maxUsage in respect to {@link PoolChunk#usage()}.
        </member>
        <member name="M:DotNetty.Buffers.PoolChunkList`1.Add0(DotNetty.Buffers.PoolChunk{`0})">
            Adds the {@link PoolChunk} to this {@link PoolChunkList}.
        </member>
        <member name="M:DotNetty.Buffers.PooledByteBuffer`1.Reuse(System.Int32)">
            Method must be called before reuse this {@link PooledByteBufAllocator}
        </member>
        <member name="M:DotNetty.Buffers.PooledByteBufferAllocator.DumpStats">
            Returns the status of the allocator (which contains all metrics) as string. Be aware this may be expensive
            and so should not called too frequently.
        </member>
        <member name="M:DotNetty.Buffers.PoolSubpage`1.#ctor(System.Int32)">
            Special constructor that creates a linked list head 
        </member>
        <member name="M:DotNetty.Buffers.PoolSubpage`1.Allocate">
            Returns the bitmap index of the subpage allocation.
        </member>
        <member name="M:DotNetty.Buffers.PoolSubpage`1.Free(DotNetty.Buffers.PoolSubpage{`0},System.Int32)">
            @return <c>true</c> if this subpage is in use.
                    <c>false</c> if this subpage is not used by its chunk and thus it's OK to be released.
        </member>
        <member name="T:DotNetty.Buffers.PoolThreadCache`1">
            <summary>
            Acts a Thread cache for allocations. This implementation is moduled after
            <a href="http://people.freebsd.org/~jasone/jemalloc/bsdcan2006/jemalloc.pdf">jemalloc</a> and the descripted
            technics of
            <a href="https://www.facebook.com/notes/facebook-engineering/scalable-memory-allocation-using-jemalloc/480222803919">
            Scalable memory allocation using jemalloc</a>.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.PoolThreadCache`1.AllocateTiny(DotNetty.Buffers.PoolArena{`0},DotNetty.Buffers.PooledByteBuffer{`0},System.Int32,System.Int32)">
            <summary>
            Try to allocate a tiny buffer out of the cache.
            </summary>
            <returns><c>true</c> if successful <c>false</c> otherwise</returns>
        </member>
        <member name="M:DotNetty.Buffers.PoolThreadCache`1.AllocateSmall(DotNetty.Buffers.PoolArena{`0},DotNetty.Buffers.PooledByteBuffer{`0},System.Int32,System.Int32)">
            <summary>
            Try to allocate a small buffer out of the cache.
            </summary>
            <returns><c>true</c> if successful <c>false</c> otherwise</returns>
        </member>
        <member name="M:DotNetty.Buffers.PoolThreadCache`1.AllocateNormal(DotNetty.Buffers.PoolArena{`0},DotNetty.Buffers.PooledByteBuffer{`0},System.Int32,System.Int32)">
            <summary>
            Try to allocate a small buffer out of the cache
            </summary>
            <returns><c>true</c> if successful <c>false</c> otherwise</returns>
        </member>
        <member name="M:DotNetty.Buffers.PoolThreadCache`1.Add(DotNetty.Buffers.PoolArena{`0},DotNetty.Buffers.PoolChunk{`0},System.Int64,System.Int32,DotNetty.Buffers.SizeClass)">
            <summary>
            Add <see cref="T:DotNetty.Buffers.PoolChunk`1"/> and <paramref name="handle"/> to the cache if there is enough room.
            </summary>
            <returns><c>true</c> if it fit into the cache <c>false</c> otherwise.</returns>
        </member>
        <member name="M:DotNetty.Buffers.PoolThreadCache`1.Free">
            <summary>
            Should be called if the Thread that uses this cache is about to exist to release resources out of the cache
            </summary>
        </member>
        <member name="T:DotNetty.Buffers.PoolThreadCache`1.SubPageMemoryRegionCache">
            <summary>
            Cache used for buffers which are backed by TINY or SMALL size.
            </summary>
        </member>
        <member name="T:DotNetty.Buffers.PoolThreadCache`1.NormalMemoryRegionCache">
            <summary>
            Cache used for buffers which are backed by NORMAL size.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.PoolThreadCache`1.MemoryRegionCache.InitBuf(DotNetty.Buffers.PoolChunk{`0},System.Int64,DotNetty.Buffers.PooledByteBuffer{`0},System.Int32,DotNetty.Buffers.PoolThreadCache{`0})">
            <summary>
            Init the <see cref="T:DotNetty.Buffers.PooledByteBuffer`1"/> using the provided chunk and handle with the capacity restrictions.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.PoolThreadCache`1.MemoryRegionCache.Add(DotNetty.Buffers.PoolChunk{`0},System.Int64)">
            <summary>
            Add to cache if not already full.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.PoolThreadCache`1.MemoryRegionCache.Allocate(DotNetty.Buffers.PooledByteBuffer{`0},System.Int32,DotNetty.Buffers.PoolThreadCache{`0})">
            <summary>
            Allocate something out of the cache if possible and remove the entry from the cache.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.PoolThreadCache`1.MemoryRegionCache.Free">
            <summary>
            Clear out this cache and free up all previous cached <see cref="T:DotNetty.Buffers.PoolChunk`1"/>s and {@code handle}s.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.PoolThreadCache`1.MemoryRegionCache.Trim">
            <summary>
            Free up cached <see cref="T:DotNetty.Buffers.PoolChunk`1"/>s if not allocated frequently enough.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferReader.#ctor(DotNetty.Buffers.IByteBuffer)">
            <summary>Create a <see cref="T:DotNetty.Buffers.ByteBufferReader" /> over the given <see cref="T:DotNetty.Buffers.IByteBuffer"/>.</summary>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferReader.#ctor(System.Buffers.ReadOnlySequence{System.Byte})">
            <summary>Create a <see cref="T:DotNetty.Buffers.ByteBufferReader" /> over the given <see cref="T:System.Buffers.ReadOnlySequence`1"/>.</summary>
        </member>
        <member name="P:DotNetty.Buffers.ByteBufferReader.IsLastSegment">
            <summary>Return true if we're in the last segment.</summary>
        </member>
        <member name="P:DotNetty.Buffers.ByteBufferReader.End">
            <summary>True when there is no more data in the <see cref="P:DotNetty.Buffers.ByteBufferReader.Sequence"/>.</summary>
        </member>
        <member name="P:DotNetty.Buffers.ByteBufferReader.Sequence">
            <summary>The underlying <see cref="T:System.Buffers.ReadOnlySequence`1"/> for the reader.</summary>
        </member>
        <member name="P:DotNetty.Buffers.ByteBufferReader.Position">
            <summary>The current position in the <see cref="P:DotNetty.Buffers.ByteBufferReader.Sequence"/>.</summary>
        </member>
        <member name="P:DotNetty.Buffers.ByteBufferReader.CurrentSpan">
            <summary>The current segment in the <see cref="P:DotNetty.Buffers.ByteBufferReader.Sequence"/>.</summary>
        </member>
        <member name="P:DotNetty.Buffers.ByteBufferReader.CurrentSpanIndex">
            <summary>The index in the <see cref="P:DotNetty.Buffers.ByteBufferReader.CurrentSpan"/>.</summary>
        </member>
        <member name="P:DotNetty.Buffers.ByteBufferReader.UnreadSpan">
            <summary>The unread portion of the <see cref="P:DotNetty.Buffers.ByteBufferReader.CurrentSpan"/>.</summary>
        </member>
        <member name="P:DotNetty.Buffers.ByteBufferReader.Consumed">
            <summary>The total number of <see cref="T:System.Byte"/>'s processed by the reader.</summary>
        </member>
        <member name="P:DotNetty.Buffers.ByteBufferReader.Remaining">
            <summary>Remaining <see cref="T:System.Byte"/>'s in the reader's <see cref="P:DotNetty.Buffers.ByteBufferReader.Sequence"/>.</summary>
        </member>
        <member name="P:DotNetty.Buffers.ByteBufferReader.Length">
            <summary>Count of <see cref="T:System.Byte"/> in the reader's <see cref="P:DotNetty.Buffers.ByteBufferReader.Sequence"/>.</summary>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferReader.TryPeek(System.Byte@)">
            <summary>Peeks at the next value without advancing the reader.</summary>
            <param name="value">The next value or default if at the end.</param>
            <returns>False if at the end of the reader.</returns>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferReader.TryRead(System.Byte@)">
            <summary>Read the next value and advance the reader.</summary>
            <param name="value">The next value or default if at the end.</param>
            <returns>False if at the end of the reader.</returns>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferReader.Rewind(System.Int64)">
            <summary>Move the reader back the specified number of items.</summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown if trying to rewind a negative amount or more than <see cref="P:DotNetty.Buffers.ByteBufferReader.Consumed"/>.
            </exception>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferReader.GetNextSpan">
            <summary>Get the next segment with available data, if any.</summary>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferReader.Advance(System.Int64)">
            <summary>Move the reader ahead the specified number of items.</summary>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferReader.AdvanceCurrentSpan(System.Int64)">
            <summary>Unchecked helper to avoid unnecessary checks where you know count is valid.</summary>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferReader.TryCopyTo(System.Span{System.Byte})">
            <summary>Copies data from the current <see cref="P:DotNetty.Buffers.ByteBufferReader.Position"/> to the given <paramref name="destination"/> span
            if there is enough data to fill it.</summary>
            <remarks>This API is used to copy a fixed amount of data out of the sequence if possible.
            It does not advance the reader.
            To look ahead for a specific stream of data <see cref="M:DotNetty.Buffers.ByteBufferReader.IsNext(System.ReadOnlySpan{System.Byte}@,System.Boolean)"/> can be used.</remarks>
            <param name="destination">Destination span to copy to.</param>
            <returns>True if there is enough data to completely fill the <paramref name="destination"/> span.</returns>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferReader.TryReadTo(System.ReadOnlySpan{System.Byte}@,System.Byte,System.Boolean)">
            <summary>Try to read everything up to the given <paramref name="delimiter"/>.</summary>
            <param name="span">The read data, if any.</param>
            <param name="delimiter">The delimiter to look for.</param>
            <param name="advancePastDelimiter">True to move past the <paramref name="delimiter"/> if found.</param>
            <returns>True if the <paramref name="delimiter"/> was found.</returns>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferReader.TryReadTo(System.ReadOnlySpan{System.Byte}@,System.Byte,System.Byte,System.Boolean)">
            <summary>Try to read everything up to the given <paramref name="delimiter"/>, ignoring delimiters that are
            preceded by <paramref name="delimiterEscape"/>.</summary>
            <param name="span">The read data, if any.</param>
            <param name="delimiter">The delimiter to look for.</param>
            <param name="delimiterEscape">If found prior to <paramref name="delimiter"/> it will skip that occurrence.</param>
            <param name="advancePastDelimiter">True to move past the <paramref name="delimiter"/> if found.</param>
            <returns>True if the <paramref name="delimiter"/> was found.</returns>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferReader.TryReadTo(System.Buffers.ReadOnlySequence{System.Byte}@,System.Byte,System.Boolean)">
            <summary>Try to read everything up to the given <paramref name="delimiter"/>.</summary>
            <param name="sequence">The read data, if any.</param>
            <param name="delimiter">The delimiter to look for.</param>
            <param name="advancePastDelimiter">True to move past the <paramref name="delimiter"/> if found.</param>
            <returns>True if the <paramref name="delimiter"/> was found.</returns>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferReader.TryReadTo(System.Buffers.ReadOnlySequence{System.Byte}@,System.Byte,System.Byte,System.Boolean)">
            <summary>Try to read everything up to the given <paramref name="delimiter"/>, ignoring delimiters that are
            preceded by <paramref name="delimiterEscape"/>.</summary>
            <param name="sequence">The read data, if any.</param>
            <param name="delimiter">The delimiter to look for.</param>
            <param name="delimiterEscape">If found prior to <paramref name="delimiter"/> it will skip that occurrence.</param>
            <param name="advancePastDelimiter">True to move past the <paramref name="delimiter"/> if found.</param>
            <returns>True if the <paramref name="delimiter"/> was found.</returns>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferReader.TryReadToAny(System.ReadOnlySpan{System.Byte}@,System.ReadOnlySpan{System.Byte}@,System.Boolean)">
            <summary>Try to read everything up to the given <paramref name="delimiters"/>.</summary>
            <param name="span">The read data, if any.</param>
            <param name="delimiters">The delimiters to look for.</param>
            <param name="advancePastDelimiter">True to move past the first found instance of any of the given <paramref name="delimiters"/>.</param>
            <returns>True if any of the <paramref name="delimiters"/> were found.</returns>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferReader.TryReadToAny(System.Buffers.ReadOnlySequence{System.Byte}@,System.ReadOnlySpan{System.Byte}@,System.Boolean)">
            <summary>Try to read everything up to the given <paramref name="delimiters"/>.</summary>
            <param name="sequence">The read data, if any.</param>
            <param name="delimiters">The delimiters to look for.</param>
            <param name="advancePastDelimiter">True to move past the first found instance of any of the given <paramref name="delimiters"/>.</param>
            <returns>True if any of the <paramref name="delimiters"/> were found.</returns>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferReader.TryReadTo(System.Buffers.ReadOnlySequence{System.Byte}@,System.ReadOnlySpan{System.Byte}@,System.Boolean)">
            <summary>Try to read data until the entire given <paramref name="delimiter"/> matches.</summary>
            <param name="sequence">The read data, if any.</param>
            <param name="delimiter">The multi (byte) delimiter.</param>
            <param name="advancePastDelimiter">True to move past the <paramref name="delimiter"/> if found.</param>
            <returns>True if the <paramref name="delimiter"/> was found.</returns>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferReader.TryAdvanceTo(System.Byte,System.Boolean)">
            <summary>Advance until the given <paramref name="delimiter"/>, if found.</summary>
            <param name="delimiter">The delimiter to search for.</param>
            <param name="advancePastDelimiter">True to move past the <paramref name="delimiter"/> if found.</param>
            <returns>True if the given <paramref name="delimiter"/> was found.</returns>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferReader.TryAdvanceToAny(System.ReadOnlySpan{System.Byte}@,System.Boolean)">
            <summary>Advance until any of the given <paramref name="delimiters"/>, if found.</summary>
            <param name="delimiters">The delimiters to search for.</param>
            <param name="advancePastDelimiter">True to move past the first found instance of any of the given <paramref name="delimiters"/>.</param>
            <returns>True if any of the given <paramref name="delimiters"/> were found.</returns>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferReader.AdvancePast(System.Byte)">
            <summary>Advance past consecutive instances of the given <paramref name="value"/>.</summary>
            <returns>How many positions the reader has been advanced.</returns>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferReader.AdvancePastAny(System.ReadOnlySpan{System.Byte}@)">
            <summary>Skip consecutive instances of any of the given <paramref name="values"/>.</summary>
            <returns>How many positions the reader has been advanced.</returns>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferReader.AdvancePastAny(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>Advance past consecutive instances of any of the given values.</summary>
            <returns>How many positions the reader has been advanced.</returns>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferReader.AdvancePastAny(System.Byte,System.Byte,System.Byte)">
            <summary>Advance past consecutive instances of any of the given values.</summary>
            <returns>How many positions the reader has been advanced.</returns>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferReader.AdvancePastAny(System.Byte,System.Byte)">
            <summary>Advance past consecutive instances of any of the given values.</summary>
            <returns>How many positions the reader has been advanced.</returns>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferReader.IsNext(System.Byte,System.Boolean)">
            <summary>Check to see if the given <paramref name="next"/> value is next.</summary>
            <param name="next">The value to compare the next items to.</param>
            <param name="advancePast">Move past the <paramref name="next"/> value if found.</param>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferReader.IsNext(System.ReadOnlySpan{System.Byte}@,System.Boolean)">
            <summary>Check to see if the given <paramref name="next"/> values are next.</summary>
            <param name="next">The span to compare the next items to.</param>
            <param name="advancePast">Move past the <paramref name="next"/> values if found.</param>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferReaderExtensions.CopyTo(DotNetty.Buffers.ByteBufferReader@,System.Span{System.Byte})">
            <summary>Copies data from the current <see cref="P:DotNetty.Buffers.ByteBufferReader.Position"/> to the given <paramref name="destination"/> span.</summary>
            <returns>True if there is enough data to copy to the <paramref name="destination"/>.</returns>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferReaderExtensions.Peek(DotNetty.Buffers.ByteBufferReader@,System.Int32)">
            <summary>Peek forward up to the number of positions specified by <paramref name="count"/>.</summary>
            <returns>Span over the peeked data.</returns>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferReaderExtensions.TryPeek(DotNetty.Buffers.ByteBufferReader@,System.Int32,System.ReadOnlySpan{System.Byte}@)">
            <summary>Peek forward up to the number of positions specified by <paramref name="count"/>.</summary>
            <returns>Span over the peeked data.</returns>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferReaderExtensions.TryRead``1(DotNetty.Buffers.ByteBufferReader@,``0@)">
            <summary>Try to read the given type out of the buffer if possible. Warning: this is dangerous to use with arbitrary
            structs- see remarks for full details.</summary>
            <remarks>IMPORTANT: The read is a straight copy of bits. If a struct depends on specific state of it's members to
            behave correctly this can lead to exceptions, etc. If reading endian specific integers, use the explicit
            overloads such as <see cref="M:DotNetty.Buffers.ByteBufferReaderExtensions.TryReadShortLE(DotNetty.Buffers.ByteBufferReader@,System.Int16@)"/>.</remarks>
            <returns>True if successful. <paramref name="value"/> will be default if failed (due to lack of space).</returns>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferReaderExtensions.TryReadShort(DotNetty.Buffers.ByteBufferReader@,System.Int16@)">
            <summary>Reads an <see cref="T:System.Int16"/> as big endian.</summary>
            <returns>False if there wasn't enough data for an <see cref="T:System.Int16"/>.</returns>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferReaderExtensions.TryReadShortLE(DotNetty.Buffers.ByteBufferReader@,System.Int16@)">
            <summary>Reads an <see cref="T:System.Int16"/> as little endian.</summary>
            <returns>False if there wasn't enough data for an <see cref="T:System.Int16"/>.</returns>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferReaderExtensions.TryReadUnsignedShort(DotNetty.Buffers.ByteBufferReader@,System.UInt16@)">
            <summary>Reads an <see cref="T:System.UInt16"/> as big endian.</summary>
            <returns>False if there wasn't enough data for an <see cref="T:System.UInt16"/>.</returns>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferReaderExtensions.TryReadUnsignedShortLE(DotNetty.Buffers.ByteBufferReader@,System.UInt16@)">
            <summary>Reads an <see cref="T:System.UInt16"/> as little endian.</summary>
            <returns>False if there wasn't enough data for an <see cref="T:System.UInt16"/>.</returns>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferReaderExtensions.TryReadInt(DotNetty.Buffers.ByteBufferReader@,System.Int32@)">
            <summary>Reads an <see cref="T:System.Int32"/> as big endian.</summary>
            <returns>False if there wasn't enough data for an <see cref="T:System.Int32"/>.</returns>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferReaderExtensions.TryReadIntLE(DotNetty.Buffers.ByteBufferReader@,System.Int32@)">
            <summary>Reads an <see cref="T:System.Int32"/> as little endian.</summary>
            <returns>False if there wasn't enough data for an <see cref="T:System.Int32"/>.</returns>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferReaderExtensions.TryReadUnsignedInt(DotNetty.Buffers.ByteBufferReader@,System.UInt32@)">
            <summary>Reads an <see cref="T:System.UInt32"/> as big endian.</summary>
            <returns>False if there wasn't enough data for an <see cref="T:System.UInt32"/>.</returns>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferReaderExtensions.TryReadUnsignedIntLE(DotNetty.Buffers.ByteBufferReader@,System.UInt32@)">
            <summary>Reads an <see cref="T:System.UInt32"/> as little endian.</summary>
            <returns>False if there wasn't enough data for an <see cref="T:System.UInt32"/>.</returns>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferReaderExtensions.TryReadLong(DotNetty.Buffers.ByteBufferReader@,System.Int64@)">
            <summary>Reads an <see cref="T:System.Int64"/> as big endian.</summary>
            <returns>False if there wasn't enough data for an <see cref="T:System.Int64"/>.</returns>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferReaderExtensions.TryReadLongLE(DotNetty.Buffers.ByteBufferReader@,System.Int64@)">
            <summary>Reads an <see cref="T:System.Int64"/> as little endian.</summary>
            <returns>False if there wasn't enough data for an <see cref="T:System.Int64"/>.</returns>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferReaderExtensions.TryReadUnsignedLong(DotNetty.Buffers.ByteBufferReader@,System.UInt64@)">
            <summary>Reads an <see cref="T:System.UInt64"/> as big endian.</summary>
            <returns>False if there wasn't enough data for an <see cref="T:System.UInt64"/>.</returns>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferReaderExtensions.TryReadUnsignedLongLE(DotNetty.Buffers.ByteBufferReader@,System.UInt64@)">
            <summary>Reads an <see cref="T:System.UInt64"/> as little endian.</summary>
            <returns>False if there wasn't enough data for an <see cref="T:System.UInt64"/>.</returns>
        </member>
        <member name="T:DotNetty.Buffers.ReadOnlyByteBuffer">
            <summary>
            A derived buffer which forbids any write requests to its parent.  It is
            recommended to use <see cref="M:DotNetty.Buffers.Unpooled.UnmodifiableBuffer(DotNetty.Buffers.IByteBuffer)"/>
            instead of calling the constructor explicitly.
            </summary>
        </member>
        <member name="T:DotNetty.Buffers.IMultiSearchProcessor">
            <summary>
            Interface for <see cref="T:DotNetty.Buffers.ISearchProcessor"/> that implements simultaneous search for multiple strings.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.IMultiSearchProcessor.GetFoundNeedleId">
            <summary>
            Return the index of found search string (if any, or -1 if none) at current position of this <see cref="T:DotNetty.Buffers.IMultiSearchProcessor"/>
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.IMultiSearchProcessorFactory.NewSearchProcessor">
            <summary>
            Returns a new <see cref="T:DotNetty.Buffers.IMultiSearchProcessor"/>.
            </summary>
        </member>
        <member name="T:DotNetty.Buffers.ISearchProcessor">
            <summary>
            Interface for <see cref="T:DotNetty.Common.Utilities.IByteProcessor"/> that implements string search.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.ISearchProcessor.Reset">
            <summary>
            Resets the state of <see cref="T:DotNetty.Buffers.ISearchProcessor"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.ISearchProcessorFactory.NewSearchProcessor">
            <summary>
            Returns a new <see cref="T:DotNetty.Buffers.ISearchProcessor"/>.
            </summary>
        </member>
        <member name="T:DotNetty.Buffers.Unpooled">
            <summary>
                Utility class for managing and creating unpooled buffers
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.Unpooled.WrappedBuffer(System.Byte[])">
            <summary>
                Creates a new big-endian buffer which wraps the specified array.
                A modification on the specified array's content will be visible to the returned buffer.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.Unpooled.WrappedBuffer(System.Byte[],System.Int32,System.Int32)">
            <summary>
                Creates a new big-endian buffer which wraps the sub-region of the
                specified array. A modification on the specified array's content 
                will be visible to the returned buffer.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.Unpooled.WrappedBuffer(DotNetty.Buffers.IByteBuffer)">
            <summary>
                Creates a new buffer which wraps the specified buffer's readable bytes.
                A modification on the specified buffer's content will be visible to the returned buffer.
            </summary>
            <param name="buffer">The buffer to wrap. Reference count ownership of this variable is transferred to this method.</param>
            <returns>The readable portion of the buffer, or an empty buffer if there is no readable portion.</returns>
        </member>
        <member name="M:DotNetty.Buffers.Unpooled.WrappedBuffer(System.Byte[][])">
            <summary>
                Creates a new big-endian composite buffer which wraps the specified arrays without copying them.
                A modification on the specified arrays' content will be visible to the returned buffer.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.Unpooled.WrappedBuffer(DotNetty.Buffers.IByteBuffer[])">
            <summary>
                Creates a new big-endian composite buffer which wraps the readable bytes of the specified buffers without copying them. 
                A modification on the content of the specified buffers will be visible to the returned buffer.
            </summary>
            <param name="buffers">The buffers to wrap. Reference count ownership of all variables is transferred to this method.</param>
            <returns>The readable portion of the buffers. The caller is responsible for releasing this buffer.</returns>
        </member>
        <member name="M:DotNetty.Buffers.Unpooled.WrappedBuffer(System.Int32,System.Byte[][])">
            <summary>
                Creates a new big-endian composite buffer which wraps the specified arrays without copying them.
                A modification on the specified arrays' content will be visible to the returned buffer.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.Unpooled.WrappedBuffer(System.Int32,DotNetty.Buffers.IByteBuffer[])">
            <summary>
                Creates a new big-endian composite buffer which wraps the readable bytes of the specified buffers without copying them.
                A modification on the content of the specified buffers will be visible to the returned buffer.
            </summary>
            <param name="maxNumComponents">Advisement as to how many independent buffers are allowed to exist before consolidation occurs.</param>
            <param name="buffers">The buffers to wrap. Reference count ownership of all variables is transferred to this method.</param>
            <returns>The readable portion of the buffers. The caller is responsible for releasing this buffer.</returns>
        </member>
        <member name="M:DotNetty.Buffers.Unpooled.CopiedBuffer(System.Byte[])">
            <summary>
                Creates a new big-endian buffer whose content is a copy of the specified array
                The new buffer's <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> and <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" />
                are <c>0</c> and <see cref="P:System.Array.Length" /> respectively.
            </summary>
            <param name="array">A buffer we're going to copy.</param>
            <returns>The new buffer that copies the contents of array.</returns>
        </member>
        <member name="M:DotNetty.Buffers.Unpooled.CopiedBuffer(System.Byte[],System.Int32,System.Int32)">
            <summary>
                Creates a new big-endian buffer whose content is a copy of the specified array.
                The new buffer's <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> and <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" />
                are <c>0</c> and <see cref="P:System.Array.Length" /> respectively.
            </summary>
            <param name="array">A buffer we're going to copy.</param>
            <param name="offset">The index offset from which we're going to read array.</param>
            <param name="length">
                The number of bytes we're going to read from array beginning from position offset.
            </param>
            <returns>The new buffer that copies the contents of array.</returns>
        </member>
        <member name="M:DotNetty.Buffers.Unpooled.CopiedBuffer(DotNetty.Buffers.IByteBuffer)">
            <summary>
                Creates a new big-endian buffer whose content is a copy of the specified <see cref="T:System.Array" />.
                The new buffer's <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> and <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" />
                are <c>0</c> and <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" /> respectively.
            </summary>
            <param name="buffer">A buffer we're going to copy.</param>
            <returns>The new buffer that copies the contents of buffer.</returns>
        </member>
        <member name="M:DotNetty.Buffers.Unpooled.CopiedBuffer(System.Byte[][])">
            <summary>
                Creates a new big-endian buffer whose content is a merged copy of of the specified arrays.
                The new buffer's <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> and <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" />
                are <c>0</c> and <see cref="P:System.Array.Length" /> respectively.
            </summary>
            <param name="arrays"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Buffers.Unpooled.CopiedBuffer(DotNetty.Buffers.IByteBuffer[])">
            <summary>
                Creates a new big-endian buffer whose content  is a merged copy of the specified <see cref="T:System.Array" />.
                The new buffer's <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" /> and <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" />
                are <c>0</c> and <see cref="P:DotNetty.Buffers.IByteBuffer.Capacity" /> respectively.
            </summary>
            <param name="buffers">Buffers we're going to copy.</param>
            <returns>The new buffer that copies the contents of buffers.</returns>
        </member>
        <member name="M:DotNetty.Buffers.Unpooled.CopyInt(System.Int32)">
            <summary>
                Creates a new 4-byte big-endian buffer that holds the specified 32-bit integer.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.Unpooled.CopyInt(System.Int32[])">
            <summary>
                Create a big-endian buffer that holds a sequence of the specified 32-bit integers.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.Unpooled.CopyShort(System.Int32)">
            <summary>
                Creates a new 2-byte big-endian buffer that holds the specified 16-bit integer.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.Unpooled.CopyShort(System.Int16[])">
            <summary>
                Create a new big-endian buffer that holds a sequence of the specified 16-bit integers.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.Unpooled.CopyShort(System.Int32[])">
            <summary>
                Create a new big-endian buffer that holds a sequence of the specified 16-bit integers.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.Unpooled.CopyMedium(System.Int32)">
            <summary>
                Creates a new 3-byte big-endian buffer that holds the specified 24-bit integer.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.Unpooled.CopyMedium(System.Int32[])">
            <summary>
                Create a new big-endian buffer that holds a sequence of the specified 24-bit integers.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.Unpooled.CopyLong(System.Int64)">
            <summary>
                Creates a new 8-byte big-endian buffer that holds the specified 64-bit integer.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.Unpooled.CopyLong(System.Int64[])">
            <summary>
                Create a new big-endian buffer that holds a sequence of the specified 64-bit integers.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.Unpooled.CopyBoolean(System.Boolean)">
            <summary>
                Creates a new single-byte big-endian buffer that holds the specified boolean value.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.Unpooled.CopyBoolean(System.Boolean[])">
            <summary>
                Create a new big-endian buffer that holds a sequence of the specified boolean values.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.Unpooled.CopyFloat(System.Single)">
            <summary>
                Creates a new 4-byte big-endian buffer that holds the specified 32-bit floating point number.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.Unpooled.CopyFloat(System.Single[])">
            <summary>
                Create a new big-endian buffer that holds a sequence of the specified 32-bit floating point numbers.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.Unpooled.CopyDouble(System.Double)">
            <summary>
                Creates a new 8-byte big-endian buffer that holds the specified 64-bit floating point number.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.Unpooled.CopyDouble(System.Double[])">
            <summary>
                Create a new big-endian buffer that holds a sequence of the specified 64-bit floating point numbers.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.Unpooled.UnreleasableBuffer(DotNetty.Buffers.IByteBuffer)">
            <summary>
                Return a unreleasable view on the given {@link ByteBuf} which will just ignore release and retain calls.
            </summary>
        </member>
        <member name="M:DotNetty.Buffers.Unpooled.EncodeString(System.String,System.Text.Encoding,System.Int32)">
            <summary>Encode the given <see cref="T:System.String" /> using the given <see cref="T:System.Text.Encoding" /> into a new
            <see cref="T:DotNetty.Buffers.IByteBuffer" /> which is allocated via the <see cref="T:DotNetty.Buffers.IByteBufferAllocator" />.</summary>
            <param name="src">src The <see cref="T:System.String" /> to encode.</param>
            <param name="encoding">charset The specified <see cref="T:System.Text.Encoding" /></param>
            <param name="extraCapacity">the extra capacity to alloc except the space for decoding.</param>
        </member>
        <member name="M:DotNetty.Buffers.Unpooled.ReadBytes(DotNetty.Buffers.IByteBuffer,System.Int32)">
            <summary>Read the given amount of bytes into a new <see cref="T:DotNetty.Buffers.IByteBuffer"/> that is allocated from the <see cref="T:DotNetty.Buffers.IByteBufferAllocator"/>.</summary>
        </member>
        <member name="T:DotNetty.Buffers.UnpooledByteBufferAllocator">
            <summary>
                Unpooled implementation of <see cref="T:DotNetty.Buffers.IByteBufferAllocator" />.
            </summary>
        </member>
        <member name="T:DotNetty.Buffers.WrappedByteBuffer">
            Wraps another <see cref="T:DotNetty.Buffers.IByteBuffer"/>.
            
            It's important that the {@link #readerIndex()} and {@link #writerIndex()} will not do any adjustments on the
            indices on the fly because of internal optimizations made by {@link ByteBufUtil#writeAscii(ByteBuf, CharSequence)}
            and {@link ByteBufUtil#writeUtf8(ByteBuf, CharSequence)}.
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferWriter.Write7BitEncodedInt0(System.Int32,System.Int32@)">
            <summary>Writes a 32-bit integer in a compressed format.</summary>
            <param name="value">The 32-bit integer to be written.</param>
            <param name="idx"></param>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferWriter.WriteShort(System.Int16)">
            <summary>Writes an Int16 into the <see cref="T:DotNetty.Buffers.IByteBuffer"/> of bytes as big endian.</summary>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferWriter.WriteShortLE(System.Int16)">
            <summary>Writes an Int16 into the <see cref="T:DotNetty.Buffers.IByteBuffer"/> of bytes as little endian.</summary>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferWriter.WriteInt(System.Int32)">
            <summary>Writes an Int32 into the <see cref="T:DotNetty.Buffers.IByteBuffer"/> of bytes as big endian.</summary>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferWriter.WriteIntLE(System.Int32)">
            <summary>Writes an Int32 into the <see cref="T:DotNetty.Buffers.IByteBuffer"/> of bytes as little endian.</summary>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferWriter.WriteLong(System.Int64)">
            <summary>Writes an Int64 into the <see cref="T:DotNetty.Buffers.IByteBuffer"/> of bytes as big endian.</summary>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferWriter.WriteLongLE(System.Int64)">
            <summary>Writes an Int64 into the <see cref="T:DotNetty.Buffers.IByteBuffer"/> of bytes as little endian.</summary>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferWriter.WriteUnsignedShort(System.UInt16)">
            <summary>Write a UInt16 into the <see cref="T:DotNetty.Buffers.IByteBuffer"/> of bytes as big endian.</summary>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferWriter.WriteUnsignedShortLE(System.UInt16)">
            <summary>Write a UInt16 into the <see cref="T:DotNetty.Buffers.IByteBuffer"/> of bytes as little endian.</summary>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferWriter.WriteUnsignedInt(System.UInt32)">
            <summary>Write a UInt32 into the <see cref="T:DotNetty.Buffers.IByteBuffer"/> of bytes as big endian.</summary>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferWriter.WriteUnsignedIntLE(System.UInt32)">
            <summary>Write a UInt32 into the <see cref="T:DotNetty.Buffers.IByteBuffer"/> of bytes as little endian.</summary>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferWriter.WriteUnsignedLong(System.UInt64)">
            <summary>Write a UInt64 into the <see cref="T:DotNetty.Buffers.IByteBuffer"/> of bytes as big endian.</summary>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferWriter.WriteUnsignedLongLE(System.UInt64)">
            <summary>Write a UInt64 into the <see cref="T:DotNetty.Buffers.IByteBuffer"/> of bytes as little endian.</summary>
        </member>
        <member name="P:DotNetty.Buffers.ByteBufferWriter.BytesWritten">
            <summary>Returns the total amount of bytes written by the <see cref="T:DotNetty.Buffers.ByteBufferWriter"/> so far
            for the current instance of the <see cref="T:DotNetty.Buffers.ByteBufferWriter"/>.
            This includes data that has been written beyond what has already been committed.</summary>
        </member>
        <member name="P:DotNetty.Buffers.ByteBufferWriter.BytesCommitted">
            <summary>Returns the total amount of bytes committed to the output by the <see cref="T:DotNetty.Buffers.ByteBufferWriter"/> so far
            for the current instance of the <see cref="T:DotNetty.Buffers.ByteBufferWriter"/>.
            This is how much the <see cref="T:DotNetty.Buffers.IByteBuffer"/> has advanced.</summary>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferWriter.#ctor(DotNetty.Buffers.IByteBuffer)">
            <summary>Constructs a new <see cref="T:DotNetty.Buffers.ByteBufferWriter"/> instance with a specified <paramref name="byteBuffer"/>.</summary>
            <param name="byteBuffer">An instance of <see cref="T:DotNetty.Buffers.IByteBuffer" /> used as a destination for writing.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when the instance of <see cref="T:DotNetty.Buffers.IByteBuffer" /> that is passed in is null.</exception>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferWriter.Write7BitEncodedInt(System.Int32)">
            <summary>Writes a 32-bit integer in a compressed format.</summary>
            <param name="value">The 32-bit integer to be written.</param>
        </member>
        <member name="M:DotNetty.Buffers.ByteBufferWriter.Flush">
            <summary>Advances the underlying <see cref="T:DotNetty.Buffers.IByteBuffer" /> based on what has been written so far.</summary>
        </member>
    </members>
</doc>
