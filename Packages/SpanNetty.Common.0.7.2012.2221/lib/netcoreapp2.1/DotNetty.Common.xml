<?xml version="1.0"?>
<doc>
    <assembly>
        <name>DotNetty.Common</name>
    </assembly>
    <members>
        <member name="T:DotNetty.Common.Concurrency.AbstractEventExecutor">
            <summary>
                Abstract base class for <see cref="T:DotNetty.Common.Concurrency.IEventExecutor" /> implementations
            </summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.#ctor">
            <summary>Creates an instance of <see cref="T:DotNetty.Common.Concurrency.AbstractEventExecutor"/>.</summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.#ctor(DotNetty.Common.Concurrency.IEventExecutorGroup)">
            <summary>Creates an instance of <see cref="T:DotNetty.Common.Concurrency.AbstractEventExecutor"/>.</summary>
        </member>
        <member name="P:DotNetty.Common.Concurrency.AbstractEventExecutor.IsShuttingDown">
            <inheritdoc />
        </member>
        <member name="P:DotNetty.Common.Concurrency.AbstractEventExecutor.TerminationCompletion">
            <inheritdoc cref="P:DotNetty.Common.Concurrency.IEventExecutorGroup.TerminationCompletion"/>
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.GetNext">
            <inheritdoc cref="M:DotNetty.Common.Concurrency.IEventExecutorGroup.GetNext"/>
        </member>
        <member name="P:DotNetty.Common.Concurrency.AbstractEventExecutor.Parent">
            <inheritdoc />
        </member>
        <member name="P:DotNetty.Common.Concurrency.AbstractEventExecutor.InEventLoop">
            <inheritdoc />
        </member>
        <member name="P:DotNetty.Common.Concurrency.AbstractEventExecutor.Items">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.IsInEventLoop(DotNetty.Common.Concurrency.XThread)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.Schedule(DotNetty.Common.Concurrency.IRunnable,System.TimeSpan)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.Schedule(System.Action,System.TimeSpan)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.Schedule(System.Action{System.Object},System.Object,System.TimeSpan)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.Schedule(System.Action{System.Object,System.Object},System.Object,System.Object,System.TimeSpan)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.ScheduleAtFixedRate(DotNetty.Common.Concurrency.IRunnable,System.TimeSpan,System.TimeSpan)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.ScheduleAtFixedRate(System.Action,System.TimeSpan,System.TimeSpan)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.ScheduleAtFixedRate(System.Action{System.Object},System.Object,System.TimeSpan,System.TimeSpan)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.ScheduleAtFixedRate(System.Action{System.Object,System.Object},System.Object,System.Object,System.TimeSpan,System.TimeSpan)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.ScheduleWithFixedDelay(DotNetty.Common.Concurrency.IRunnable,System.TimeSpan,System.TimeSpan)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.ScheduleWithFixedDelay(System.Action,System.TimeSpan,System.TimeSpan)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.ScheduleWithFixedDelay(System.Action{System.Object},System.Object,System.TimeSpan,System.TimeSpan)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.ScheduleWithFixedDelay(System.Action{System.Object,System.Object},System.Object,System.Object,System.TimeSpan,System.TimeSpan)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.ScheduleAsync(DotNetty.Common.Concurrency.IRunnable,System.TimeSpan)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.ScheduleAsync(DotNetty.Common.Concurrency.IRunnable,System.TimeSpan,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.ScheduleAsync(System.Action,System.TimeSpan)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.ScheduleAsync(System.Action,System.TimeSpan,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.ScheduleAsync(System.Action{System.Object},System.Object,System.TimeSpan)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.ScheduleAsync(System.Action{System.Object},System.Object,System.TimeSpan,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.ScheduleAsync(System.Action{System.Object,System.Object},System.Object,System.Object,System.TimeSpan)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.ScheduleAsync(System.Action{System.Object,System.Object},System.Object,System.Object,System.TimeSpan,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.ShutdownGracefullyAsync">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.ShutdownGracefullyAsync(System.TimeSpan,System.TimeSpan)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.SetCurrentExecutor(DotNetty.Common.Concurrency.IEventExecutor)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.SafeExecute(DotNetty.Common.Concurrency.IRunnable)">
            <summary>
            Try to execute the given <see cref="T:DotNetty.Common.Concurrency.IRunnable"/> and just log if it throws a <see cref="T:System.Exception"/>.
            </summary>
            <param name="task"></param>
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractEventExecutor.LazyExecute(DotNetty.Common.Concurrency.IRunnable)">
            <summary>
            Like <see cref="M:DotNetty.Common.Concurrency.AbstractExecutorService.Execute(DotNetty.Common.Concurrency.IRunnable)"/> but does not guarantee the task will be run until either
            a non-lazy task is executed or the executor is shut down.
            
            <para>This is equivalent to submitting a <see cref="T:DotNetty.Common.Concurrency.ILazyRunnable"/> to
            <see cref="M:DotNetty.Common.Concurrency.AbstractExecutorService.Execute(DotNetty.Common.Concurrency.IRunnable)"/> but for an arbitrary <see cref="T:DotNetty.Common.Concurrency.IRunnable"/>.</para>
            </summary>
            <remarks>The default implementation just delegates to <see cref="M:DotNetty.Common.Concurrency.AbstractExecutorService.Execute(DotNetty.Common.Concurrency.IRunnable)"/>.</remarks>
            <param name="task"></param>
        </member>
        <member name="P:DotNetty.Common.Concurrency.AbstractExecutorService.IsShutdown">
            <inheritdoc />
        </member>
        <member name="P:DotNetty.Common.Concurrency.AbstractExecutorService.IsTerminated">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractExecutorService.SubmitAsync``1(System.Func{``0})">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractExecutorService.SubmitAsync``1(System.Func{``0},System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractExecutorService.SubmitAsync``1(System.Func{System.Object,``0},System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractExecutorService.SubmitAsync``1(System.Func{System.Object,``0},System.Object,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractExecutorService.SubmitAsync``1(System.Func{System.Object,System.Object,``0},System.Object,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractExecutorService.SubmitAsync``1(System.Func{System.Object,System.Object,``0},System.Object,System.Object,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractExecutorService.Execute(DotNetty.Common.Concurrency.IRunnable)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractExecutorService.Execute(System.Action{System.Object},System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractExecutorService.Execute(System.Action{System.Object,System.Object},System.Object,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractExecutorService.Execute(System.Action)">
            <inheritdoc />
        </member>
        <member name="T:DotNetty.Common.Concurrency.AbstractScheduledEventExecutor">
            <summary>
            Abstract base class for <see cref="T:DotNetty.Common.Concurrency.IEventExecutor" />s that need to support scheduling.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractScheduledEventExecutor.DeadlineToDelayNanos(System.Int64)">
            <summary>
            Given an arbitrary deadline <paramref name="deadlineNanos"/>, calculate the number of nano seconds from now
            <paramref name="deadlineNanos"/> would expire.
            </summary>
            <param name="deadlineNanos">An arbitrary deadline in nano seconds.</param>
            <returns>the number of nano seconds from now <paramref name="deadlineNanos"/> would expire.</returns>
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractScheduledEventExecutor.InitialNanoTime">
            <summary>The initial value used for delay and computations based upon a monatomic time source.</summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractScheduledEventExecutor.CancelScheduledTasks">
            <summary>
            Cancel all scheduled tasks
            This method MUST be called only when <see cref="P:DotNetty.Common.Concurrency.IEventExecutor.InEventLoop" /> is <c>true</c>.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractScheduledEventExecutor.PollScheduledTask(System.Int64)">
            <summary>
            Return the <see cref="T:DotNetty.Common.Concurrency.IScheduledRunnable"/> which is ready to be executed with the given <paramref name="nanoTime"/>.
            You should use <see cref="M:DotNetty.Common.Concurrency.AbstractScheduledEventExecutor.NanoTime"/> to retrieve the correct <paramref name="nanoTime"/>.
            </summary>
            <param name="nanoTime"></param>
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractScheduledEventExecutor.NextScheduledTaskNanos">
            <summary>
            Return the nanoseconds until the next scheduled task is ready to be run or <c>-1</c> if no task is scheduled.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractScheduledEventExecutor.NextScheduledTaskDeadlineNanos">
            <summary>
            Return the deadline (in nanoseconds) when the next scheduled task is ready to be run or <c>-1</c>
            if no task is scheduled.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractScheduledEventExecutor.HasScheduledTasks">
            <summary>
            Returns <c>true</c> if a scheduled task is ready for processing.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractScheduledEventExecutor.BeforeScheduledTaskSubmitted(System.Int64)">
            <summary>
            Called from arbitrary non-<see cref="T:DotNetty.Common.Concurrency.IEventExecutor"/> threads prior to scheduled task submission.
            Returns <c>true</c> if the <see cref="T:DotNetty.Common.Concurrency.IEventExecutor"/> thread should be woken immediately to
            process the scheduled task (if not already awake).
            
            <para>If <c>false</c> is returned, <see cref="M:DotNetty.Common.Concurrency.AbstractScheduledEventExecutor.AfterScheduledTaskSubmitted(System.Int64)"/> will be called with
            the same value <i>after</i> the scheduled task is enqueued, providing another opportunity
            to wake the <see cref="T:DotNetty.Common.Concurrency.IEventExecutor"/> thread if required.</para>
            </summary>
            <param name="deadlineNanos">deadline of the to-be-scheduled task
            relative to <see cref="M:DotNetty.Common.Concurrency.AbstractScheduledEventExecutor.NanoTime"/></param>
            <returns><c>true</c> if the <see cref="T:DotNetty.Common.Concurrency.IEventExecutor"/> thread should be woken, <c>false</c> otherwise</returns>
        </member>
        <member name="M:DotNetty.Common.Concurrency.AbstractScheduledEventExecutor.AfterScheduledTaskSubmitted(System.Int64)">
            <summary>
            See <see cref="M:DotNetty.Common.Concurrency.AbstractScheduledEventExecutor.BeforeScheduledTaskSubmitted(System.Int64)"/>. Called only after that method returns false.
            </summary>
            <param name="deadlineNanos">relative to <see cref="M:DotNetty.Common.Concurrency.AbstractScheduledEventExecutor.NanoTime"/></param>
            <returns><c>true</c> if the <see cref="T:DotNetty.Common.Concurrency.IEventExecutor"/> thread should be woken, <c>false</c> otherwise</returns>
        </member>
        <member name="T:DotNetty.Common.Concurrency.DefaultEventExecutor">
            <summary>
            Default <see cref="T:DotNetty.Common.Concurrency.SingleThreadEventExecutor"/> implementation which just execute all submitted task in a serial fashion.
            </summary>
        </member>
        <member name="T:DotNetty.Common.Concurrency.DefaultEventExecutorChooserFactory`1">
            <summary>
            Default implementation which uses simple round-robin to choose next <see cref="T:DotNetty.Common.Concurrency.IEventExecutor"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.DefaultEventExecutorChooserFactory`1.NewChooser(`0[])">
            <summary>
            Returns a new <see cref="T:DotNetty.Common.Concurrency.IEventExecutorChooser`1"/>.
            </summary>
            <param name="executors"></param>
            <returns></returns>
        </member>
        <member name="T:DotNetty.Common.Concurrency.DefaultEventExecutorGroup">
            <summary>
            Default implementation of <see cref="T:DotNetty.Common.Concurrency.MultithreadEventExecutorGroup`2"/> which will use <see cref="T:DotNetty.Common.Concurrency.DefaultEventExecutor"/> instances
            to handle the tasks.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.DefaultEventExecutorGroup.#ctor">
            <summary>Creates a new instance of <see cref="T:DotNetty.Common.Concurrency.DefaultEventExecutorGroup"/>.</summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.DefaultEventExecutorGroup.#ctor(System.Int32)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Common.Concurrency.DefaultEventExecutorGroup"/>.</summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.DefaultEventExecutorGroup.#ctor(DotNetty.Common.Concurrency.IRejectedExecutionHandler)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Common.Concurrency.DefaultEventExecutorGroup"/>.</summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.DefaultEventExecutorGroup.#ctor(DotNetty.Common.Concurrency.IEventExecutorTaskQueueFactory)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Common.Concurrency.DefaultEventExecutorGroup"/>.</summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.DefaultEventExecutorGroup.#ctor(System.Int32,DotNetty.Common.Concurrency.IRejectedExecutionHandler)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Common.Concurrency.DefaultEventExecutorGroup"/>.</summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.DefaultEventExecutorGroup.#ctor(System.Int32,System.Int32)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Common.Concurrency.DefaultEventExecutorGroup"/>.</summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.DefaultEventExecutorGroup.#ctor(System.Int32,DotNetty.Common.Concurrency.IEventExecutorTaskQueueFactory)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Common.Concurrency.DefaultEventExecutorGroup"/>.</summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.DefaultEventExecutorGroup.#ctor(System.Int32,DotNetty.Common.Concurrency.IRejectedExecutionHandler,System.Int32)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Common.Concurrency.DefaultEventExecutorGroup"/>.</summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.DefaultEventExecutorGroup.#ctor(System.Int32,DotNetty.Common.Concurrency.IRejectedExecutionHandler,DotNetty.Common.Concurrency.IEventExecutorTaskQueueFactory)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Common.Concurrency.DefaultEventExecutorGroup"/>.</summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.DefaultEventExecutorGroup.#ctor(DotNetty.Common.Concurrency.IThreadFactory)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Common.Concurrency.DefaultEventExecutorGroup"/>.</summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.DefaultEventExecutorGroup.#ctor(System.Int32,DotNetty.Common.Concurrency.IThreadFactory)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Common.Concurrency.DefaultEventExecutorGroup"/>.</summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.DefaultEventExecutorGroup.#ctor(System.Int32,DotNetty.Common.Concurrency.IThreadFactory,DotNetty.Common.Concurrency.IRejectedExecutionHandler)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Common.Concurrency.DefaultEventExecutorGroup"/>.</summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.DefaultEventExecutorGroup.#ctor(System.Int32,DotNetty.Common.Concurrency.IThreadFactory,System.Int32)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Common.Concurrency.DefaultEventExecutorGroup"/>.</summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.DefaultEventExecutorGroup.#ctor(System.Int32,DotNetty.Common.Concurrency.IThreadFactory,DotNetty.Common.Concurrency.IEventExecutorTaskQueueFactory)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Common.Concurrency.DefaultEventExecutorGroup"/>.</summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.DefaultEventExecutorGroup.#ctor(System.Int32,DotNetty.Common.Concurrency.IThreadFactory,DotNetty.Common.Concurrency.IRejectedExecutionHandler,System.Int32)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Common.Concurrency.DefaultEventExecutorGroup"/>.</summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.DefaultEventExecutorGroup.#ctor(System.Int32,DotNetty.Common.Concurrency.IThreadFactory,DotNetty.Common.Concurrency.IRejectedExecutionHandler,DotNetty.Common.Concurrency.IEventExecutorTaskQueueFactory)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Common.Concurrency.DefaultEventExecutorGroup"/>.</summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.DefaultEventExecutorGroup.#ctor(DotNetty.Common.Concurrency.IEventExecutorChooserFactory{DotNetty.Common.Concurrency.DefaultEventExecutor})">
            <summary>Creates a new instance of <see cref="T:DotNetty.Common.Concurrency.DefaultEventExecutorGroup"/>.</summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.DefaultEventExecutorGroup.#ctor(System.Int32,DotNetty.Common.Concurrency.IEventExecutorChooserFactory{DotNetty.Common.Concurrency.DefaultEventExecutor})">
            <summary>Creates a new instance of <see cref="T:DotNetty.Common.Concurrency.DefaultEventExecutorGroup"/>.</summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.DefaultEventExecutorGroup.#ctor(System.Int32,DotNetty.Common.Concurrency.IEventExecutorChooserFactory{DotNetty.Common.Concurrency.DefaultEventExecutor},DotNetty.Common.Concurrency.IRejectedExecutionHandler)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Common.Concurrency.DefaultEventExecutorGroup"/>.</summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.DefaultEventExecutorGroup.#ctor(System.Int32,DotNetty.Common.Concurrency.IEventExecutorChooserFactory{DotNetty.Common.Concurrency.DefaultEventExecutor},System.Int32)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Common.Concurrency.DefaultEventExecutorGroup"/>.</summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.DefaultEventExecutorGroup.#ctor(System.Int32,DotNetty.Common.Concurrency.IEventExecutorChooserFactory{DotNetty.Common.Concurrency.DefaultEventExecutor},DotNetty.Common.Concurrency.IEventExecutorTaskQueueFactory)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Common.Concurrency.DefaultEventExecutorGroup"/>.</summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.DefaultEventExecutorGroup.#ctor(System.Int32,DotNetty.Common.Concurrency.IEventExecutorChooserFactory{DotNetty.Common.Concurrency.DefaultEventExecutor},DotNetty.Common.Concurrency.IRejectedExecutionHandler,System.Int32)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Common.Concurrency.DefaultEventExecutorGroup"/>.</summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.DefaultEventExecutorGroup.#ctor(System.Int32,DotNetty.Common.Concurrency.IEventExecutorChooserFactory{DotNetty.Common.Concurrency.DefaultEventExecutor},DotNetty.Common.Concurrency.IRejectedExecutionHandler,DotNetty.Common.Concurrency.IEventExecutorTaskQueueFactory)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Common.Concurrency.DefaultEventExecutorGroup"/>.</summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.DefaultEventExecutorGroup.#ctor(System.Int32,DotNetty.Common.Concurrency.IThreadFactory,DotNetty.Common.Concurrency.IEventExecutorChooserFactory{DotNetty.Common.Concurrency.DefaultEventExecutor},DotNetty.Common.Concurrency.IRejectedExecutionHandler,System.Int32)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Common.Concurrency.DefaultEventExecutorGroup"/>.</summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.DefaultEventExecutorGroup.#ctor(System.Int32,DotNetty.Common.Concurrency.IThreadFactory,DotNetty.Common.Concurrency.IEventExecutorChooserFactory{DotNetty.Common.Concurrency.DefaultEventExecutor},DotNetty.Common.Concurrency.IRejectedExecutionHandler,DotNetty.Common.Concurrency.IEventExecutorTaskQueueFactory)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Common.Concurrency.DefaultEventExecutorGroup"/>.</summary>
        </member>
        <member name="T:DotNetty.Common.Concurrency.DefaultThreadFactory`1">
            <summary>
            A <see cref="T:DotNetty.Common.Concurrency.IThreadFactory"/> implementation with a simple naming rule.
            </summary>
        </member>
        <member name="T:DotNetty.Common.Concurrency.DefaultThreadFactory">
            <summary>
            A <see cref="T:DotNetty.Common.Concurrency.IThreadFactory"/> implementation with a simple naming rule.
            </summary>
        </member>
        <member name="P:DotNetty.Common.Concurrency.IEventExecutor.Parent">
            <summary>
            Parent <see cref="T:DotNetty.Common.Concurrency.IEventExecutorGroup"/>.
            </summary>
        </member>
        <member name="P:DotNetty.Common.Concurrency.IEventExecutor.InEventLoop">
            <summary>
                Returns <c>true</c> if the current <see cref="T:DotNetty.Common.Concurrency.XThread" /> belongs to this event loop,
                <c>false</c> otherwise.
            </summary>
            <remarks>
                It is a convenient way to determine whether code can be executed directly or if it
                should be posted for execution to this executor instance explicitly to ensure execution in the loop.
            </remarks>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IEventExecutor.IsInEventLoop(DotNetty.Common.Concurrency.XThread)">
            <summary>
                Returns <c>true</c> if the given <see cref="T:DotNetty.Common.Concurrency.XThread" /> belongs to this event loop,
                <c>false></c> otherwise.
            </summary>
        </member>
        <member name="T:DotNetty.Common.Concurrency.IEventExecutorChooser`1">
            <summary>
            Chooses the next <typeparamref name="TEventExecutor"/> to use.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IEventExecutorChooser`1.GetNext">
            <summary>
            Returns the new <typeparamref name="TEventExecutor"/> to use.
            </summary>
        </member>
        <member name="T:DotNetty.Common.Concurrency.IEventExecutorChooserFactory`1">
            <summary>
            Factory that creates new <see cref="T:DotNetty.Common.Concurrency.IEventExecutorChooser`1"/>s.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IEventExecutorChooserFactory`1.NewChooser(`0[])">
            <summary>
            Returns a new <see cref="T:DotNetty.Common.Concurrency.IEventExecutorChooser`1"/>.
            </summary>
            <param name="executors"></param>
            <returns></returns>
        </member>
        <member name="T:DotNetty.Common.Concurrency.IEventExecutorGroup">
            <summary>
            The <see cref="T:DotNetty.Common.Concurrency.IEventExecutorGroup"/> is responsible for providing the <see cref="T:DotNetty.Common.Concurrency.IEventExecutor"/>'s to use
            via its <see cref="M:DotNetty.Common.Concurrency.IEventExecutorGroup.GetNext"/> method. Besides this, it is also responsible for handling their
            life-cycle and allows shutting them down in a global fashion.
            </summary>
        </member>
        <member name="P:DotNetty.Common.Concurrency.IEventExecutorGroup.Items">
            <summary>
            Returns list of owned event executors.
            </summary>
        </member>
        <member name="P:DotNetty.Common.Concurrency.IEventExecutorGroup.IsShuttingDown">
            <summary>
                Returns <c>true</c> if and only if this executor is being shut down via <see cref="M:DotNetty.Common.Concurrency.IEventExecutorGroup.ShutdownGracefullyAsync" />.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IEventExecutorGroup.ShutdownGracefullyAsync">
            <summary>
            Terminates this <see cref="T:DotNetty.Common.Concurrency.IEventExecutorGroup"/> and all its <see cref="T:DotNetty.Common.Concurrency.IEventExecutor"/>s.
            </summary>
            <returns><see cref="T:System.Threading.Tasks.Task"/> for completion of termination.</returns>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IEventExecutorGroup.ShutdownGracefullyAsync(System.TimeSpan,System.TimeSpan)">
            <summary>
            Terminates this <see cref="T:DotNetty.Common.Concurrency.IEventExecutorGroup"/> and all its <see cref="T:DotNetty.Common.Concurrency.IEventExecutor"/>s.
            </summary>
            <returns><see cref="T:System.Threading.Tasks.Task"/> for completion of termination.</returns>
        </member>
        <member name="P:DotNetty.Common.Concurrency.IEventExecutorGroup.TerminationCompletion">
            <summary>
            A <see cref="T:System.Threading.Tasks.Task"/> for completion of termination. <see cref="M:DotNetty.Common.Concurrency.IEventExecutorGroup.ShutdownGracefullyAsync"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IEventExecutorGroup.GetNext">
            <summary>
            Returns <see cref="T:DotNetty.Common.Concurrency.IEventExecutor"/>.
            </summary>
        </member>
        <member name="T:DotNetty.Common.Concurrency.IEventExecutorTaskQueueFactory">
            <summary>
            Factory used to create <see cref="T:DotNetty.Common.Internal.IQueue`1"/> instances that will be used to store tasks for an <see cref="T:DotNetty.Common.Concurrency.IEventExecutor"/>.
            
            <para>Generally speaking the returned <see cref="T:DotNetty.Common.Internal.IQueue`1"/> MUST be thread-safe and depending on the <see cref="T:DotNetty.Common.Concurrency.IEventExecutor"/>
            implementation must be of type <see cref="T:DotNetty.Common.Internal.IBlockingQueue`1"/>.</para>
            </summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IEventExecutorTaskQueueFactory.NewTaskQueue(System.Int32)">
            <summary>
            Returns a new <see cref="T:DotNetty.Common.Internal.IQueue`1"/> to use.
            </summary>
            <param name="maxCapacity">the maximum amount of elements that can be stored in the <see cref="T:DotNetty.Common.Internal.IQueue`1"/> at a given point
            in time.</param>
            <returns>the new queue.</returns>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IExecutor.Execute(DotNetty.Common.Concurrency.IRunnable)">
            <summary>
                Executes the given task.
            </summary>
            <remarks>Threading specifics are determined by <c>IEventExecutor</c> implementation.</remarks>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IExecutor.Execute(System.Action{System.Object},System.Object)">
            <summary>
                Executes the given action.
            </summary>
            <remarks>
                <paramref name="state" /> parameter is useful to when repeated execution of an action against
                different objects is needed.
                <para>Threading specifics are determined by <c>IEventExecutor</c> implementation.</para>
            </remarks>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IExecutor.Execute(System.Action)">
            <summary>
                Executes the given <paramref name="action" />.
            </summary>
            <remarks>Threading specifics are determined by <c>IEventExecutor</c> implementation.</remarks>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IExecutor.Execute(System.Action{System.Object,System.Object},System.Object,System.Object)">
            <summary>
                Executes the given action.
            </summary>
            <remarks>
                <paramref name="context" /> and <paramref name="state" /> parameters are useful when repeated execution of
                an action against different objects in different context is needed.
                <para>Threading specifics are determined by <c>IEventExecutor</c> implementation.</para>
            </remarks>
        </member>
        <member name="P:DotNetty.Common.Concurrency.IExecutorService.IsShutdown">
            <summary>
                Returns <c>true</c> if this executor has been shut down, <c>false</c> otherwise.
            </summary>
        </member>
        <member name="P:DotNetty.Common.Concurrency.IExecutorService.IsTerminated">
            <summary>
                Returns <c>true</c> if all tasks have completed following shut down.
            </summary>
            <remarks>
                Note that <see cref="P:DotNetty.Common.Concurrency.IExecutorService.IsTerminated" /> is never <c>true</c> unless <see cref="M:DotNetty.Common.Concurrency.IEventExecutorGroup.ShutdownGracefullyAsync" /> was called first.
            </remarks>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IExecutorService.SubmitAsync``1(System.Func{``0})">
            <summary>
                Executes the given function and returns <see cref="T:System.Threading.Tasks.Task`1" /> indicating completion status and result of
                execution.
            </summary>
            <remarks>
                <para>Threading specifics are determined by <c>IEventExecutor</c> implementation.</para>
            </remarks>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IExecutorService.SubmitAsync``1(System.Func{``0},System.Threading.CancellationToken)">
            <summary>
                Executes the given action and returns <see cref="T:System.Threading.Tasks.Task`1" /> indicating completion status and result of execution.
            </summary>
            <remarks>
                <para>Threading specifics are determined by <c>IEventExecutor</c> implementation.</para>
            </remarks>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IExecutorService.SubmitAsync``1(System.Func{System.Object,``0},System.Object)">
            <summary>
                Executes the given action and returns <see cref="T:System.Threading.Tasks.Task`1" /> indicating completion status and result of execution.
            </summary>
            <remarks>
                <paramref name="state" /> parameter is useful to when repeated execution of an action against
                different objects is needed.
                <para>Threading specifics are determined by <c>IEventExecutor</c> implementation.</para>
            </remarks>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IExecutorService.SubmitAsync``1(System.Func{System.Object,``0},System.Object,System.Threading.CancellationToken)">
            <summary>
                Executes the given action and returns <see cref="T:System.Threading.Tasks.Task`1" /> indicating completion status and result of execution.
            </summary>
            <remarks>
                <paramref name="state" /> parameter is useful to when repeated execution of an action against
                different objects is needed.
                <para>Threading specifics are determined by <c>IEventExecutor</c> implementation.</para>
            </remarks>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IExecutorService.SubmitAsync``1(System.Func{System.Object,System.Object,``0},System.Object,System.Object)">
            <summary>
                Executes the given action and returns <see cref="T:System.Threading.Tasks.Task`1" /> indicating completion status and result of execution.
            </summary>
            <remarks>
                <paramref name="context" /> and <paramref name="state" /> parameters are useful when repeated execution of
                an action against different objects in different context is needed.
                <para>Threading specifics are determined by <c>IEventExecutor</c> implementation.</para>
            </remarks>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IExecutorService.SubmitAsync``1(System.Func{System.Object,System.Object,``0},System.Object,System.Object,System.Threading.CancellationToken)">
            <summary>
                Executes the given action and returns <see cref="T:System.Threading.Tasks.Task`1" /> indicating completion status and result of execution.
            </summary>
            <remarks>
                <paramref name="context" /> and <paramref name="state" /> parameters are useful when repeated execution of
                an action against different objects in different context is needed.
                <para>Threading specifics are determined by <c>IEventExecutor</c> implementation.</para>
            </remarks>
        </member>
        <member name="T:DotNetty.Common.Concurrency.IOrderedEventExecutor">
            <summary>Marker interface for <see cref="T:DotNetty.Common.Concurrency.IEventExecutor"/>s that will process all submitted tasks in an ordered / serial fashion.</summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IRejectedExecutionHandler.Rejected(DotNetty.Common.Concurrency.IRunnable,DotNetty.Common.Concurrency.SingleThreadEventExecutor)">
            <summary>
            Called when someone tried to add a task to <see cref="T:DotNetty.Common.Concurrency.SingleThreadEventExecutor"/> but this failed due capacity
            restrictions.
            </summary>
            <param name="task"></param>
            <param name="executor"></param>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IScheduledExecutorService.Schedule(DotNetty.Common.Concurrency.IRunnable,System.TimeSpan)">
            <summary>
                Creates and executes a one-shot action that becomes enabled after the given delay.
            </summary>
            <param name="action">the task to execute</param>
            <param name="delay">the time from now to delay execution</param>
            <returns>an <see cref="T:DotNetty.Common.Concurrency.IScheduledTask" /> representing pending completion of the task.</returns>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IScheduledExecutorService.Schedule(System.Action,System.TimeSpan)">
            <summary>
                Schedules the given action for execution after the specified delay would pass.
            </summary>
            <remarks>
                <para>Threading specifics are determined by <c>IEventExecutor</c> implementation.</para>
            </remarks>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IScheduledExecutorService.Schedule(System.Action{System.Object},System.Object,System.TimeSpan)">
            <summary>
                Schedules the given action for execution after the specified delay would pass.
            </summary>
            <remarks>
                <paramref name="state" /> parameter is useful to when repeated execution of an action against
                different objects is needed.
                <para>Threading specifics are determined by <c>IEventExecutor</c> implementation.</para>
            </remarks>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IScheduledExecutorService.Schedule(System.Action{System.Object,System.Object},System.Object,System.Object,System.TimeSpan)">
            <summary>
                Schedules the given action for execution after the specified delay would pass.
            </summary>
            <remarks>
                <paramref name="context" /> and <paramref name="state" /> parameters are useful when repeated execution of
                an action against different objects in different context is needed.
                <para>Threading specifics are determined by <c>IEventExecutor</c> implementation.</para>
            </remarks>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IScheduledExecutorService.ScheduleAsync(System.Action,System.TimeSpan)">
            <summary>
                Schedules the given action for execution after the specified delay would pass.
            </summary>
            <remarks>
                <para>Threading specifics are determined by <c>IEventExecutor</c> implementation.</para>
            </remarks>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IScheduledExecutorService.ScheduleAsync(System.Action,System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
                Schedules the given action for execution after the specified delay would pass.
            </summary>
            <remarks>
                <para>Threading specifics are determined by <c>IEventExecutor</c> implementation.</para>
            </remarks>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IScheduledExecutorService.ScheduleAsync(System.Action{System.Object},System.Object,System.TimeSpan)">
            <summary>
                Schedules the given action for execution after the specified delay would pass.
            </summary>
            <remarks>
                <paramref name="state" /> parameter is useful to when repeated execution of an action against
                different objects is needed.
                <para>Threading specifics are determined by <c>IEventExecutor</c> implementation.</para>
            </remarks>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IScheduledExecutorService.ScheduleAsync(System.Action{System.Object},System.Object,System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
                Schedules the given action for execution after the specified delay would pass.
            </summary>
            <remarks>
                <paramref name="state" /> parameter is useful to when repeated execution of an action against
                different objects is needed.
                <para>Threading specifics are determined by <c>IEventExecutor</c> implementation.</para>
            </remarks>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IScheduledExecutorService.ScheduleAsync(System.Action{System.Object,System.Object},System.Object,System.Object,System.TimeSpan)">
            <summary>
                Schedules the given action for execution after the specified delay would pass.
            </summary>
            <remarks>
                <paramref name="context" /> and <paramref name="state" /> parameters are useful when repeated execution of
                an action against different objects in different context is needed.
                <para>Threading specifics are determined by <c>IEventExecutor</c> implementation.</para>
            </remarks>
        </member>
        <member name="M:DotNetty.Common.Concurrency.IScheduledExecutorService.ScheduleAsync(System.Action{System.Object,System.Object},System.Object,System.Object,System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
                Schedules the given action for execution after the specified delay would pass.
            </summary>
            <remarks>
                <paramref name="context" /> and <paramref name="state" /> parameters are useful when repeated execution of
                an action against different objects in different context is needed.
                <para>Threading specifics are determined by <c>IEventExecutor</c> implementation.</para>
            </remarks>
        </member>
        <member name="T:DotNetty.Common.Concurrency.MultithreadEventExecutorGroup`2">
            <summary>
            Abstract base class for <see cref="T:DotNetty.Common.Concurrency.IEventExecutorGroup"/> implementations that handles their tasks with multiple threads at
            the same time.
            </summary>
        </member>
        <member name="P:DotNetty.Common.Concurrency.MultithreadEventExecutorGroup`2.IsShutdown">
            <inheritdoc />
        </member>
        <member name="P:DotNetty.Common.Concurrency.MultithreadEventExecutorGroup`2.IsTerminated">
            <inheritdoc />
        </member>
        <member name="P:DotNetty.Common.Concurrency.MultithreadEventExecutorGroup`2.IsShuttingDown">
            <inheritdoc />
        </member>
        <member name="P:DotNetty.Common.Concurrency.MultithreadEventExecutorGroup`2.TerminationCompletion">
            <inheritdoc />
        </member>
        <member name="P:DotNetty.Common.Concurrency.MultithreadEventExecutorGroup`2.Items">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.MultithreadEventExecutorGroup`2.GetItems">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.MultithreadEventExecutorGroup`2.GetNext">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.MultithreadEventExecutorGroup`2.#ctor(System.Int32,System.Func{`0,`1})">
            <summary>Creates a new instance of <see cref="T:DotNetty.Common.Concurrency.MultithreadEventExecutorGroup`2"/>.</summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.MultithreadEventExecutorGroup`2.#ctor(System.Int32,DotNetty.Common.Concurrency.IEventExecutorChooserFactory{`1},System.Func{`0,`1})">
            <summary>Creates a new instance of <see cref="T:DotNetty.Common.Concurrency.MultithreadEventExecutorGroup`2"/>.</summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.MultithreadEventExecutorGroup`2.ShutdownGracefullyAsync(System.TimeSpan,System.TimeSpan)">
            <inheritdoc cref="M:DotNetty.Common.Concurrency.IEventExecutorGroup.ShutdownGracefullyAsync(System.TimeSpan,System.TimeSpan)" />
        </member>
        <member name="T:DotNetty.Common.Concurrency.PromiseCombiner">
            <summary>
            A promise combiner monitors the outcome of a number of discrete futures, then notifies a final, aggregate promise
            when all of the combined futures are finished. The aggregate promise will succeed if and only if all of the combined
            futures succeed. If any of the combined futures fail, the aggregate promise will fail. The cause failure for the
            aggregate promise will be the failure for one of the failed combined futures; if more than one of the combined
            futures fails, exactly which cause of failure will be assigned to the aggregate promise is undefined.
            
            <para>Callers may populate a promise combiner with any number of futures to be combined via the
            <see cref="M:DotNetty.Common.Concurrency.PromiseCombiner.Add(System.Threading.Tasks.Task)"/> and <see cref="M:DotNetty.Common.Concurrency.PromiseCombiner.AddAll(System.Threading.Tasks.Task[])"/> methods. When all futures to be
            combined have been added, callers must provide an aggregate promise to be notified when all combined promises have
            finished via the <see cref="M:DotNetty.Common.Concurrency.PromiseCombiner.Finish(DotNetty.Common.Concurrency.IPromise)"/> method.</para>
            </summary>
        </member>
        <member name="T:DotNetty.Common.Concurrency.RejectedExecutionHandlers">
            <summary>
            Expose helper methods which create different <see cref="T:DotNetty.Common.Concurrency.IRejectedExecutionHandler"/>s.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.RejectedExecutionHandlers.Reject">
            <summary>
            Returns a <see cref="T:DotNetty.Common.Concurrency.IRejectedExecutionHandler"/> that will always just throw a <see cref="T:DotNetty.Common.Concurrency.RejectedExecutionException"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.RejectedExecutionHandlers.Backoff(System.Int32,System.TimeSpan)">
            <summary>
            Tries to backoff when the task can not be added due restrictions for an configured amount of time. This
            </summary>
            <param name="retries"></param>
            <param name="delay"></param>
            <returns></returns>
        </member>
        <member name="T:DotNetty.Common.Concurrency.SimplePromiseAggregator">
            <summary>
            Provides the ability to associate the outcome of multiple <see cref="T:DotNetty.Common.Concurrency.IPromise"/>
            objects into a single <see cref="T:DotNetty.Common.Concurrency.IPromise"/> object.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.SimplePromiseAggregator.NewPromise">
            <summary>
            Allocate a new promise which will be used to aggregate the overall success of this promise aggregator.
            </summary>
            <returns>A new promise which will be aggregated.
            <c>null</c> if <see cref="M:DotNetty.Common.Concurrency.SimplePromiseAggregator.DoneAllocatingPromises"/> was previously called.</returns>
        </member>
        <member name="M:DotNetty.Common.Concurrency.SimplePromiseAggregator.DoneAllocatingPromises">
            <summary>
            Signify that no more <see cref="M:DotNetty.Common.Concurrency.SimplePromiseAggregator.NewPromise"/> allocations will be made.
            The aggregation can not be successful until this method is called.
            </summary>
            <returns>The promise that is the aggregation of all promises allocated with <see cref="M:DotNetty.Common.Concurrency.SimplePromiseAggregator.NewPromise"/>.</returns>
        </member>
        <member name="M:DotNetty.Common.Concurrency.SimplePromiseAggregator.SetException(System.Exception)">
            <summary>
            Fail this object if it has not already been failed.
            
            This method will NOT throw an <see cref="T:System.InvalidOperationException"/> if called multiple times
            because that may be expected.
            </summary>
            <param name="cause"></param>
        </member>
        <member name="T:DotNetty.Common.Concurrency.SingleThreadEventExecutor">
            <summary>
            <see cref="T:DotNetty.Common.Concurrency.IOrderedEventExecutor"/> backed by a single thread.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.#ctor(DotNetty.Common.Concurrency.IThreadFactory,System.Boolean)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Common.Concurrency.SingleThreadEventExecutor"/>.</summary>
            <param name="threadFactory">the <see cref="T:DotNetty.Common.Concurrency.IThreadFactory"/> which will be used for the used <see cref="T:DotNetty.Common.Concurrency.XThread"/>.</param>
            <param name="addTaskWakesUp"><c>true</c> if and only if invocation of <see cref="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.AddTask(DotNetty.Common.Concurrency.IRunnable)"/> will wake up the executor thread.</param>
        </member>
        <member name="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.#ctor(DotNetty.Common.Concurrency.IThreadFactory,System.Boolean,System.Int32)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Common.Concurrency.SingleThreadEventExecutor"/>.</summary>
            <param name="threadFactory">the <see cref="T:DotNetty.Common.Concurrency.IThreadFactory"/> which will be used for the used <see cref="T:DotNetty.Common.Concurrency.XThread"/>.</param>
            <param name="addTaskWakesUp"><c>true</c> if and only if invocation of <see cref="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.AddTask(DotNetty.Common.Concurrency.IRunnable)"/> will wake up the executor thread.</param>
            <param name="maxPendingTasks">the maximum number of pending tasks before new tasks will be rejected.</param>
        </member>
        <member name="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.#ctor(DotNetty.Common.Concurrency.IThreadFactory,System.Boolean,DotNetty.Common.Concurrency.IRejectedExecutionHandler)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Common.Concurrency.SingleThreadEventExecutor"/>.</summary>
            <param name="threadFactory">the <see cref="T:DotNetty.Common.Concurrency.IThreadFactory"/> which will be used for the used <see cref="T:DotNetty.Common.Concurrency.XThread"/>.</param>
            <param name="addTaskWakesUp"><c>true</c> if and only if invocation of <see cref="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.AddTask(DotNetty.Common.Concurrency.IRunnable)"/> will wake up the executor thread.</param>
            <param name="rejectedHandler">the <see cref="T:DotNetty.Common.Concurrency.IRejectedExecutionHandler"/> to use.</param>
        </member>
        <member name="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.#ctor(DotNetty.Common.Concurrency.IEventExecutorGroup,DotNetty.Common.Concurrency.IThreadFactory,System.Boolean)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Common.Concurrency.SingleThreadEventExecutor"/>.</summary>
            <param name="parent">the <see cref="T:DotNetty.Common.Concurrency.IEventExecutorGroup"/> which is the parent of this instance and belongs to it.</param>
            <param name="threadFactory">the <see cref="T:DotNetty.Common.Concurrency.IThreadFactory"/> which will be used for the used <see cref="T:DotNetty.Common.Concurrency.XThread"/>.</param>
            <param name="addTaskWakesUp"><c>true</c> if and only if invocation of <see cref="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.AddTask(DotNetty.Common.Concurrency.IRunnable)"/> will wake up the executor thread.</param>
        </member>
        <member name="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.#ctor(DotNetty.Common.Concurrency.IEventExecutorGroup,DotNetty.Common.Concurrency.IThreadFactory,System.Boolean,System.Int32)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Common.Concurrency.SingleThreadEventExecutor"/>.</summary>
            <param name="parent">the <see cref="T:DotNetty.Common.Concurrency.IEventExecutorGroup"/> which is the parent of this instance and belongs to it.</param>
            <param name="threadFactory">the <see cref="T:DotNetty.Common.Concurrency.IThreadFactory"/> which will be used for the used <see cref="T:DotNetty.Common.Concurrency.XThread"/>.</param>
            <param name="addTaskWakesUp"><c>true</c> if and only if invocation of <see cref="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.AddTask(DotNetty.Common.Concurrency.IRunnable)"/> will wake up the executor thread.</param>
            <param name="maxPendingTasks">the maximum number of pending tasks before new tasks will be rejected.</param>
        </member>
        <member name="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.#ctor(DotNetty.Common.Concurrency.IEventExecutorGroup,DotNetty.Common.Concurrency.IThreadFactory,System.Boolean,DotNetty.Common.Concurrency.IRejectedExecutionHandler)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Common.Concurrency.SingleThreadEventExecutor"/>.</summary>
            <param name="parent">the <see cref="T:DotNetty.Common.Concurrency.IEventExecutorGroup"/> which is the parent of this instance and belongs to it.</param>
            <param name="threadFactory">the <see cref="T:DotNetty.Common.Concurrency.IThreadFactory"/> which will be used for the used <see cref="T:DotNetty.Common.Concurrency.XThread"/>.</param>
            <param name="addTaskWakesUp"><c>true</c> if and only if invocation of <see cref="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.AddTask(DotNetty.Common.Concurrency.IRunnable)"/> will wake up the executor thread.</param>
            <param name="rejectedHandler">the <see cref="T:DotNetty.Common.Concurrency.IRejectedExecutionHandler"/> to use.</param>
        </member>
        <member name="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.#ctor(DotNetty.Common.Concurrency.IEventExecutorGroup,DotNetty.Common.Concurrency.IThreadFactory,System.Boolean,System.Int32,DotNetty.Common.Concurrency.IRejectedExecutionHandler)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Common.Concurrency.SingleThreadEventExecutor"/>.</summary>
            <param name="parent">the <see cref="T:DotNetty.Common.Concurrency.IEventExecutorGroup"/> which is the parent of this instance and belongs to it.</param>
            <param name="threadFactory">the <see cref="T:DotNetty.Common.Concurrency.IThreadFactory"/> which will be used for the used <see cref="T:DotNetty.Common.Concurrency.XThread"/>.</param>
            <param name="addTaskWakesUp"><c>true</c> if and only if invocation of <see cref="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.AddTask(DotNetty.Common.Concurrency.IRunnable)"/> will wake up the executor thread.</param>
            <param name="maxPendingTasks">the maximum number of pending tasks before new tasks will be rejected.</param>
            <param name="rejectedHandler">the <see cref="T:DotNetty.Common.Concurrency.IRejectedExecutionHandler"/> to use.</param>
        </member>
        <member name="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.#ctor(DotNetty.Common.Concurrency.IEventExecutorGroup,DotNetty.Common.Concurrency.IThreadFactory,System.Boolean,DotNetty.Common.Internal.IQueue{DotNetty.Common.Concurrency.IRunnable},DotNetty.Common.Concurrency.IRejectedExecutionHandler)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Common.Concurrency.SingleThreadEventExecutor"/>.</summary>
            <param name="parent">the <see cref="T:DotNetty.Common.Concurrency.IEventExecutorGroup"/> which is the parent of this instance and belongs to it.</param>
            <param name="threadFactory">the <see cref="T:DotNetty.Common.Concurrency.IThreadFactory"/> which will be used for the used <see cref="T:DotNetty.Common.Concurrency.XThread"/>.</param>
            <param name="addTaskWakesUp"><c>true</c> if and only if invocation of <see cref="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.AddTask(DotNetty.Common.Concurrency.IRunnable)"/> will wake up the executor thread.</param>
            <param name="taskQueue">The pending task queue.</param>
            <param name="rejectedHandler">the <see cref="T:DotNetty.Common.Concurrency.IRejectedExecutionHandler"/> to use.</param>
        </member>
        <member name="P:DotNetty.Common.Concurrency.SingleThreadEventExecutor.Scheduler">
            <summary>
            Task Scheduler that will post work to this executor's queue.
            </summary>
        </member>
        <member name="P:DotNetty.Common.Concurrency.SingleThreadEventExecutor.IsBacklogEmpty">
            <summary>
            Indicates whether executor's backlog is empty. Useful for diagnosing / mitigating stalls due to blocking calls in conjunction with Progress property.
            </summary>
        </member>
        <member name="P:DotNetty.Common.Concurrency.SingleThreadEventExecutor.BacklogLength">
            <summary>
            Gets length of backlog of tasks queued for immediate execution.
            </summary>
        </member>
        <member name="P:DotNetty.Common.Concurrency.SingleThreadEventExecutor.HasTasks">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:DotNetty.Common.Concurrency.SingleThreadEventExecutor.PendingTasks">
            <summary>
            Gets the number of tasks that are pending for processing.
            </summary>
            <remarks>Be aware that this operation may be expensive as it depends on the internal implementation of the
            <see cref="T:DotNetty.Common.Concurrency.SingleThreadEventExecutor"/>. So use it with care!</remarks>
        </member>
        <member name="P:DotNetty.Common.Concurrency.SingleThreadEventExecutor.IsShuttingDown">
            <inheritdoc />
        </member>
        <member name="P:DotNetty.Common.Concurrency.SingleThreadEventExecutor.IsShutdown">
            <inheritdoc />
        </member>
        <member name="P:DotNetty.Common.Concurrency.SingleThreadEventExecutor.IsTerminated">
            <inheritdoc />
        </member>
        <member name="P:DotNetty.Common.Concurrency.SingleThreadEventExecutor.TerminationCompletion">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.IsInEventLoop(DotNetty.Common.Concurrency.XThread)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.Reject(DotNetty.Common.Concurrency.IRunnable)">
            <summary>
            Offers the task to the associated <see cref="T:DotNetty.Common.Concurrency.IRejectedExecutionHandler"/>.
            </summary>
            <param name="task">The task to reject.</param>
        </member>
        <member name="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.TakeTask">
            <summary>
            Take the next <see cref="T:DotNetty.Common.Concurrency.IRunnable"/> from the task queue and so will block if no task is currently present.
            
            <para>Be aware that this method will throw an <see cref="T:System.NotSupportedException"/> if the task queue
            does not implement <see cref="T:DotNetty.Common.Internal.IBlockingQueue`1"/>.</para>
            </summary>
            <returns><c>null</c> if the executor thread has been interrupted or waken up.</returns>
        </member>
        <member name="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.ExecuteExpiredScheduledTasks">
            <summary>
            Return <c>true</c> if at least one scheduled task was executed.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.AddTask(DotNetty.Common.Concurrency.IRunnable)">
            <summary>
            Add a task to the task queue, or throws a <see cref="T:DotNetty.Common.Concurrency.RejectedExecutionException"/> if this instance was shutdown before.
            </summary>
            <param name="task"></param>
        </member>
        <member name="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.RunAllTasks">
            <summary>
            Poll all tasks from the task queue and run them via <see cref="M:DotNetty.Common.Concurrency.IRunnable.Run"/> method.
            </summary>
            <returns><c>true</c> if and only if at least one task was run</returns>
        </member>
        <member name="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.RunScheduledAndExecutorTasks(System.Int32)">
            <summary>
            Execute all expired scheduled tasks and all current tasks in the executor queue until both queues are empty,
            or <paramref name="maxDrainAttempts"/> has been exceeded.
            </summary>
            <param name="maxDrainAttempts">The maximum amount of times this method attempts to drain from queues. This is to prevent
            continuous task execution and scheduling from preventing the EventExecutor thread to
            make progress and return to the selector mechanism to process inbound I/O events.</param>
            <returns><c>true</c> if at least one task was run.</returns>
        </member>
        <member name="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.RunAllTasksFrom(DotNetty.Common.Internal.IQueue{DotNetty.Common.Concurrency.IRunnable})">
            <summary>
            Runs all tasks from the passed <paramref name="taskQueue"/>.
            </summary>
            <param name="taskQueue">To poll and execute all tasks.</param>
            <returns><c>true</c> if at least one task was executed.</returns>
        </member>
        <member name="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.RunExistingTasksFrom(DotNetty.Common.Internal.IQueue{DotNetty.Common.Concurrency.IRunnable})">
            <summary>
            What ever tasks are present in <paramref name="taskQueue"/> when this method is invoked will be <see cref="M:DotNetty.Common.Concurrency.IRunnable.Run"/>.
            </summary>
            <param name="taskQueue">the task queue to drain.</param>
            <returns><c>true</c> if at least <see cref="M:DotNetty.Common.Concurrency.IRunnable.Run"/> was called.</returns>
        </member>
        <member name="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.RunAllTasks(System.Int64)">
            <summary>
            Poll all tasks from the task queue and run them via <see cref="M:DotNetty.Common.Concurrency.IRunnable.Run"/> method.  This method stops running
            the tasks in the task queue and returns if it ran longer than <paramref name="timeout"/>.
            </summary>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.AfterRunningAllTasks">
            <summary>
            Invoked before returning from <see cref="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.RunAllTasks"/> and <see cref="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.RunAllTasks(System.Int64)"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.UpdateLastExecutionTime">
            <summary>
            Updates the internal timestamp that tells when a submitted task was executed most recently.
            <see cref="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.RunAllTasks"/> and <see cref="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.RunAllTasks(System.Int64)"/> updates this timestamp automatically, and thus there's
            usually no need to call this method.  However, if you take the tasks manually using <see cref="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.TakeTask"/> or
            <see cref="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.PollTask"/>, you have to call this method at the end of task execution loop for accurate quiet period
            checks.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.Run">
            <summary>
            Run the tasks in the <c>taskQueue</c>
            </summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.Cleanup">
            <summary>
            Do nothing, sub-classes may override
            </summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.AddShutdownHook(System.Action)">
            <summary>
            Adds an <see cref="T:System.Action"/> which will be executed on shutdown of this instance.
            </summary>
            <param name="action">The <see cref="T:System.Action"/> to run on shutdown.</param>
        </member>
        <member name="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.RemoveShutdownHook(System.Action)">
            <summary>
            Removes a previously added <see cref="T:System.Action"/> from the collection of <see cref="T:System.Action"/>s which will be
            executed on shutdown of this instance.
            </summary>
            <param name="action">The <see cref="T:System.Action"/> to remove.</param>
        </member>
        <member name="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.ShutdownGracefullyAsync(System.TimeSpan,System.TimeSpan)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.ConfirmShutdown">
            <summary>
            Confirm that the shutdown if the instance should be done now!
            </summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.SingleThreadEventExecutor.Execute(DotNetty.Common.Concurrency.IRunnable)">
            <inheritdoc />
        </member>
        <member name="T:DotNetty.Common.Concurrency.SingleThreadEventExecutorOld">
            <summary>
            <see cref="T:DotNetty.Common.Concurrency.IOrderedEventExecutor"/> backed by a single thread.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.SingleThreadEventExecutorOld.#ctor(System.String,System.TimeSpan)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Common.Concurrency.SingleThreadEventExecutorOld"/>.</summary>
        </member>
        <member name="M:DotNetty.Common.Concurrency.SingleThreadEventExecutorOld.#ctor(DotNetty.Common.Concurrency.IEventExecutorGroup,System.String,System.TimeSpan)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Common.Concurrency.SingleThreadEventExecutorOld"/>.</summary>
        </member>
        <member name="P:DotNetty.Common.Concurrency.SingleThreadEventExecutorOld.Scheduler">
            <summary>
                Task Scheduler that will post work to this executor's queue.
            </summary>
        </member>
        <member name="P:DotNetty.Common.Concurrency.SingleThreadEventExecutorOld.Progress">
            <summary>
                Allows to track whether executor is progressing through its backlog. Useful for diagnosing / mitigating stalls due to blocking calls in conjunction with IsBacklogEmpty property.
            </summary>
        </member>
        <member name="P:DotNetty.Common.Concurrency.SingleThreadEventExecutorOld.IsBacklogEmpty">
            <summary>
                Indicates whether executor's backlog is empty. Useful for diagnosing / mitigating stalls due to blocking calls in conjunction with Progress property.
            </summary>
        </member>
        <member name="P:DotNetty.Common.Concurrency.SingleThreadEventExecutorOld.BacklogLength">
            <summary>
                Gets length of backlog of tasks queued for immediate execution.
            </summary>
        </member>
        <member name="P:DotNetty.Common.Concurrency.SingleThreadEventExecutorOld.IsShuttingDown">
            <inheritdoc />
        </member>
        <member name="P:DotNetty.Common.Concurrency.SingleThreadEventExecutorOld.TerminationCompletion">
            <inheritdoc />
        </member>
        <member name="P:DotNetty.Common.Concurrency.SingleThreadEventExecutorOld.IsShutdown">
            <inheritdoc />
        </member>
        <member name="P:DotNetty.Common.Concurrency.SingleThreadEventExecutorOld.IsTerminated">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.SingleThreadEventExecutorOld.IsInEventLoop(DotNetty.Common.Concurrency.XThread)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.SingleThreadEventExecutorOld.Execute(DotNetty.Common.Concurrency.IRunnable)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.SingleThreadEventExecutorOld.AddShutdownHook(System.Action)">
            <summary>
            Adds an <see cref="T:System.Action"/> which will be executed on shutdown of this instance.
            </summary>
            <param name="action">The <see cref="T:System.Action"/> to run on shutdown.</param>
        </member>
        <member name="M:DotNetty.Common.Concurrency.SingleThreadEventExecutorOld.RemoveShutdownHook(System.Action)">
            <summary>
            Removes a previously added <see cref="T:System.Action"/> from the collection of <see cref="T:System.Action"/>s which will be
            executed on shutdown of this instance.
            </summary>
            <param name="action">The <see cref="T:System.Action"/> to remove.</param>
        </member>
        <member name="M:DotNetty.Common.Concurrency.SingleThreadEventExecutorOld.ShutdownGracefullyAsync(System.TimeSpan,System.TimeSpan)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Concurrency.SingleThreadEventExecutorOld.AfterRunningAllTasks">
            <summary>
            Invoked before returning from <see cref="M:DotNetty.Common.Concurrency.SingleThreadEventExecutorOld.RunAllTasks"/> and <see cref="M:DotNetty.Common.Concurrency.SingleThreadEventExecutorOld.RunAllTasks(DotNetty.Common.PreciseTimeSpan)"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Common.FastThreadLocal.RemoveAll">
            <summary>
                Removes all <see cref="T:DotNetty.Common.FastThreadLocal"/> variables bound to the current thread.  This operation is useful when you
                are in a container environment, and you don't want to leave the thread local variables in the threads you do not
                manage.
            </summary>
        </member>
        <member name="M:DotNetty.Common.FastThreadLocal.Destroy">
            <summary>
            Destroys the data structure that keeps all <see cref="T:DotNetty.Common.FastThreadLocal"/> variables accessed from
            non-<see cref="T:DotNetty.Common.FastThreadLocal"/>s.  This operation is useful when you are in a container environment, and
            you do not want to leave the thread local variables in the threads you do not manage.  Call this method when
            your application is being unloaded from the container.
            </summary>
        </member>
        <member name="M:DotNetty.Common.FastThreadLocal.Remove(DotNetty.Common.InternalThreadLocalMap)">
            <summary>
                Sets the value to uninitialized; a proceeding call to get() will trigger a call to GetInitialValue().
            </summary>
            <param name="threadLocalMap"></param>
        </member>
        <member name="P:DotNetty.Common.FastThreadLocal`1.Count">
            <summary>
                Returns the number of thread local variables bound to the current thread.
            </summary>
        </member>
        <member name="P:DotNetty.Common.FastThreadLocal`1.Value">
            <summary>
                Gets or sets current value for the current thread.
            </summary>
        </member>
        <member name="M:DotNetty.Common.FastThreadLocal`1.Get(DotNetty.Common.InternalThreadLocalMap)">
            <summary>
                Returns the current value for the specified thread local map.
                The specified thread local map must be for the current thread.
            </summary>
        </member>
        <member name="M:DotNetty.Common.FastThreadLocal`1.Set(DotNetty.Common.InternalThreadLocalMap,`0)">
            <summary>
            Set the value for the specified thread local map. The specified thread local map must be for the current thread.
            </summary>
        </member>
        <member name="M:DotNetty.Common.FastThreadLocal`1.IsSet">
            <summary>
            Returns <c>true</c> if and only if this thread-local variable is set.
            </summary>
        </member>
        <member name="M:DotNetty.Common.FastThreadLocal`1.IsSet(DotNetty.Common.InternalThreadLocalMap)">
            <summary>
            Returns <c>true</c> if and only if this thread-local variable is set.
            The specified thread local map must be for the current thread.
            </summary>
        </member>
        <member name="M:DotNetty.Common.FastThreadLocal`1.GetInitialValue">
            <summary>
            Returns the initial value for this thread-local variable.
            </summary>
        </member>
        <member name="M:DotNetty.Common.FastThreadLocal`1.Remove(DotNetty.Common.InternalThreadLocalMap)">
            <summary>
            Sets the value to uninitialized for the specified thread local map;
            a proceeding call to <see cref="M:DotNetty.Common.FastThreadLocal`1.Get(DotNetty.Common.InternalThreadLocalMap)"/> will trigger a call to <see cref="M:DotNetty.Common.FastThreadLocal`1.GetInitialValue"/>.
            The specified thread local map must be for the current thread.
            </summary>
            <param name="threadLocalMap">
            The <see cref="T:DotNetty.Common.InternalThreadLocalMap"/> from which this <see cref="T:DotNetty.Common.FastThreadLocal"/> should be removed.
            </param>
        </member>
        <member name="M:DotNetty.Common.FastThreadLocal`1.OnRemoval(`0)">
            <summary>
            Invoked when this thread local variable is removed by <see cref="M:DotNetty.Common.FastThreadLocal`1.Remove"/>.
            </summary>
        </member>
        <member name="T:DotNetty.Common.InternalThreadLocalMap">
            <summary>
            The internal data structure that stores the thread-local variables for DotNetty and all
            <see cref="T:DotNetty.Common.FastThreadLocal"/>s. Note that this class is for internal use only and is subject to change at any
            time. Use <see cref="T:DotNetty.Common.FastThreadLocal"/> unless you know what you are doing.
            </summary>
        </member>
        <member name="F:DotNetty.Common.InternalThreadLocalMap._indexedVariables">
            <summary>
            Used by <see cref="T:DotNetty.Common.FastThreadLocal"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Common.InternalThreadLocalMap.SetIndexedVariable(System.Int32,System.Object)">
            <summary>
            Sets a value at the given index in this <see cref="T:DotNetty.Common.InternalThreadLocalMap"/>.
            </summary>
            <param name="index">The desired index at which a value should be set.</param>
            <param name="value">The value to set at the given index.</param>
            <returns><c>true</c> if and only if a new thread-local variable has been created.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.AppendableCharSequence.Reset">
            <summary>
            Resets the <see cref="T:DotNetty.Common.Internal.AppendableCharSequence"/>. Be aware this will only reset the current internal
            position and not shrink the internal char array.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.AppendableCharSequence.SubStringUnsafe(System.Int32,System.Int32)">
            <summary>
            Create a new ascii string, this method assumes all chars has been sanitized to ascii chars when appending
            to the array.
            </summary>
        </member>
        <member name="T:DotNetty.Common.Internal.ArrayBuilder`1">
            <summary>
            Helper type for avoiding allocations while building arrays.
            </summary>
            <typeparam name="T">The element type.</typeparam>
        </member>
        <member name="M:DotNetty.Common.Internal.ArrayBuilder`1.#ctor(System.Int32)">
            <summary>
            Initializes the <see cref="T:DotNetty.Common.Internal.ArrayBuilder`1"/> with a specified capacity.
            </summary>
            <param name="capacity">The capacity of the array to allocate.</param>
        </member>
        <member name="P:DotNetty.Common.Internal.ArrayBuilder`1.Capacity">
            <summary>
            Gets the number of items this instance can store without re-allocating,
            or 0 if the backing array is <c>null</c>.
            </summary>
        </member>
        <member name="P:DotNetty.Common.Internal.ArrayBuilder`1.Count">
            <summary>
            Gets the number of items in the array currently in use.
            </summary>
        </member>
        <member name="P:DotNetty.Common.Internal.ArrayBuilder`1.Item(System.Int32)">
            <summary>
            Gets or sets the item at a certain index in the array.
            </summary>
            <param name="index">The index into the array.</param>
        </member>
        <member name="M:DotNetty.Common.Internal.ArrayBuilder`1.Add(`0)">
            <summary>
            Adds an item to the backing array, resizing it if necessary.
            </summary>
            <param name="item">The item to add.</param>
        </member>
        <member name="M:DotNetty.Common.Internal.ArrayBuilder`1.First">
            <summary>
            Gets the first item in this builder.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.ArrayBuilder`1.Last">
            <summary>
            Gets the last item in this builder.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.ArrayBuilder`1.ToArray">
            <summary>
            Creates an array from the contents of this builder.
            </summary>
            <remarks>
            Do not call this method twice on the same builder.
            </remarks>
        </member>
        <member name="M:DotNetty.Common.Internal.ArrayBuilder`1.UncheckedAdd(`0)">
            <summary>
            Adds an item to the backing array, without checking if there is room.
            </summary>
            <param name="item">The item to add.</param>
            <remarks>
            Use this method if you know there is enough space in the <see cref="T:DotNetty.Common.Internal.ArrayBuilder`1"/>
            for another item, and you are writing performance-sensitive code.
            </remarks>
        </member>
        <member name="T:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2">
            <summary>A thread-safe dictionary for read-heavy workloads.</summary>
            <typeparam name="TKey">The key type.</typeparam>
            <typeparam name="TValue">The value type.</typeparam>
        </member>
        <member name="P:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2.DefaultConcurrencyLevel">
            <summary>The number of concurrent writes for which to optimize by default.</summary>
        </member>
        <member name="F:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2.CacheMissesBeforeCaching">
            <summary>The number of cache misses which are tolerated before the cache is regenerated.</summary>
        </member>
        <member name="F:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2._cacheMissReads">
            <summary>Approximate number of reads which did not hit the cache since it was last invalidated.
            This is used as a heuristic that the dictionary is not being modified frequently with respect to the read volume.</summary>
        </member>
        <member name="F:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2._readCache">
            <summary>Cached version of inner concurrent dictionary.</summary>
        </member>
        <member name="M:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2.#ctor">
            <summary>Initializes a new instance of the <see cref="T:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2"/> class.</summary>
        </member>
        <member name="M:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2.#ctor(System.Int32)">
            <summary>Initializes a new instance of the <see cref="T:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2"/> class.</summary>
            <param name="capacity">The initial number of elements that the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> can contain.</param>
        </member>
        <member name="M:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>Initializes a new instance of the <see cref="T:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2"/> class
            that contains elements copied from the specified collection and uses the specified
            <see cref="T:System.Collections.Generic.IEqualityComparer{TKey}"/>.</summary>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> implementation to use when comparing keys.</param>
        </member>
        <member name="M:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>Initializes a new instance of the <see cref="T:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2"/> class.</summary>
            <param name="capacity">The initial number of elements that the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> can contain.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> implementation to use when comparing keys.</param>
        </member>
        <member name="M:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>Initializes a new instance of the <see cref="T:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2"/> class
            that contains elements copied from the specified collection.</summary>
            <param name="collection">The <see cref="T:IEnumerable{KeyValuePair{TKey,TValue}}"/> whose elements are copied to the new instance.</param>
        </member>
        <member name="M:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>Initializes a new instance of the <see cref="T:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2"/>
            class that contains elements copied from the specified collection and uses the specified
            <see cref="T:System.Collections.Generic.IEqualityComparer{TKey}"/>.</summary>
            <param name="collection">The <see cref="T:IEnumerable{KeyValuePair{TKey,TValue}}"/> whose elements are copied to the new instance.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> implementation to use when comparing keys.</param>
        </member>
        <member name="M:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2.Clear">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc />
        </member>
        <member name="P:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2.Count">
            <inheritdoc />
        </member>
        <member name="P:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2.Add(`0,`1)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})">
            <summary>Adds a key/value pair to the <see cref="T:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2"/> if the key does not exist.</summary>
            <param name="key">The key of the element to add.</param>
            <param name="valueFactory">The function used to generate a value for the key</param>
            <returns>The value for the key.  This will be either the existing value for the key if the
            key is already in the dictionary, or the new value for the key as returned by valueFactory
            if the key was not in the dictionary.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2.GetOrAdd``1(`0,System.Func{`0,``0,`1},``0)">
            <summary>Adds a key/value pair to the <see cref="T:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2"/> if the key does not already exist.</summary>
            <param name="key">The key of the element to add.</param>
            <param name="valueFactory">The function used to generate a value for the key</param>
            <param name="factoryArgument">An argument value to pass into <paramref name="valueFactory"/>.</param>
            <returns>The value for the key.  This will be either the existing value for the key if the
            key is already in the dictionary, or the new value for the key as returned by valueFactory
            if the key was not in the dictionary.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2.GetOrAdd``2(`0,System.Func{`0,``0,``1,`1},``0,``1)">
            <summary>Adds a key/value pair to the <see cref="T:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2"/> if the key does not already exist.</summary>
            <param name="key">The key of the element to add.</param>
            <param name="valueFactory">The function used to generate a value for the key</param>
            <param name="factoryArg1">An argument value to pass into <paramref name="valueFactory"/>.</param>
            <param name="factoryArg2">An argument value to pass into <paramref name="valueFactory"/>.</param>
            <returns>The value for the key.  This will be either the existing value for the key if the
            key is already in the dictionary, or the new value for the key as returned by valueFactory
            if the key was not in the dictionary.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2.GetOrAdd``3(`0,System.Func{`0,``0,``1,``2,`1},``0,``1,``2)">
            <summary>Adds a key/value pair to the <see cref="T:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2"/> if the key does not already exist.</summary>
            <param name="key">The key of the element to add.</param>
            <param name="valueFactory">The function used to generate a value for the key</param>
            <param name="factoryArg1">An argument value to pass into <paramref name="valueFactory"/>.</param>
            <param name="factoryArg2">An argument value to pass into <paramref name="valueFactory"/>.</param>
            <param name="factoryArg3">An argument value to pass into <paramref name="valueFactory"/>.</param>
            <returns>The value for the key.  This will be either the existing value for the key if the
            key is already in the dictionary, or the new value for the key as returned by valueFactory
            if the key was not in the dictionary.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2.GetOrAdd``4(`0,System.Func{`0,``0,``1,``2,``3,`1},``0,``1,``2,``3)">
            <summary>Adds a key/value pair to the <see cref="T:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2"/> if the key does not already exist.</summary>
            <param name="key">The key of the element to add.</param>
            <param name="valueFactory">The function used to generate a value for the key</param>
            <param name="factoryArg1">An argument value to pass into <paramref name="valueFactory"/>.</param>
            <param name="factoryArg2">An argument value to pass into <paramref name="valueFactory"/>.</param>
            <param name="factoryArg3">An argument value to pass into <paramref name="valueFactory"/>.</param>
            <param name="factoryArg4">An argument value to pass into <paramref name="valueFactory"/>.</param>
            <returns>The value for the key.  This will be either the existing value for the key if the
            key is already in the dictionary, or the new value for the key as returned by valueFactory
            if the key was not in the dictionary.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2.GetOrAdd``5(`0,System.Func{`0,``0,``1,``2,``3,``4,`1},``0,``1,``2,``3,``4)">
            <summary>Adds a key/value pair to the <see cref="T:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2"/> if the key does not already exist.</summary>
            <param name="key">The key of the element to add.</param>
            <param name="valueFactory">The function used to generate a value for the key</param>
            <param name="factoryArg1">An argument value to pass into <paramref name="valueFactory"/>.</param>
            <param name="factoryArg2">An argument value to pass into <paramref name="valueFactory"/>.</param>
            <param name="factoryArg3">An argument value to pass into <paramref name="valueFactory"/>.</param>
            <param name="factoryArg4">An argument value to pass into <paramref name="valueFactory"/>.</param>
            <param name="factoryArg5">An argument value to pass into <paramref name="valueFactory"/>.</param>
            <returns>The value for the key.  This will be either the existing value for the key if the
            key is already in the dictionary, or the new value for the key as returned by valueFactory
            if the key was not in the dictionary.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2.GetOrAdd``6(`0,System.Func{`0,``0,``1,``2,``3,``4,``5,`1},``0,``1,``2,``3,``4,``5)">
            <summary>Adds a key/value pair to the <see cref="T:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2"/> if the key does not already exist.</summary>
            <param name="key">The key of the element to add.</param>
            <param name="valueFactory">The function used to generate a value for the key</param>
            <param name="factoryArg1">An argument value to pass into <paramref name="valueFactory"/>.</param>
            <param name="factoryArg2">An argument value to pass into <paramref name="valueFactory"/>.</param>
            <param name="factoryArg3">An argument value to pass into <paramref name="valueFactory"/>.</param>
            <param name="factoryArg4">An argument value to pass into <paramref name="valueFactory"/>.</param>
            <param name="factoryArg5">An argument value to pass into <paramref name="valueFactory"/>.</param>
            <param name="factoryArg6">An argument value to pass into <paramref name="valueFactory"/>.</param>
            <returns>The value for the key.  This will be either the existing value for the key if the
            key is already in the dictionary, or the new value for the key as returned by valueFactory
            if the key was not in the dictionary.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2.GetOrAdd``7(`0,System.Func{`0,``0,``1,``2,``3,``4,``5,``6,`1},``0,``1,``2,``3,``4,``5,``6)">
            <summary>Adds a key/value pair to the <see cref="T:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2"/> if the key does not already exist.</summary>
            <param name="key">The key of the element to add.</param>
            <param name="valueFactory">The function used to generate a value for the key</param>
            <param name="factoryArg1">An argument value to pass into <paramref name="valueFactory"/>.</param>
            <param name="factoryArg2">An argument value to pass into <paramref name="valueFactory"/>.</param>
            <param name="factoryArg3">An argument value to pass into <paramref name="valueFactory"/>.</param>
            <param name="factoryArg4">An argument value to pass into <paramref name="valueFactory"/>.</param>
            <param name="factoryArg5">An argument value to pass into <paramref name="valueFactory"/>.</param>
            <param name="factoryArg6">An argument value to pass into <paramref name="valueFactory"/>.</param>
            <param name="factoryArg7">An argument value to pass into <paramref name="valueFactory"/>.</param>
            <returns>The value for the key.  This will be either the existing value for the key if the
            key is already in the dictionary, or the new value for the key as returned by valueFactory
            if the key was not in the dictionary.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2.TryAdd(`0,`1)">
            <summary>Attempts to add the specified key and value.</summary>
            <param name="key">The key of the element to add.</param>
            <param name="value">The value of the element to add. The value can be a null reference (Nothing
            in Visual Basic) for reference types.</param>
            <returns>true if the key/value pair was added successfully; otherwise, false.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2.ContainsKey(`0)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2.Remove(`0)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2.TryRemove(`0,`1@)">
            <summary>TryRemove</summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2.TryGetValue(`0,`1@)">
            <inheritdoc />
        </member>
        <member name="P:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2.Item(`0)">
            <inheritdoc />
        </member>
        <member name="P:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2.Keys">
            <inheritdoc />
        </member>
        <member name="P:DotNetty.Common.Internal.CachedReadConcurrentDictionary`2.Values">
            <inheritdoc />
        </member>
        <member name="T:DotNetty.Common.Internal.ConcurrentCircularArrayQueue`1">
            Forked from
            <a href="https://github.com/JCTools/JCTools">JCTools</a>
            .
            A concurrent access enabling class used by circular array based queues this class exposes an offset computation
            method along with differently memory fenced load/store methods into the underlying array. The class is pre-padded and
            the array is padded on either side to help with False sharing prvention. It is expected theat subclasses handle post
            padding.
            <p />
            Offset calculation is separate from access to enable the reuse of a give compute offset.
            <p />
            Load/Store methods using a
            <i>buffer</i>
            parameter are provided to allow the prevention of field reload after a
            LoadLoad barrier.
            <p />
        </member>
        <member name="M:DotNetty.Common.Internal.ConcurrentCircularArrayQueue`1.CalcElementOffset(System.Int64)">
            <summary>
            Calculates an element offset based on a given array index.
            </summary>
            <param name="index">The desirable element index.</param>
            <returns>The offset in bytes within the array for a given index.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.ConcurrentCircularArrayQueue`1.SpElement(System.Int64,`0)">
            <summary>
            A plain store (no ordering/fences) of an element to a given offset.
            </summary>
            <param name="offset">Computed via <see cref="M:DotNetty.Common.Internal.ConcurrentCircularArrayQueue`1.CalcElementOffset(System.Int64)"/>.</param>
            <param name="e">A kitty.</param>
        </member>
        <member name="M:DotNetty.Common.Internal.ConcurrentCircularArrayQueue`1.SoElement(System.Int64,`0)">
            <summary>
            An ordered store(store + StoreStore barrier) of an element to a given offset.
            </summary>
            <param name="offset">Computed via <see cref="M:DotNetty.Common.Internal.ConcurrentCircularArrayQueue`1.CalcElementOffset(System.Int64)"/>.</param>
            <param name="e">An orderly kitty.</param>
        </member>
        <member name="M:DotNetty.Common.Internal.ConcurrentCircularArrayQueue`1.LpElement(System.Int64)">
            <summary>
            A plain load (no ordering/fences) of an element from a given offset.
            </summary>
            <param name="offset">Computed via <see cref="M:DotNetty.Common.Internal.ConcurrentCircularArrayQueue`1.CalcElementOffset(System.Int64)"/>.</param>
            <returns>The element at the offset.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.ConcurrentCircularArrayQueue`1.LvElement(System.Int64)">
            <summary>
            A volatile load (load + LoadLoad barrier) of an element from a given offset.
            </summary>
            <param name="offset">Computed via <see cref="M:DotNetty.Common.Internal.ConcurrentCircularArrayQueue`1.CalcElementOffset(System.Int64)"/>.</param>
            <returns>The element at the offset.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.ConstantTimeUtils.EqualsConstantTime(System.Int32,System.Int32)">
            <summary>
            Compare two <see cref="T:System.Int32"/>s without leaking timing information.
            <code>
            int v1 = 1;
            int v1 = 1;
            int v1 = 1;
            int v1 = 500;
            bool equals = (EqualsConstantTime(l1, l2) &amp; EqualsConstantTime(l3, l4)) != 0;
            </code>.
            </summary>
            <param name="x">the first value.</param>
            <param name="y">the second value.</param>
            <returns><c>0</c>if not equal. <c>1</c> if equal.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.ConstantTimeUtils.EqualsConstantTime(System.Int64,System.Int64)">
            <summary>
            Compare two <see cref="T:System.Int64"/>s without leaking timing information.
            <code>
            long v1 = 1;
            long v1 = 1;
            long v1 = 1;
            long v1 = 500;
            bool equals = (EqualsConstantTime(l1, l2) &amp; EqualsConstantTime(l3, l4)) != 0;
            </code>.
            </summary>
            <param name="x">the first value.</param>
            <param name="y">the second value.</param>
            <returns><c>0</c>if not equal. <c>1</c> if equal.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.ConstantTimeUtils.EqualsConstantTime(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Compare two {@code byte} arrays for equality without leaking timing information.
            For performance reasons no bounds checking on the parameters is performed.
            
            <para>The <see cref="T:System.Int32"/> return type is intentional and is designed to allow cascading of constant time operations:</para>
            <code>
                byte[] s1 = new {1, 2, 3};
                byte[] s2 = new {1, 2, 3};
                byte[] s3 = new {1, 2, 3};
                byte[] s4 = new {4, 5, 6};
                boolean equals = (EqualsConstantTime(s1, 0, s2, 0, s1.length) &amp;
                                  EqualsConstantTime(s3, 0, s4, 0, s3.length)) != 0;
            </code>
            </summary>
            <param name="bytes1">the first byte array.</param>
            <param name="startPos1">the position (inclusive) to start comparing in <paramref name="bytes1"/>.</param>
            <param name="bytes2">the second byte array.</param>
            <param name="startPos2">the position (inclusive) to start comparing in <paramref name="bytes2"/>.</param>
            <param name="length">the amount of bytes to compare. This is assumed to be validated as not going out of bounds
            by the caller.</param>
            <returns><c>0</c> if not equal. <c>1</c> if equal.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.ConstantTimeUtils.EqualsConstantTime(DotNetty.Common.Utilities.ICharSequence,DotNetty.Common.Utilities.ICharSequence)">
            <summary>
            Compare two {@link CharSequence} objects without leaking timing information.
            
            <para>The <see cref="T:System.Int32"/> return type is intentional and is designed to allow cascading of constant time operations:</para>
            <code>
                String s1 = "foo";
                String s2 = "foo";
                String s3 = "foo";
                String s4 = "goo";
                boolean equals = (EqualsConstantTime(s1, s2) &amp; EqualsConstantTime(s3, s4)) != 0;
            </code>
            </summary>
            <param name="s1">the first value.</param>
            <param name="s2">the second value.</param>
            <returns><c>0</c> if not equal. <c>1</c> if equal.</returns>
        </member>
        <member name="T:DotNetty.Common.Internal.Deque`1">
            <summary>A double-ended queue (deque), which provides O(1) indexed access, O(1) removals from the front and back, 
            amortized O(1) insertions to the front and back, and O(N) insertions and removals anywhere else 
            (with the operations getting slower as the index approaches the middle).</summary>
            <typeparam name="T">The type of elements contained in the deque.</typeparam>
        </member>
        <member name="F:DotNetty.Common.Internal.Deque`1.DefaultCapacity">
            <summary>The default capacity.</summary>
        </member>
        <member name="F:DotNetty.Common.Internal.Deque`1._buffer">
            <summary>The circular _buffer that holds the view.</summary>
        </member>
        <member name="F:DotNetty.Common.Internal.Deque`1._offset">
            <summary>The offset into <see cref="F:DotNetty.Common.Internal.Deque`1._buffer"/> where the view begins.</summary>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.#ctor">
            <summary>Initializes a new instance of the <see cref="T:DotNetty.Common.Internal.Deque`1"/> class.</summary>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.#ctor(System.Int32)">
            <summary>Initializes a new instance of the <see cref="T:DotNetty.Common.Internal.Deque`1"/> class with the specified capacity.</summary>
            <param name="capacity">The initial capacity. Must be greater than <c>0</c>.</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.#ctor(System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:DotNetty.Common.Internal.Deque`1"/> class with the specified capacity.</summary>
            <param name="useReversingEnumerator"></param>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>Initializes a new instance of the <see cref="T:DotNetty.Common.Internal.Deque`1"/> class with the specified capacity.</summary>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> implementation to use when comparing elements, 
            or null to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1"/> for the type of the element.</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.#ctor(System.Int32,System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:DotNetty.Common.Internal.Deque`1"/> class with the specified capacity.</summary>
            <param name="capacity">The initial capacity. Must be greater than <c>0</c>.</param>
            <param name="useReversingEnumerator"></param>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>Initializes a new instance of the <see cref="T:DotNetty.Common.Internal.Deque`1"/> class with the specified capacity.</summary>
            <param name="capacity">The initial capacity. Must be greater than <c>0</c>.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> implementation to use when comparing elements, 
            or null to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1"/> for the type of the element.</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.#ctor(System.Boolean,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>Initializes a new instance of the <see cref="T:DotNetty.Common.Internal.Deque`1"/> class with the specified capacity.</summary>
            <param name="useReversingEnumerator"></param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> implementation to use when comparing elements, 
            or null to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1"/> for the type of the element.</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.#ctor(System.Int32,System.Boolean,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>Initializes a new instance of the <see cref="T:DotNetty.Common.Internal.Deque`1"/> class with the specified capacity.</summary>
            <param name="capacity">The initial capacity. Must be greater than <c>0</c>.</param>
            <param name="useReversingEnumerator"></param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> implementation to use when comparing elements, 
            or null to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1"/> for the type of the element.</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>Initializes a new instance of the <see cref="T:DotNetty.Common.Internal.Deque`1"/> class with the elements from the specified collection.</summary>
            <param name="collection">The collection. May not be <c>null</c>.</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>Initializes a new instance of the <see cref="T:DotNetty.Common.Internal.Deque`1"/> class with the elements from the specified collection.</summary>
            <param name="collection">The collection. May not be <c>null</c>.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> implementation to use when comparing elements, 
            or null to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1"/> for the type of the element.</param>
        </member>
        <member name="P:DotNetty.Common.Internal.Deque`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <summary>Gets a value indicating whether this list is read-only. This implementation always returns <c>false</c>.</summary>
            <returns>true if this list is read-only; otherwise, false.</returns>
        </member>
        <member name="P:DotNetty.Common.Internal.Deque`1.Item(System.Int32)">
            <summary>Gets or sets the item at the specified index.</summary>
            <param name="index">The index of the item to get or set.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is not a valid index in this list.</exception>
            <exception cref="T:System.NotSupportedException">This property is set and the list is read-only.</exception>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.Insert(System.Int32,`0)">
            <summary>Inserts an item to this list at the specified index.</summary>
            <param name="index">The zero-based index at which <paramref name="item"/> should be inserted.</param>
            <param name="item">The object to insert into this list.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="index"/> is not a valid index in this list.
            </exception>
            <exception cref="T:System.NotSupportedException">
            This list is read-only.
            </exception>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.RemoveAt(System.Int32)">
            <summary>Removes the item at the specified index.</summary>
            <param name="index">The zero-based index of the item to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="index"/> is not a valid index in this list.
            </exception>
            <exception cref="T:System.NotSupportedException">
            This list is read-only.
            </exception>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.IndexOf(`0)">
            <summary>Determines the index of a specific item in this list.</summary>
            <param name="item">The object to locate in this list.</param>
            <returns>The index of <paramref name="item"/> if found in this list; otherwise, -1.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <summary>Adds an item to the end of this list.</summary>
            <param name="item">The object to add to this list.</param>
            <exception cref="T:System.NotSupportedException">
            This list is read-only.
            </exception>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.Contains(`0)">
            <summary>Determines whether this list contains a specific value.</summary>
            <param name="item">The object to locate in this list.</param>
            <returns>true if <paramref name="item"/> is found in this list; otherwise, false.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.CopyTo(`0[],System.Int32)">
            <summary>Copies the elements of this list to an <see cref="T:System.Array"/>, starting at a particular <see cref="T:System.Array"/> index.</summary>
            <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the destination of the elements copied from this slice. The <see cref="T:System.Array"/> must have zero-based indexing.</param>
            <param name="arrayIndex">The zero-based index in <paramref name="array"/> at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="array"/> is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="arrayIndex"/> is less than 0.
            </exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
            -or-
            The number of elements in the source <see cref="T:System.Collections.Generic.ICollection`1"/> is greater than the available space from <paramref name="arrayIndex"/> to the end of the destination <paramref name="array"/>.
            </exception>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.CopyToArray(System.Array,System.Int32)">
            <summary>Copies the deque elemens into an array. The resulting array always has all the deque elements contiguously.</summary>
            <param name="array">The destination array.</param>
            <param name="arrayIndex">The optional index in the destination array at which to begin writing.</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.Remove(`0)">
            <summary>Removes the first occurrence of a specific object from this list.</summary>
            <param name="item">The object to remove from this list.</param>
            <returns>true if <paramref name="item"/> was successfully removed from this list; otherwise, false. This method also returns false if <paramref name="item"/> is not found in this list.</returns>
            <exception cref="T:System.NotSupportedException">
            This list is read-only.
            </exception>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.GetEnumerator">
            <summary>Returns an enumerator that iterates through the collection.</summary>
            <returns>A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <internalonly/>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.CheckNewIndexArgument(System.Int32,System.Int32)">
            <summary>Checks the <paramref name="index"/> argument to see if it refers to a valid insertion point in a source of a given length.</summary>
            <param name="sourceLength">The length of the source. This parameter is not checked for validity.</param>
            <param name="index">The index into the source.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is not a valid index to an insertion point for the source.</exception>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.CheckExistingIndexArgument(System.Int32,System.Int32)">
            <summary>Checks the <paramref name="index"/> argument to see if it refers to an existing element in a source of a given length.</summary>
            <param name="sourceLength">The length of the source. This parameter is not checked for validity.</param>
            <param name="index">The index into the source.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is not a valid index to an existing element for the source.</exception>
        </member>
        <member name="P:DotNetty.Common.Internal.Deque`1.IsEmpty">
            <summary>Gets a value indicating whether this instance is empty.</summary>
        </member>
        <member name="P:DotNetty.Common.Internal.Deque`1.IsFull">
            <summary>Gets a value indicating whether this instance is at full capacity.</summary>
        </member>
        <member name="P:DotNetty.Common.Internal.Deque`1.IsSplit">
            <summary>Gets a value indicating whether the buffer is "split" (meaning the beginning of the view is at a later index in <see cref="F:DotNetty.Common.Internal.Deque`1._buffer"/> than the end).</summary>
        </member>
        <member name="P:DotNetty.Common.Internal.Deque`1.Capacity">
            <summary>Gets or sets the capacity for this deque. This value must always be greater than zero, and this property cannot be set to a value less than <see cref="P:DotNetty.Common.Internal.Deque`1.Count"/>.</summary>
            <exception cref="T:System.InvalidOperationException"><c>Capacity</c> cannot be set to a value less than <see cref="P:DotNetty.Common.Internal.Deque`1.Count"/>.</exception>
        </member>
        <member name="P:DotNetty.Common.Internal.Deque`1.Count">
            <summary>Gets the number of elements contained in this deque.</summary>
            <returns>The number of elements contained in this deque.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.DequeIndexToBufferIndex(System.Int32)">
            <summary>Applies the offset to <paramref name="index"/>, resulting in a buffer index.</summary>
            <param name="index">The deque index.</param>
            <returns>The buffer index.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.DoGetItem(System.Int32)">
            <summary>Gets an element at the specified view index.</summary>
            <param name="index">The zero-based view index of the element to get. This index is guaranteed to be valid.</param>
            <returns>The element at the specified index.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.DoSetItem(System.Int32,`0)">
            <summary>Sets an element at the specified view index.</summary>
            <param name="index">The zero-based view index of the element to get. This index is guaranteed to be valid.</param>
            <param name="item">The element to store in the list.</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.DoInsert(System.Int32,`0)">
            <summary>Inserts an element at the specified view index.</summary>
            <param name="index">The zero-based view index at which the element should be inserted. This index is guaranteed to be valid.</param>
            <param name="item">The element to store in the list.</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.DoRemoveAt(System.Int32)">
            <summary>Removes an element at the specified view index.</summary>
            <param name="index">The zero-based view index of the element to remove. This index is guaranteed to be valid.</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.PostIncrement(System.Int32@,System.Int32)">
            <summary>Increments <see cref="F:DotNetty.Common.Internal.Deque`1._offset"/> by <paramref name="value"/> using modulo-<see cref="P:DotNetty.Common.Internal.Deque`1.Capacity"/> arithmetic.</summary>
            <param name="offset">The offset into <see cref="F:DotNetty.Common.Internal.Deque`1._buffer"/> where the view begins.</param>
            <param name="value">The value by which to increase <see cref="F:DotNetty.Common.Internal.Deque`1._offset"/>. May not be negative.</param>
            <returns>The value of <see cref="F:DotNetty.Common.Internal.Deque`1._offset"/> after it was incremented.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.PreDecrement(System.Int32@,System.Int32)">
            <summary>Decrements <see cref="F:DotNetty.Common.Internal.Deque`1._offset"/> by <paramref name="value"/> using modulo-<see cref="P:DotNetty.Common.Internal.Deque`1.Capacity"/> arithmetic.</summary>
            <param name="offset">The offset into <see cref="F:DotNetty.Common.Internal.Deque`1._buffer"/> where the view begins.</param>
            <param name="value">The value by which to reduce <see cref="F:DotNetty.Common.Internal.Deque`1._offset"/>. May not be negative or greater than <see cref="P:DotNetty.Common.Internal.Deque`1.Capacity"/>.</param>
            <returns>The value of <see cref="F:DotNetty.Common.Internal.Deque`1._offset"/> before it was decremented.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.DoAddToBack(`0)">
            <summary>Inserts a single element to the back of the view. <see cref="P:DotNetty.Common.Internal.Deque`1.IsFull"/> must be false when this method is called.</summary>
            <param name="value">The element to insert.</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.DoAddToFront(`0)">
            <summary>Inserts a single element to the front of the view. <see cref="P:DotNetty.Common.Internal.Deque`1.IsFull"/> must be false when this method is called.</summary>
            <param name="value">The element to insert.</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.DoRemoveFromBack">
            <summary>Removes and returns the last element in the view. <see cref="P:DotNetty.Common.Internal.Deque`1.IsEmpty"/> must be false when this method is called.</summary>
            <returns>The former last element.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.DoRemoveFromFront">
            <summary>Removes and returns the first element in the view. <see cref="P:DotNetty.Common.Internal.Deque`1.IsEmpty"/> must be false when this method is called.</summary>
            <returns>The former first element.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.DoInsertRange(System.Int32,System.Collections.Generic.IReadOnlyCollection{`0})">
            <summary>Inserts a range of elements into the view.</summary>
            <param name="index">The index into the view at which the elements are to be inserted.</param>
            <param name="collection">The elements to insert. The sum of <c>collection.Count</c> and <see cref="P:DotNetty.Common.Internal.Deque`1.Count"/> must be less than or equal to <see cref="P:DotNetty.Common.Internal.Deque`1.Capacity"/>.</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.DoRemoveRange(System.Int32,System.Int32)">
            <summary>Removes a range of elements from the view.</summary>
            <param name="index">The index into the view at which the range begins.</param>
            <param name="collectionCount">The number of elements in the range. This must be greater than 0 and less than or equal to <see cref="P:DotNetty.Common.Internal.Deque`1.Count"/>.</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.EnsureCapacityForOneElement">
            <summary>Doubles the capacity if necessary to make room for one more element. When this method returns, <see cref="P:DotNetty.Common.Internal.Deque`1.IsFull"/> is false.</summary>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.AddLast(`0)">
            <summary>Inserts a single element at the back of this deque.</summary>
            <param name="value">The element to insert.</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.AddFirst(`0)">
            <summary>Inserts a single element at the front of this deque.</summary>
            <param name="value">The element to insert.</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>Inserts a collection of elements into this deque.</summary>
            <param name="index">The index at which the collection is inserted.</param>
            <param name="collection">The collection of elements to insert.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is not a valid index to an insertion point for the source.</exception>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.RemoveRange(System.Int32,System.Int32)">
            <summary>Removes a range of elements from this deque.</summary>
            <param name="offset">The index into the deque at which the range begins.</param>
            <param name="count">The number of elements to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Either <paramref name="offset"/> or <paramref name="count"/> is less than 0.</exception>
            <exception cref="T:System.ArgumentException">The range [<paramref name="offset"/>, <paramref name="offset"/> + <paramref name="count"/>) is not within the range [0, <see cref="P:DotNetty.Common.Internal.Deque`1.Count"/>).</exception>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.RemoveLast">
            <summary>Removes and returns the last element of this deque.</summary>
            <returns>The former last element.</returns>
            <exception cref="T:System.InvalidOperationException">The deque is empty.</exception>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.TryRemoveLast(`0@)">
            <summary>Removes and returns the last element of this deque.</summary>
            <param name="result">The former last element.</param>
            <returns>true if an item could be dequeued; otherwise, false.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.TryRemoveLastIf(System.Predicate{`0},`0@)">
            <summary>Removes and returns the last element of this deque.</summary>
            <param name="match">The predicate that must return true for the item to be dequeued.  If null, all items implicitly return true.</param>
            <param name="result">The former last element.</param>
            <returns>true if an item could be dequeued; otherwise, false.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.RemoveFirst">
            <summary>Removes and returns the first element of this deque.</summary>
            <returns>The former first element.</returns>
            <exception cref="T:System.InvalidOperationException">The deque is empty.</exception>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.TryRemoveFirst(`0@)">
            <summary>Removes and returns the first element of this deque.</summary>
            <param name="result">The former first element.</param>
            <returns>true if an item could be dequeued; otherwise, false.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.TryRemoveFirstIf(System.Predicate{`0},`0@)">
            <summary>Removes and returns the first element of this deque.</summary>
            <param name="match">The predicate that must return true for the item to be dequeued.  If null, all items implicitly return true.</param>
            <param name="result">The former first element.</param>
            <returns>true if an item could be dequeued; otherwise, false.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.Clear">
            <summary>Removes all items from this deque.</summary>
        </member>
        <member name="M:DotNetty.Common.Internal.Deque`1.ToArray">
            <summary>Creates and returns a new array containing the elements in this deque.</summary>
        </member>
        <member name="M:DotNetty.Common.Internal.IPriorityQueue`1.PriorityChanged(`0)">
            <summary>
            Notify the queue that the priority for <paramref name="item"/> has changed. The queue will adjust to ensure the priority
            queue properties are maintained.
            </summary>
            <param name="item">An object which is in this queue and the priority may have changed.</param>
        </member>
        <member name="M:DotNetty.Common.Internal.IPriorityQueue`1.ClearIgnoringIndexes">
            <summary>
            Removes all of the elements from this <see cref="T:DotNetty.Common.Internal.IPriorityQueue`1"/> without calling
            <see cref="M:DotNetty.Common.Internal.IPriorityQueueNode`1.GetPriorityQueueIndex(DotNetty.Common.Internal.IPriorityQueue{`0})"/> or explicitly removing references to them to
            allow them to be garbage collected. This should only be used when it is certain that the nodes will not be
            re-inserted into this or any other <see cref="T:DotNetty.Common.Internal.IPriorityQueue`1"/> and it is known that the <see cref="T:DotNetty.Common.Internal.IPriorityQueue`1"/> itself
            will be garbage collected after this call.
            </summary>
        </member>
        <member name="T:DotNetty.Common.Internal.IPriorityQueueNode`1">
            <summary>
            Provides methods for <see cref="T:DotNetty.Common.Internal.DefaultPriorityQueue`1"/> to maintain internal state. These methods should generally not be
            used outside the scope of <see cref="T:DotNetty.Common.Internal.DefaultPriorityQueue`1"/>.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:DotNetty.Common.Internal.IPriorityQueueNode`1.GetPriorityQueueIndex(DotNetty.Common.Internal.IPriorityQueue{`0})">
            <summary>
            Get the last value set by <see cref="M:DotNetty.Common.Internal.IPriorityQueueNode`1.SetPriorityQueueIndex(DotNetty.Common.Internal.IPriorityQueue{`0},System.Int32)"/> for the value corresponding to
            <paramref name="queue"/>.
            
            Throwing exceptions from this method will result in undefined behavior.
            </summary>
            <param name="queue"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Common.Internal.IPriorityQueueNode`1.SetPriorityQueueIndex(DotNetty.Common.Internal.IPriorityQueue{`0},System.Int32)">
            <summary>
            Used by <see cref="T:DotNetty.Common.Internal.DefaultPriorityQueue`1"/> to maintain state for an element in the queue.
            
            Throwing exceptions from this method will result in undefined behavior.
            </summary>
            <param name="queue">The queue for which the index is being set.</param>
            <param name="i">The index as used by <see cref="T:DotNetty.Common.Internal.DefaultPriorityQueue`1"/>.</param>
        </member>
        <member name="T:DotNetty.Common.Internal.CopyPosition">
            <summary>
            Represents a position within a <see cref="T:DotNetty.Common.Internal.LargeArrayBuilder`1"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.CopyPosition.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a new <see cref="T:DotNetty.Common.Internal.CopyPosition"/>.
            </summary>
            <param name="row">The index of the buffer to select.</param>
            <param name="column">The index within the buffer to select.</param>
        </member>
        <member name="P:DotNetty.Common.Internal.CopyPosition.Start">
            <summary>
            Represents a position at the start of a <see cref="T:DotNetty.Common.Internal.LargeArrayBuilder`1"/>.
            </summary>
        </member>
        <member name="P:DotNetty.Common.Internal.CopyPosition.Row">
            <summary>
            The index of the buffer to select.
            </summary>
        </member>
        <member name="P:DotNetty.Common.Internal.CopyPosition.Column">
            <summary>
            The index within the buffer to select.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.CopyPosition.Normalize(System.Int32)">
            <summary>
            If this position is at the end of the current buffer, returns the position
            at the start of the next buffer. Otherwise, returns this position.
            </summary>
            <param name="endColumn">The length of the current buffer.</param>
        </member>
        <member name="P:DotNetty.Common.Internal.CopyPosition.DebuggerDisplay">
            <summary>
            Gets a string suitable for display in the debugger.
            </summary>
        </member>
        <member name="T:DotNetty.Common.Internal.LargeArrayBuilder`1">
            <summary>
            Helper type for building dynamically-sized arrays while minimizing allocations and copying.
            </summary>
            <typeparam name="T">The element type.</typeparam>
        </member>
        <member name="M:DotNetty.Common.Internal.LargeArrayBuilder`1.#ctor(System.Boolean)">
            <summary>
            Constructs a new builder.
            </summary>
            <param name="initialize">Pass <c>true</c>.</param>
        </member>
        <member name="M:DotNetty.Common.Internal.LargeArrayBuilder`1.#ctor(System.Int32)">
            <summary>
            Constructs a new builder with the specified maximum capacity.
            </summary>
            <param name="maxCapacity">The maximum capacity this builder can have.</param>
            <remarks>
            Do not add more than <paramref name="maxCapacity"/> items to this builder.
            </remarks>
        </member>
        <member name="P:DotNetty.Common.Internal.LargeArrayBuilder`1.Count">
            <summary>
            Gets the number of items added to the builder.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.LargeArrayBuilder`1.Add(`0)">
            <summary>
            Adds an item to this builder.
            </summary>
            <param name="item">The item to add.</param>
            <remarks>
            Use <see cref="M:DotNetty.Common.Internal.LargeArrayBuilder`1.Add(`0)"/> if adding to the builder is a bottleneck for your use case.
            Otherwise, use <see cref="M:DotNetty.Common.Internal.LargeArrayBuilder`1.SlowAdd(`0)"/>.
            </remarks>
        </member>
        <member name="M:DotNetty.Common.Internal.LargeArrayBuilder`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds a range of items to this builder.
            </summary>
            <param name="items">The sequence to add.</param>
            <remarks>
            It is the caller's responsibility to ensure that adding <paramref name="items"/>
            does not cause the builder to exceed its maximum capacity.
            </remarks>
        </member>
        <member name="M:DotNetty.Common.Internal.LargeArrayBuilder`1.CopyTo(`0[],System.Int32,System.Int32)">
            <summary>
            Copies the contents of this builder to the specified array.
            </summary>
            <param name="array">The destination array.</param>
            <param name="arrayIndex">The index in <paramref name="array"/> to start copying to.</param>
            <param name="count">The number of items to copy.</param>
        </member>
        <member name="M:DotNetty.Common.Internal.LargeArrayBuilder`1.CopyTo(DotNetty.Common.Internal.CopyPosition,`0[],System.Int32,System.Int32)">
            <summary>
            Copies the contents of this builder to the specified array.
            </summary>
            <param name="position">The position in this builder to start copying from.</param>
            <param name="array">The destination array.</param>
            <param name="arrayIndex">The index in <paramref name="array"/> to start copying to.</param>
            <param name="count">The number of items to copy.</param>
            <returns>The position in this builder that was copied up to.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.LargeArrayBuilder`1.GetBuffer(System.Int32)">
            <summary>
            Retrieves the buffer at the specified index.
            </summary>
            <param name="index">The index of the buffer.</param>
        </member>
        <member name="M:DotNetty.Common.Internal.LargeArrayBuilder`1.SlowAdd(`0)">
            <summary>
            Adds an item to this builder.
            </summary>
            <param name="item">The item to add.</param>
            <remarks>
            Use <see cref="M:DotNetty.Common.Internal.LargeArrayBuilder`1.Add(`0)"/> if adding to the builder is a bottleneck for your use case.
            Otherwise, use <see cref="M:DotNetty.Common.Internal.LargeArrayBuilder`1.SlowAdd(`0)"/>.
            </remarks>
        </member>
        <member name="M:DotNetty.Common.Internal.LargeArrayBuilder`1.ToArray">
            <summary>
            Creates an array from the contents of this builder.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.LargeArrayBuilder`1.TryMove(`0[]@)">
            <summary>
            Attempts to transfer this builder into an array without copying.
            </summary>
            <param name="array">The transferred array, if the operation succeeded.</param>
            <returns><c>true</c> if the operation succeeded; otherwise, <c>false</c>.</returns>
        </member>
        <member name="T:DotNetty.Common.Internal.Logging.AbstractInternalLogger">
            <summary>
            A skeletal implementation of <see cref="T:DotNetty.Common.Internal.Logging.IInternalLogger"/>. This class implements
            all methods that have a <see cref="T:DotNetty.Common.Internal.Logging.InternalLogLevel"/> parameter by default to call
            specific logger methods such as <see cref="M:DotNetty.Common.Internal.Logging.AbstractInternalLogger.Info(System.String)"/> or <see cref="P:DotNetty.Common.Internal.Logging.AbstractInternalLogger.InfoEnabled"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.AbstractInternalLogger.#ctor(System.String)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="name">A friendly name for the new logger instance.</param>
        </member>
        <member name="T:DotNetty.Common.Internal.Logging.FormattingTuple">
            <summary>
            Holds the results of formatting done by <see cref="T:DotNetty.Common.Internal.Logging.MessageFormatter"/>.
            </summary>
        </member>
        <member name="T:DotNetty.Common.Internal.Logging.IInternalLogger">
            <summary>
                <em>Internal-use-only</em> logger used by DotNetty. <strong>DO NOT</strong>
                access this class outside of DotNetty.
            </summary>
        </member>
        <member name="P:DotNetty.Common.Internal.Logging.IInternalLogger.Name">
            <summary>
                Return the name of this <see cref="T:DotNetty.Common.Internal.Logging.IInternalLogger" /> instance.
            </summary>
            <value>name of this logger instance</value>
        </member>
        <member name="P:DotNetty.Common.Internal.Logging.IInternalLogger.TraceEnabled">
            <summary>
                Is this logger instance enabled for the TRACE level?
            </summary>
            <value>true if this Logger is enabled for level TRACE, false otherwise.</value>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Trace(System.String)">
            <summary>
                Log a message object at level TRACE.
            </summary>
            <param name="msg">the message object to be logged</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Trace(System.String,System.Object)">
            <summary>
                Log a message at level TRACE according to the specified format and
                argument.
                <para>
                    This form avoids superfluous object creation when the logger is disabled
                    for level TRACE.
                </para>
            </summary>
            <param name="format">the format string</param>
            <param name="arg">the argument</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Trace(System.String,System.Object,System.Object)">
            <summary>
                Log a message at level TRACE according to the specified format and
                arguments.
                <para>
                    This form avoids superfluous object creation when the logger is disabled
                    for level TRACE.
                </para>
            </summary>
            <param name="format">the format string</param>
            <param name="argA">the first argument</param>
            <param name="argB">the second argument</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Trace(System.String,System.Object[])">
            <summary>
                Log a message at level TRACE according to the specified format and
                arguments.
                <para>
                    This form avoids superfluous object creation when the logger is disabled
                    for level TRACE. However, this variant incurs the hidden
                    (and relatively small) cost of creating an <c>object[]</c>
                    before invoking the method,
                    even if this logger is disabled for TRACE. The variants
                    <see cref="M:DotNetty.Common.Internal.Logging.IInternalLogger.Trace(System.String,System.Object)" /> and <see cref="M:DotNetty.Common.Internal.Logging.IInternalLogger.Trace(System.String,System.Object,System.Object)" />
                    arguments exist solely to avoid this hidden cost.
                </para>
            </summary>
            <param name="format">the format string</param>
            <param name="arguments">an array of arguments</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Trace(System.String,System.Exception)">
            <summary>
                Log an exception at level TRACE with an accompanying message.
            </summary>
            <param name="msg">the message accompanying the exception</param>
            <param name="t">the exception to log</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Trace(System.Exception)">
            <summary>
                Log an exception at level TRACE.
            </summary>
            <param name="t">the exception to log</param>
        </member>
        <member name="P:DotNetty.Common.Internal.Logging.IInternalLogger.DebugEnabled">
            <summary>
                Is this logger instance enabled for the DEBUG level?
            </summary>
            <value>true if this Logger is enabled for level DEBUG, false otherwise.</value>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Debug(System.String)">
            <summary>
                Log a message object at level DEBUG.
            </summary>
            <param name="msg">the message object to be logged</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Debug(System.String,System.Object)">
            <summary>
                Log a message at level DEBUG according to the specified format and
                argument.
                <para>
                    This form avoids superfluous object creation when the logger is disabled
                    for level DEBUG.
                </para>
            </summary>
            <param name="format">the format string</param>
            <param name="arg">the argument</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Debug(System.String,System.Object,System.Object)">
            <summary>
                Log a message at level DEBUG according to the specified format and
                arguments.
                <para>
                    This form avoids superfluous object creation when the logger is disabled
                    for level DEBUG.
                </para>
            </summary>
            <param name="format">the format string</param>
            <param name="argA">the first argument</param>
            <param name="argB">the second argument</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Debug(System.String,System.Object[])">
            <summary>
                Log a message at level DEBUG according to the specified format and
                arguments.
                <para>
                    This form avoids superfluous object creation when the logger is disabled
                    for level DEBUG. However, this variant incurs the hidden
                    (and relatively small) cost of creating an <c>object[]</c>
                    before invoking the method,
                    even if this logger is disabled for DEBUG. The variants
                    <see cref="M:DotNetty.Common.Internal.Logging.IInternalLogger.Debug(System.String,System.Object)" /> and <see cref="M:DotNetty.Common.Internal.Logging.IInternalLogger.Debug(System.String,System.Object,System.Object)" />
                    arguments exist solely to avoid this hidden cost.
                </para>
            </summary>
            <param name="format">the format string</param>
            <param name="arguments">an array of arguments</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Debug(System.String,System.Exception)">
            <summary>
                Log an exception at level DEBUG with an accompanying message.
            </summary>
            <param name="msg">the message accompanying the exception</param>
            <param name="t">the exception to log</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Debug(System.Exception)">
            <summary>
                Log an exception at level DEBUG.
            </summary>
            <param name="t">the exception to log</param>
        </member>
        <member name="P:DotNetty.Common.Internal.Logging.IInternalLogger.InfoEnabled">
            <summary>
                Is this logger instance enabled for the INFO level?
            </summary>
            <value>true if this Logger is enabled for level INFO, false otherwise.</value>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Info(System.String)">
            <summary>
                Log a message object at level INFO.
            </summary>
            <param name="msg">the message object to be logged</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Info(System.String,System.Object)">
            <summary>
                Log a message at level INFO according to the specified format and
                argument.
                <para>
                    This form avoids superfluous object creation when the logger is disabled
                    for level INFO.
                </para>
            </summary>
            <param name="format">the format string</param>
            <param name="arg">the argument</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Info(System.String,System.Object,System.Object)">
            <summary>
                Log a message at level INFO according to the specified format and
                arguments.
                <para>
                    This form avoids superfluous object creation when the logger is disabled
                    for level INFO.
                </para>
            </summary>
            <param name="format">the format string</param>
            <param name="argA">the first argument</param>
            <param name="argB">the second argument</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Info(System.String,System.Object[])">
            <summary>
                Log a message at level INFO according to the specified format and
                arguments.
                <para>
                    This form avoids superfluous object creation when the logger is disabled
                    for level INFO. However, this variant incurs the hidden
                    (and relatively small) cost of creating an <c>object[]</c>
                    before invoking the method,
                    even if this logger is disabled for INFO. The variants
                    <see cref="M:DotNetty.Common.Internal.Logging.IInternalLogger.Info(System.String,System.Object)" /> and <see cref="M:DotNetty.Common.Internal.Logging.IInternalLogger.Info(System.String,System.Object,System.Object)" />
                    arguments exist solely to avoid this hidden cost.
                </para>
            </summary>
            <param name="format">the format string</param>
            <param name="arguments">an array of arguments</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Info(System.String,System.Exception)">
            <summary>
                Log an exception at level INFO with an accompanying message.
            </summary>
            <param name="msg">the message accompanying the exception</param>
            <param name="t">the exception to log</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Info(System.Exception)">
            <summary>
                Log an exception at level INFO.
            </summary>
            <param name="t">the exception to log</param>
        </member>
        <member name="P:DotNetty.Common.Internal.Logging.IInternalLogger.WarnEnabled">
            <summary>
                Is this logger instance enabled for the WARN level?
            </summary>
            <value>true if this Logger is enabled for level WARN, false otherwise.</value>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Warn(System.String)">
            <summary>
                Log a message object at level WARN.
            </summary>
            <param name="msg">the message object to be logged</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Warn(System.String,System.Object)">
            <summary>
                Log a message at level WARN according to the specified format and
                argument.
                <para>
                    This form avoids superfluous object creation when the logger is disabled
                    for level WARN.
                </para>
            </summary>
            <param name="format">the format string</param>
            <param name="arg">the argument</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Warn(System.String,System.Object[])">
            <summary>
                Log a message at level WARN according to the specified format and
                arguments.
                <para>
                    This form avoids superfluous object creation when the logger is disabled
                    for level WARN. However, this variant incurs the hidden
                    (and relatively small) cost of creating an <c>object[]</c>
                    before invoking the method,
                    even if this logger is disabled for WARN. The variants
                    <see cref="M:DotNetty.Common.Internal.Logging.IInternalLogger.Warn(System.String,System.Object)" /> and <see cref="M:DotNetty.Common.Internal.Logging.IInternalLogger.Warn(System.String,System.Object,System.Object)" />
                    arguments exist solely to avoid this hidden cost.
                </para>
            </summary>
            <param name="format">the format string</param>
            <param name="arguments">an array of arguments</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Warn(System.String,System.Object,System.Object)">
            <summary>
                Log a message at level WARN according to the specified format and
                arguments.
                <para>
                    This form avoids superfluous object creation when the logger is disabled
                    for level WARN.
                </para>
            </summary>
            <param name="format">the format string</param>
            <param name="argA">the first argument</param>
            <param name="argB">the second argument</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Warn(System.String,System.Exception)">
            <summary>
                Log an exception at level WARN with an accompanying message.
            </summary>
            <param name="msg">the message accompanying the exception</param>
            <param name="t">the exception to log</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Warn(System.Exception)">
            <summary>
                Log an exception at level WARN.
            </summary>
            <param name="t">the exception to log</param>
        </member>
        <member name="P:DotNetty.Common.Internal.Logging.IInternalLogger.ErrorEnabled">
            <summary>
                Is this logger instance enabled for the ERROR level?
            </summary>
            <value>true if this Logger is enabled for level ERROR, false otherwise.</value>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Error(System.String)">
            <summary>
                Log a message object at level ERROR.
            </summary>
            <param name="msg">the message object to be logged</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Error(System.String,System.Object)">
            <summary>
                Log a message at level ERROR according to the specified format and
                argument.
                <para>
                    This form avoids superfluous object creation when the logger is disabled
                    for level ERROR.
                </para>
            </summary>
            <param name="format">the format string</param>
            <param name="arg">the argument</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Error(System.String,System.Object,System.Object)">
            <summary>
                Log a message at level ERROR according to the specified format and
                arguments.
                <para>
                    This form avoids superfluous object creation when the logger is disabled
                    for level ERROR.
                </para>
            </summary>
            <param name="format">the format string</param>
            <param name="argA">the first argument</param>
            <param name="argB">the second argument</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Error(System.String,System.Object[])">
            <summary>
                Log a message at level ERROR according to the specified format and
                arguments.
                <para>
                    This form avoids superfluous object creation when the logger is disabled
                    for level ERROR. However, this variant incurs the hidden
                    (and relatively small) cost of creating an <c>object[]</c>
                    before invoking the method,
                    even if this logger is disabled for ERROR. The variants
                    <see cref="M:DotNetty.Common.Internal.Logging.IInternalLogger.Error(System.String,System.Object)" /> and <see cref="M:DotNetty.Common.Internal.Logging.IInternalLogger.Error(System.String,System.Object,System.Object)" />
                    arguments exist solely to avoid this hidden cost.
                </para>
            </summary>
            <param name="format">the format string</param>
            <param name="arguments">an array of arguments</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Error(System.String,System.Exception)">
            <summary>
                Log an exception at level ERROR with an accompanying message.
            </summary>
            <param name="msg">the message accompanying the exception</param>
            <param name="t">the exception to log</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Error(System.Exception)">
            <summary>
                Log an exception at level ERROR.
            </summary>
            <param name="t">the exception to log</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.IsEnabled(DotNetty.Common.Internal.Logging.InternalLogLevel)">
            <summary>
                Is the logger instance enabled for the specified <paramref name="level"/>?
            </summary>
            <param name="level">log level</param>
            <returns>true if this Logger is enabled for the specified <paramref name="level"/>, false otherwise.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Log(DotNetty.Common.Internal.Logging.InternalLogLevel,System.String)">
            <summary>
                Log a message object at a specified <see cref="T:DotNetty.Common.Internal.Logging.InternalLogLevel" />.
            </summary>
            <param name="level">log level</param>
            <param name="msg">the message object to be logged</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Log(DotNetty.Common.Internal.Logging.InternalLogLevel,System.String,System.Object)">
            <summary>
                Log a message at a specified <see cref="T:DotNetty.Common.Internal.Logging.InternalLogLevel" /> according to the specified format and
                argument.
                <para>
                    This form avoids superfluous object creation when the logger is disabled
                    for the specified <see cref="T:DotNetty.Common.Internal.Logging.InternalLogLevel" />.
                </para>
            </summary>
            <param name="level">log level</param>
            <param name="format">the format string</param>
            <param name="arg">the argument</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Log(DotNetty.Common.Internal.Logging.InternalLogLevel,System.String,System.Object,System.Object)">
            <summary>
                Log a message at a specified <see cref="T:DotNetty.Common.Internal.Logging.InternalLogLevel" /> according to the specified format and
                arguments.
                <para>
                    This form avoids superfluous object creation when the logger is disabled
                    for the specified <see cref="T:DotNetty.Common.Internal.Logging.InternalLogLevel" />.
                </para>
            </summary>
            <param name="level">log level</param>
            <param name="format">the format string</param>
            <param name="argA">the first argument</param>
            <param name="argB">the second argument</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Log(DotNetty.Common.Internal.Logging.InternalLogLevel,System.String,System.Object[])">
            <summary>
                Log a message at the specified <paramref name="level"/> according to the specified format
                and arguments.
                <para>
                    This form avoids superfluous string concatenation when the logger
                    is disabled for the specified <paramref name="level"/>. However, this variant incurs the hidden
                    (and relatively small) cost of creating an <c>object[]</c> before invoking the method,
                    even if this logger is disabled for the specified <paramref name="level"/>. The variants
                    <see cref="M:DotNetty.Common.Internal.Logging.IInternalLogger.Log(DotNetty.Common.Internal.Logging.InternalLogLevel,System.String,System.Object)" /> and
                    <see cref="M:DotNetty.Common.Internal.Logging.IInternalLogger.Log(DotNetty.Common.Internal.Logging.InternalLogLevel,System.String,System.Object,System.Object)" /> arguments exist solely
                    in order to avoid this hidden cost.
                </para>
            </summary>
            <param name="level">log level</param>
            <param name="format">the format string</param>
            <param name="arguments">an array of arguments</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Log(DotNetty.Common.Internal.Logging.InternalLogLevel,System.String,System.Exception)">
            <summary>
                Log an exception at the specified <see cref="T:DotNetty.Common.Internal.Logging.InternalLogLevel" /> with an
                accompanying message.
            </summary>
            <param name="level">log level</param>
            <param name="msg">the message accompanying the exception</param>
            <param name="t">the exception to log</param>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.IInternalLogger.Log(DotNetty.Common.Internal.Logging.InternalLogLevel,System.Exception)">
            <summary>
                Log an exception at the specified <see cref="T:DotNetty.Common.Internal.Logging.InternalLogLevel" />.
            </summary>
            <param name="level">log level</param>
            <param name="t">the exception to log</param>
        </member>
        <member name="T:DotNetty.Common.Internal.Logging.InternalLoggerFactory">
            <summary>
                Creates an <see cref="T:DotNetty.Common.Internal.Logging.IInternalLogger" /> or changes the default factory
                implementation. This factory allows you to choose what logging framework
                DotNetty should use.  The default factory is own <see cref="T:Microsoft.Extensions.Logging.LoggerFactory"/> with <see cref="T:DotNetty.Common.Internal.Logging.EventSourceLoggerProvider" /> registered.
                You can change it to your preferred logging framework before other DotNetty classes are loaded:
                <pre>
                    <code>InternalLoggerFactory.DefaultFactory = new LoggerFactory();</code>
                </pre>
                Please note that the new default factory is effective only for the classes
                which were loaded after the default factory is changed.  Therefore, <see cref="P:DotNetty.Common.Internal.Logging.InternalLoggerFactory.DefaultFactory"/> should be set as early
                as possible and should not be called more than once.
            </summary>
        </member>
        <member name="P:DotNetty.Common.Internal.Logging.InternalLoggerFactory.DefaultFactory">
            <summary>
                Gets or sets the default factory.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.InternalLoggerFactory.GetInstance``1">
            <summary>
                Creates a new logger instance with the name of the specified type.
            </summary>
            <typeparam name="T">type where logger is used</typeparam>
            <returns>logger instance</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.InternalLoggerFactory.GetInstance(System.Type)">
            <summary>
                Creates a new logger instance with the name of the specified type.
            </summary>
            <param name="type">type where logger is used</param>
            <returns>logger instance</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.InternalLoggerFactory.GetInstance(System.String)">
            <summary>
                Creates a new logger instance with the specified name.
            </summary>
            <param name="name">logger name</param>
            <returns>logger instance</returns>
        </member>
        <member name="T:DotNetty.Common.Internal.Logging.InternalLogLevel">
            <summary>
            The log level that <see cref="T:DotNetty.Common.Internal.Logging.IInternalLogger"/> can log at.
            </summary>
        </member>
        <member name="F:DotNetty.Common.Internal.Logging.InternalLogLevel.TRACE">
            <summary>
                'TRACE' log level.
            </summary>
        </member>
        <member name="F:DotNetty.Common.Internal.Logging.InternalLogLevel.DEBUG">
            <summary>
                'DEBUG' log level.
            </summary>
        </member>
        <member name="F:DotNetty.Common.Internal.Logging.InternalLogLevel.INFO">
            <summary>
                'INFO' log level.
            </summary>
        </member>
        <member name="F:DotNetty.Common.Internal.Logging.InternalLogLevel.WARN">
            <summary>
                'WARN' log level.
            </summary>
        </member>
        <member name="F:DotNetty.Common.Internal.Logging.InternalLogLevel.ERROR">
            <summary>
                'ERROR' log level.
            </summary>
        </member>
        <member name="T:DotNetty.Common.Internal.Logging.MessageFormatter">
            <summary>
            Formats messages according to very simple substitution rules. Substitutions can be made 1, 2 or more arguments.
            <para>For example,</para>
            <code>
            MessageFormatter.Format(&quot;Hi {}.&quot;, &quot;there&quot;)
            </code>
            <para>
            will return the string "Hi there.".
            </para>
            <para>
            The {} pair is called the <em>formatting anchor</em>. It serves to designate the location where arguments need
            to be substituted within the message pattern.
            </para>
            <para>
            In case your message contains the '{' or the '}' character, you do not have to do anything special unless the
            '}' character immediately follows '{'. For example,
            </para>
            <code>
            MessageFormatter.Format(&quot;Set {1,2,3} is not equal to {}.&quot;, &quot;1,2&quot;);
            </code>
            <para>
            will return the string "Set {1,2,3} is not equal to 1,2.".
            </para>
            <para>
            If for whatever reason you need to place the string "{}" in the message without its <em>formatting anchor</em>
            meaning, then you need to escape the '{' character with '\', that is the backslash character. Only the '{'
            character should be escaped. There is no need to escape the '}' character. For example,
            </para>
            <code>
            MessageFormatter.Format(&quot;Set \\{} is not equal to {}.&quot;, &quot;1,2&quot;);
            </code>
            <para>
            will return the string "Set {} is not equal to 1,2.".
            </para>
            <para>
            The escaping behavior just described can be overridden by escaping the escape character '\'. Calling
            </para>
            <code>
            MessageFormatter.Format(&quot;File name is C:\\\\{}.&quot;, &quot;file.zip&quot;);
            </code>
            <para>
            will return the string "File name is C:\file.zip".
            </para>
            <seealso cref="M:DotNetty.Common.Internal.Logging.MessageFormatter.Format(System.String,System.Object)" />
            <seealso cref="M:DotNetty.Common.Internal.Logging.MessageFormatter.Format(System.String,System.Object,System.Object)" />
            <seealso cref="M:DotNetty.Common.Internal.Logging.MessageFormatter.ArrayFormat(System.String,System.Object[])" />
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.MessageFormatter.Format(System.String,System.Object)">
            <summary>
            Performs single argument substitution for the given <paramref name="messagePattern"/>.
            <para>
            For example,
            </para>
            <code>
            MessageFormatter.Format(&quot;Hi {}.&quot;, &quot;there&quot;);
            </code>
            <para>
            will return the string "Hi there.".
            </para>
            </summary>
            <param name="messagePattern">The message pattern which will be parsed and formatted</param>
            <param name="arg">The argument to be substituted in place of the formatting anchor</param>
            <returns>The formatted message</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.MessageFormatter.Format(System.String,System.Object,System.Object)">
            <summary>
            Performs a two argument substitution for the given <paramref name="messagePattern"/>.
            <para>
            For example,
            </para>
            <code>
            MessageFormatter.Format(&quot;Hi {}. My name is {}.&quot;, &quot;Alice&quot;, &quot;Bob&quot;);
            </code>
            <para>
            will return the string "Hi Alice. My name is Bob.".
            </para>
            </summary>
            <param name="messagePattern">The message pattern which will be parsed and formatted</param>
            <param name="argA">The argument to be substituted in place of the first formatting anchor</param>
            <param name="argB">The argument to be substituted in place of the second formatting anchor</param>
            <returns>The formatted message</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.Logging.MessageFormatter.ArrayFormat(System.String,System.Object[])">
            <summary>
            Same principle as the <see cref="M:DotNetty.Common.Internal.Logging.MessageFormatter.Format(System.String,System.Object)"/> and <see cref="M:DotNetty.Common.Internal.Logging.MessageFormatter.Format(System.String,System.Object,System.Object)"/>
            methods, except that any number of arguments can be passed in an array.
            </summary>
            <param name="messagePattern">The message pattern which will be parsed and formatted</param>
            <param name="argArray">An array of arguments to be substituted in place of formatting anchors</param>
            <returns>The formatted message</returns>
        </member>
        <member name="F:DotNetty.Common.Internal.MacAddressUtil.MacAddressLength">
            Length of a valid MAC address.
        </member>
        <member name="M:DotNetty.Common.Internal.MacAddressUtil.GetBestAvailableMac">
            Obtains the best MAC address found on local network interfaces.
            Generally speaking, an active network interface used on public
            networks is better than a local network interface.
            <returns>byte array containing a MAC. null if no MAC can be found.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.MacAddressUtil.FormatAddress(System.Byte[])">
            <param name="addr">byte array of a MAC address.</param>
            <returns>hex formatted MAC address.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.MacAddressUtil.CompareAddresses(System.Byte[],System.Byte[])">
            <returns>positive - current is better, 0 - cannot tell from MAC addr, negative - candidate is better.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.MacAddressUtil.CompareAddresses(System.Net.IPAddress,System.Net.IPAddress)">
            <returns>positive - current is better, 0 - cannot tell, negative - candidate is better</returns>
        </member>
        <member name="T:DotNetty.Common.Internal.MpscArrayQueue`1">
            <summary>
            Forked from <a href="https://github.com/JCTools/JCTools">JCTools</a>.
            A Multi-Producer-Single-Consumer queue based on a <see cref="T:DotNetty.Common.Internal.ConcurrentCircularArrayQueue`1"/>. This implies
            that any thread may call the Enqueue methods, but only a single thread may call poll/peek for correctness to
            maintained.
            <para>
            This implementation follows patterns documented on the package level for False Sharing protection.
            </para>
            <para>
            This implementation is using the <a href="http://sourceforge.net/projects/mc-fastflow/">Fast Flow</a>
            method for polling from the queue (with minor change to correctly publish the index) and an extension of
            the Leslie Lamport concurrent queue algorithm (originated by Martin Thompson) on the producer side.
            </para>
            </summary>
            <typeparam name="T">The type of each item in the queue.</typeparam>
        </member>
        <member name="M:DotNetty.Common.Internal.MpscArrayQueue`1.TryEnqueue(`0)">
            <summary>
            Lock free Enqueue operation, using a single compare-and-swap. As the class name suggests, access is
            permitted to many threads concurrently.
            </summary>
            <param name="e">The item to enqueue.</param>
            <returns><c>true</c> if the item was added successfully, otherwise <c>false</c>.</returns>
            <seealso cref="M:DotNetty.Common.Internal.IQueue`1.TryEnqueue(`0)"/>
        </member>
        <member name="M:DotNetty.Common.Internal.MpscArrayQueue`1.WeakEnqueue(`0)">
            <summary>
            A wait-free alternative to <see cref="M:DotNetty.Common.Internal.MpscArrayQueue`1.TryEnqueue(`0)"/>, which fails on compare-and-swap failure.
            </summary>
            <param name="e">The item to enqueue.</param>
            <returns><c>1</c> if next element cannot be filled, <c>-1</c> if CAS failed, and <c>0</c> if successful.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.MpscArrayQueue`1.TryDequeue(`0@)">
            <summary>
            Lock free poll using ordered loads/stores. As class name suggests, access is limited to a single thread.
            </summary>
            <param name="item">The dequeued item.</param>
            <returns><c>true</c> if an item was retrieved, otherwise <c>false</c>.</returns>
            <seealso cref="M:DotNetty.Common.Internal.IQueue`1.TryDequeue(`0@)"/>
        </member>
        <member name="M:DotNetty.Common.Internal.MpscArrayQueue`1.TryPeek(`0@)">
            <summary>
            Lock free peek using ordered loads. As class name suggests access is limited to a single thread.
            </summary>
            <param name="item">The peeked item.</param>
            <returns><c>true</c> if an item was retrieved, otherwise <c>false</c>.</returns>
            <seealso cref="M:DotNetty.Common.Internal.IQueue`1.TryPeek(`0@)"/>
        </member>
        <member name="P:DotNetty.Common.Internal.MpscArrayQueue`1.Count">
            <summary>
            Returns the number of items in this <see cref="T:DotNetty.Common.Internal.MpscArrayQueue`1"/>.
            </summary>
        </member>
        <member name="T:DotNetty.Common.Internal.PlatformHelper">
            <summary>A helper class to get the number of processors, it updates the numbers of processors every sampling interval.</summary>
        </member>
        <member name="P:DotNetty.Common.Internal.PlatformHelper.ProcessorCount">
            <summary>Gets the number of available processors</summary>
        </member>
        <member name="P:DotNetty.Common.Internal.PlatformHelper.IsSingleProcessor">
            <summary>Gets whether the current machine has only a single processor.</summary>
        </member>
        <member name="M:DotNetty.Common.Internal.ObjectPool`1.Get">
            <summary></summary>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Common.Internal.ObjectPool`1.Take">
            <summary></summary>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Common.Internal.ObjectPool`1.Return(`0)">
            <summary></summary>
            <param name="obj"></param>
        </member>
        <member name="M:DotNetty.Common.Internal.ObjectPool`1.Clear">
            <summary></summary>
        </member>
        <member name="T:DotNetty.Common.Internal.PromiseNotificationUtil">
            <summary>
            Internal utilities to notify <see cref="T:DotNetty.Common.Concurrency.IPromise"/>s.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.PromiseNotificationUtil.TryCancel(DotNetty.Common.Concurrency.IPromise,DotNetty.Common.Internal.Logging.IInternalLogger)">
            <summary>
            Try to cancel the <see cref="T:DotNetty.Common.Concurrency.IPromise"/> and log if <paramref name="logger"/> is not <c>null</c> in case this fails.
            </summary>
            <param name="p"></param>
            <param name="logger"></param>
        </member>
        <member name="M:DotNetty.Common.Internal.PromiseNotificationUtil.TrySuccess(DotNetty.Common.Concurrency.IPromise,DotNetty.Common.Internal.Logging.IInternalLogger)">
            <summary>
            Try to mark the <see cref="T:DotNetty.Common.Concurrency.IPromise"/> as success and log if <paramref name="logger"/> is not <c>null</c> in case this fails.
            </summary>
            <param name="p"></param>
            <param name="logger"></param>
        </member>
        <member name="M:DotNetty.Common.Internal.PromiseNotificationUtil.TryFailure(DotNetty.Common.Concurrency.IPromise,System.Exception,DotNetty.Common.Internal.Logging.IInternalLogger)">
            <summary>
            Try to mark the <see cref="T:DotNetty.Common.Concurrency.IPromise"/> as failure and log if <paramref name="logger"/> is not <c>null</c> in case this fails.
            </summary>
            <param name="p"></param>
            <param name="cause"></param>
            <param name="logger"></param>
        </member>
        <member name="M:DotNetty.Common.Internal.RefArrayAccessUtil.SpElement``1(``0[],System.Int64,``0)">
            <summary>
            A plain store (no ordering/fences) of an element to a given offset.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="buffer">The source buffer.</param>
            <param name="offset">Computed via <see cref="M:DotNetty.Common.Internal.ConcurrentCircularArrayQueue`1.CalcElementOffset(System.Int64)"/></param>
            <param name="e">An orderly kitty.</param>
        </member>
        <member name="M:DotNetty.Common.Internal.RefArrayAccessUtil.SoElement``1(``0[],System.Int64,``0)">
            <summary>
            An ordered store(store + StoreStore barrier) of an element to a given offset.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="buffer">The source buffer.</param>
            <param name="offset">Computed via <see cref="M:DotNetty.Common.Internal.ConcurrentCircularArrayQueue`1.CalcElementOffset(System.Int64)"/></param>
            <param name="e"></param>
        </member>
        <member name="M:DotNetty.Common.Internal.RefArrayAccessUtil.LpElement``1(``0[],System.Int64)">
            <summary>
            A plain load (no ordering/fences) of an element from a given offset.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="buffer">The source buffer.</param>
            <param name="offset">Computed via <see cref="M:DotNetty.Common.Internal.ConcurrentCircularArrayQueue`1.CalcElementOffset(System.Int64)"/></param>
            <returns>The element at the given <paramref name="offset"/> in the given <paramref name="buffer"/>.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.RefArrayAccessUtil.LvElement``1(``0[],System.Int64)">
            <summary>
            A volatile load (load + LoadLoad barrier) of an element from a given offset.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="buffer">The source buffer.</param>
            <param name="offset">Computed via <see cref="M:DotNetty.Common.Internal.ConcurrentCircularArrayQueue`1.CalcElementOffset(System.Int64)"/></param>
            <returns>The element at the given <paramref name="offset"/> in the given <paramref name="buffer"/>.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.RefArrayAccessUtil.CalcElementOffset(System.Int64,System.Int64)">
            <summary>
            Gets the offset in bytes within the array for a given index.
            </summary>
            <param name="index">The desired element index.</param>
            <param name="mask">Mask for the index.</param>
            <returns>The offset (in bytes) within the array for a given index.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.BaseLinkedQueuePad0`1.Offer(`0)">
            <summary>
            Called from a producer thread subject to the restrictions appropriate to the implementation and
            according to the <see cref="M:DotNetty.Common.Internal.ILinkedQueue`1.Offer(`0)"/> interface.
            </summary>
            <param name="e">The element to enqueue.</param>
            <returns><c>true</c> if the element was inserted, <c>false</c> iff the queue is full.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.BaseLinkedQueuePad0`1.Poll">
            <summary>
            Called from the consumer thread subject to the restrictions appropriate to the implementation and
            according to the <see cref="M:DotNetty.Common.Internal.ILinkedQueue`1.Poll"/> interface.
            </summary>
            <returns>A message from the queue if one is available, <c>null</c> iff the queue is empty.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.BaseLinkedQueuePad0`1.Peek">
            <summary>
            Called from the consumer thread subject to the restrictions appropriate to the implementation and
            according to the <see cref="M:DotNetty.Common.Internal.ILinkedQueue`1.Peek"/> interface.
            </summary>
            <returns>A message from the queue if one is available, <c>null</c> iff the queue is empty.</returns>
        </member>
        <member name="T:DotNetty.Common.Internal.StringBuilderCache">
            <summary>StringBuilderCache</summary>
        </member>
        <member name="T:DotNetty.Common.Internal.Strings">
            <summary>
              一个强类型的资源类，用于查找本地化的字符串等。
            </summary>
        </member>
        <member name="P:DotNetty.Common.Internal.Strings.ResourceManager">
            <summary>
              返回此类使用的缓存的 ResourceManager 实例。
            </summary>
        </member>
        <member name="P:DotNetty.Common.Internal.Strings.Culture">
            <summary>
              重写当前线程的 CurrentUICulture 属性
              重写当前线程的 CurrentUICulture 属性。
            </summary>
        </member>
        <member name="P:DotNetty.Common.Internal.Strings.ArgumentOutOfRange_Count">
            <summary>
              查找类似 Count must be positive and count must refer to a location within the collection. 的本地化字符串。
            </summary>
        </member>
        <member name="P:DotNetty.Common.Internal.Strings.ArgumentOutOfRange_Index">
            <summary>
              查找类似 Index was out of range. Must be non-negative and less than the size of the collection. 的本地化字符串。
            </summary>
        </member>
        <member name="P:DotNetty.Common.Internal.Strings.ArgumentOutOfRange_NeedNonNegNum">
            <summary>
              查找类似 Non-negative number required. 的本地化字符串。
            </summary>
        </member>
        <member name="P:DotNetty.Common.Internal.Strings.Capacity_May_Not_Be_Negative">
            <summary>
              查找类似 Capacity may not be negative. 的本地化字符串。
            </summary>
        </member>
        <member name="P:DotNetty.Common.Internal.Strings.Dest_Array_Cannot_Be_Null">
            <summary>
              查找类似 Destination array cannot be null. 的本地化字符串。
            </summary>
        </member>
        <member name="P:DotNetty.Common.Internal.Strings.Value_Cannot_Be_Null">
            <summary>
              查找类似 Value cannot be null. 的本地化字符串。
            </summary>
        </member>
        <member name="P:DotNetty.Common.Internal.Strings.Value_Is_Of_Incorrect_Type">
            <summary>
              查找类似 Value is of incorrect type. 的本地化字符串。
            </summary>
        </member>
        <member name="T:DotNetty.Common.Internal.SynchronizedPool`1">
             <summary>A simple synchronized pool would simply lock a stack and push/pop on return/take.</summary>
             <typeparam name="T"></typeparam>
             <remarks>
             This implementation tries to reduce locking by exploiting the case where an item
             is taken and returned by the same thread, which turns out to be common in our 
             scenarios.  
            
             Initially, all the quota is allocated to a global (non-thread-specific) pool, 
             which takes locks.  As different threads take and return values, we record their IDs, 
             and if we detect that a thread is taking and returning "enough" on the same thread, 
             then we decide to "promote" the thread.  When a thread is promoted, we decrease the 
             quota of the global pool by one, and allocate a thread-specific entry for the thread 
             to store it's value.  Once this entry is allocated, the thread can take and return 
             it's value from that entry without taking any locks.  Not only does this avoid 
             locks, but it affinitizes pooled items to a particular thread.
            
             There are a couple of additional things worth noting:
             
             It is possible for a thread that we have reserved an entry for to exit.  This means
             we will still have a entry allocated for it, but the pooled item stored there 
             will never be used.  After a while, we could end up with a number of these, and 
             as a result we would begin to exhaust the quota of the overall pool.  To mitigate this
             case, we throw away the entire per-thread pool, and return all the quota back to 
             the global pool if we are unable to promote a thread (due to lack of space).  Then 
             the set of active threads will be re-promoted as they take and return items.
             
             You may notice that the code does not immediately promote a thread, and does not
             immediately throw away the entire per-thread pool when it is unable to promote a 
             thread.  Instead, it uses counters (based on the number of calls to the pool) 
             and a threshold to figure out when to do these operations.  In the case where the
             pool to misconfigured to have too few items for the workload, this avoids constant 
             promoting and rebuilding of the per thread entries.
            
             You may also notice that we do not use interlocked methods when adjusting statistics.
             Since the statistics are a heuristic as to how often something is happening, they 
             do not need to be perfect.
             </remarks>
        </member>
        <member name="T:DotNetty.Common.Internal.SystemPropertyUtil">
            <summary>
                A collection of utility methods to retrieve and parse the values of the system properties (Environment variables).
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.SystemPropertyUtil.Contains(System.String)">
            <summary>
                Returns <c>true</c> if and only if the system property with the specified <c>key</c>
                exists.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.SystemPropertyUtil.Get(System.String)">
            <summary>
                Returns the value of the system property with the specified
                <c>key</c>, while falling back to <c>null</c> if the property access fails.
            </summary>
            <returns>the property value or <c>null</c></returns>
        </member>
        <member name="M:DotNetty.Common.Internal.SystemPropertyUtil.Get(System.String,System.String)">
            <summary>
                Returns the value of the system property with the specified
                <c>key</c>, while falling back to the specified default value if
                the property access fails.
            </summary>
            <returns>
                the property value.
                <c>def</c> if there's no such property or if an access to the
                specified property is not allowed.
            </returns>
        </member>
        <member name="M:DotNetty.Common.Internal.SystemPropertyUtil.GetBoolean(System.String,System.Boolean)">
            <summary>
                Returns the value of the system property with the specified
                <c>key</c>, while falling back to the specified default value if
                the property access fails.
            </summary>
            <returns>
                the property value or <c>def</c> if there's no such property or
                if an access to the specified property is not allowed.
            </returns>
        </member>
        <member name="M:DotNetty.Common.Internal.SystemPropertyUtil.GetInt(System.String,System.Int32)">
            <summary>
                Returns the value of the system property with the specified
                <c>key</c>, while falling back to the specified default value if
                the property access fails.
            </summary>
            <returns>
                the property value.
                <c>def</c> if there's no such property or if an access to the
                specified property is not allowed.
            </returns>
        </member>
        <member name="M:DotNetty.Common.Internal.SystemPropertyUtil.GetLong(System.String,System.Int64)">
            <summary>
                Returns the value of the system property with the specified
                <c>key</c>, while falling back to the specified default value if
                the property access fails.
            </summary>
            <returns>
                the property value.
                <c>def</c> if there's no such property or if an access to the
                specified property is not allowed.
            </returns>
        </member>
        <member name="F:DotNetty.Common.Internal.TextEncodings.UTF8NoBOM">
            <summary>不提供 Unicode 字节顺序标记，检测到无效的编码时不引发异常</summary>
        </member>
        <member name="F:DotNetty.Common.Internal.TextEncodings.SecureUTF8NoBOM">
            <summary>不提供 Unicode 字节顺序标记，检测到无效的编码时引发异常</summary>
        </member>
        <member name="F:DotNetty.Common.Internal.TextEncodings.SecureUTF8">
            <summary>提供 Unicode 字节顺序标记，检测到无效的编码时引发异常</summary>
        </member>
        <member name="M:DotNetty.Common.Internal.TextEncodings.Utf16.ToUtf8(System.Byte@,System.Int32,System.Byte@,System.Int32,System.Int32@,System.Int32@)">
             <summary>
             Converts a span containing a sequence of UTF-16 bytes into UTF-8 bytes.
            
             This method will consume as many of the input bytes as possible.
            
             On successful exit, the entire input was consumed and encoded successfully. In this case, <paramref name="bytesConsumed"/> will be
             equal to the length of the <paramref name="utf16Source"/> and <paramref name="bytesWritten"/> will equal the total number of bytes written to
             the <paramref name="utf8Destination"/>.
             </summary>
             <param name="utf16Source">A span containing a sequence of UTF-16 bytes.</param>
             <param name="utf16Length"></param>
             <param name="utf8Destination">A span to write the UTF-8 bytes into.</param>
             <param name="utf8Length"></param>
             <param name="bytesConsumed">On exit, contains the number of bytes that were consumed from the <paramref name="utf16Source"/>.</param>
             <param name="bytesWritten">On exit, contains the number of bytes written to <paramref name="utf8Destination"/></param>
             <returns>A <see cref="T:System.Buffers.OperationStatus"/> value representing the state of the conversion.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.TextEncodings.Utf16.ToUtf8Length(System.ReadOnlySpan{System.Byte}@,System.Int32@)">
             <summary>
             Calculates the byte count needed to encode the UTF-8 bytes from the specified UTF-16 sequence.
            
             This method will consume as many of the input bytes as possible.
             </summary>
             <param name="utf16Source">A span containing a sequence of UTF-16 bytes.</param>
             <param name="bytesNeeded">On exit, contains the number of bytes required for encoding from the <paramref name="utf16Source"/>.</param>
             <returns>A <see cref="T:System.Buffers.OperationStatus"/> value representing the expected state of the conversion.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.TextEncodings.Utf8.GetMaxByteCount(System.String)">
            <summary>For short strings use only.</summary>
        </member>
        <member name="M:DotNetty.Common.Internal.TextEncodings.Utf8.GetMaxByteCount(System.Int32)">
            <summary>For short strings use only.</summary>
        </member>
        <member name="M:DotNetty.Common.Internal.TextEncodings.Utf8.ToUtf16(System.ReadOnlySpan{System.Byte}@,System.Span{System.Byte},System.Int32@,System.Int32@)">
             <summary>Converts a span containing a sequence of UTF-8 bytes into UTF-16 bytes.
            
             This method will consume as many of the input bytes as possible.
            
             On successful exit, the entire input was consumed and encoded successfully. In this case, <paramref name="bytesConsumed"/> will be
             equal to the length of the <paramref name="utf8Source"/> and <paramref name="bytesWritten"/> will equal the total number of bytes written to
             the <paramref name="utf16Destination"/>.</summary>
             <param name="utf8Source">A span containing a sequence of UTF-8 bytes.</param>
             <param name="utf16Destination">A span to write the UTF-16 bytes into.</param>
             <param name="bytesConsumed">On exit, contains the number of bytes that were consumed from the <paramref name="utf8Source"/>.</param>
             <param name="bytesWritten">On exit, contains the number of bytes written to <paramref name="utf16Destination"/></param>
             <returns>A <see cref="T:System.Buffers.OperationStatus"/> value representing the state of the conversion.</returns>
        </member>
        <member name="M:DotNetty.Common.Internal.UnicodeDebug.ToHexString(System.UInt32)">
            <summary>
            Formats a code point as the hex string "U+XXXX".
            </summary>
            <remarks>
            The input value doesn't have to be a real code point in the Unicode codespace. It can be any integer.
            </remarks>
        </member>
        <member name="F:DotNetty.Common.Internal.UnicodeUtility.ReplacementChar">
            <summary>
            The Unicode replacement character U+FFFD.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.UnicodeUtility.GetPlane(System.UInt32)">
            <summary>
            Returns the Unicode plane (0 through 16, inclusive) which contains this code point.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.UnicodeUtility.GetScalarFromUtf16SurrogatePair(System.UInt32,System.UInt32)">
            <summary>
            Returns a Unicode scalar value from two code points representing a UTF-16 surrogate pair.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.UnicodeUtility.GetUtf16SequenceLength(System.UInt32)">
            <summary>
            Given a Unicode scalar value, gets the number of UTF-16 code units required to represent this value.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.UnicodeUtility.GetUtf16SurrogatesFromSupplementaryPlaneScalar(System.UInt32,System.Char@,System.Char@)">
            <summary>
            Decomposes an astral Unicode scalar into UTF-16 high and low surrogate code units.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.UnicodeUtility.GetUtf8SequenceLength(System.UInt32)">
            <summary>
            Given a Unicode scalar value, gets the number of UTF-8 code units required to represent this value.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.UnicodeUtility.IsAsciiCodePoint(System.UInt32)">
            <summary>
            Returns <see langword="true"/> iff <paramref name="value"/> is an ASCII
            character ([ U+0000..U+007F ]).
            </summary>
            <remarks>
            Per http://www.unicode.org/glossary/#ASCII, ASCII is only U+0000..U+007F.
            </remarks>
        </member>
        <member name="M:DotNetty.Common.Internal.UnicodeUtility.IsBmpCodePoint(System.UInt32)">
            <summary>
            Returns <see langword="true"/> iff <paramref name="value"/> is in the
            Basic Multilingual Plane (BMP).
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.UnicodeUtility.IsHighSurrogateCodePoint(System.UInt32)">
            <summary>
            Returns <see langword="true"/> iff <paramref name="value"/> is a UTF-16 high surrogate code point,
            i.e., is in [ U+D800..U+DBFF ], inclusive.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.UnicodeUtility.IsInRangeInclusive(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Returns <see langword="true"/> iff <paramref name="value"/> is between
            <paramref name="lowerBound"/> and <paramref name="upperBound"/>, inclusive.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.UnicodeUtility.IsInRangeInclusive(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns <see langword="true"/> if <paramref name="value"/> is between
            <paramref name="lowerBound"/> and <paramref name="upperBound"/>, inclusive.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.UnicodeUtility.IsInRangeInclusive(System.Int64,System.Int64,System.Int64)">
            <summary>
            Returns <see langword="true"/> if <paramref name="value"/> is between
            <paramref name="lowerBound"/> and <paramref name="upperBound"/>, inclusive.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.UnicodeUtility.IsLowSurrogateCodePoint(System.UInt32)">
            <summary>
            Returns <see langword="true"/> iff <paramref name="value"/> is a UTF-16 low surrogate code point,
            i.e., is in [ U+DC00..U+DFFF ], inclusive.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.UnicodeUtility.IsSurrogateCodePoint(System.UInt32)">
            <summary>
            Returns <see langword="true"/> iff <paramref name="value"/> is a UTF-16 surrogate code point,
            i.e., is in [ U+D800..U+DFFF ], inclusive.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.UnicodeUtility.IsValidCodePoint(System.UInt32)">
            <summary>
            Returns <see langword="true"/> iff <paramref name="codePoint"/> is a valid Unicode code
            point, i.e., is in [ U+0000..U+10FFFF ], inclusive.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.UnicodeUtility.IsValidUnicodeScalar(System.UInt32)">
            <summary>
            Returns <see langword="true"/> iff <paramref name="value"/> is a valid Unicode scalar
            value, i.e., is in [ U+0000..U+D7FF ], inclusive; or [ U+E000..U+10FFFF ], inclusive.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.Utf8Util.ConvertIntPtrToInt32WithoutOverflowCheck(System.IntPtr)">
            <summary>
            Casts an <see cref="T:System.IntPtr"/> to an <see cref="T:System.Int32"/> without overflow checking.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.Utf8Util.CountNumberOfLeadingAsciiBytesFrom24BitInteger(System.UInt32)">
            <summary>
            Given a 24-bit integer which represents a three-byte buffer read in machine endianness,
            counts the number of consecutive ASCII bytes starting from the beginning of the buffer.
            Returns a value 0 - 3, inclusive.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.Utf8Util.DWordAllBytesAreAscii(System.UInt32)">
            <summary>
            Returns <see langword="true"/> iff all bytes in <paramref name="value"/> are ASCII.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.Utf8Util.DWordBeginsAndEndsWithUtf8TwoByteMask(System.UInt32)">
            <summary>
            Given a UTF-8 buffer which has been read into a DWORD in machine endianness,
            returns <see langword="true"/> iff the buffer contains two UTF-8 sequences
            that match the mask [ 110yyyyy 10xxxxxx 110yyyyy 10xxxxxx ]. This method *does not*
            validate that the sequences are well-formed; the caller must still perform
            overlong form checking.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.Utf8Util.DWordBeginsWithOverlongUtf8TwoByteSequence(System.UInt32)">
            <summary>
            Given a UTF-8 buffer which has been read into a DWORD in machine endianness,
            returns <see langword="true"/> iff the first two bytes of the buffer are
            an overlong representation of a sequence that should be represented as one byte.
            This method *does not* validate that the sequence matches the appropriate
            2-byte sequence mask (see <see cref="M:DotNetty.Common.Internal.Utf8Util.DWordBeginsWithUtf8TwoByteMask(System.UInt32)"/>).
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.Utf8Util.DWordBeginsWithUtf8FourByteMask(System.UInt32)">
            <summary>
            Given a UTF-8 buffer which has been read into a DWORD in machine endianness,
            returns <see langword="true"/> iff the first four bytes of the buffer match
            the UTF-8 4-byte sequence mask [ 11110www 10zzzzzz 10yyyyyy 10xxxxxx ]. This
            method *does not* validate that the sequence is well-formed; the caller must
            still perform overlong form or out-of-range checking.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.Utf8Util.DWordBeginsWithUtf8ThreeByteMask(System.UInt32)">
            <summary>
            Given a UTF-8 buffer which has been read into a DWORD in machine endianness,
            returns <see langword="true"/> iff the first three bytes of the buffer match
            the UTF-8 3-byte sequence mask [ 1110zzzz 10yyyyyy 10xxxxxx ]. This method *does not*
            validate that the sequence is well-formed; the caller must still perform
            overlong form or surrogate checking.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.Utf8Util.DWordBeginsWithUtf8TwoByteMask(System.UInt32)">
            <summary>
            Given a UTF-8 buffer which has been read into a DWORD in machine endianness,
            returns <see langword="true"/> iff the first two bytes of the buffer match
            the UTF-8 2-byte sequence mask [ 110yyyyy 10xxxxxx ]. This method *does not*
            validate that the sequence is well-formed; the caller must still perform
            overlong form checking.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.Utf8Util.DWordEndsWithOverlongUtf8TwoByteSequence(System.UInt32)">
            <summary>
            Given a UTF-8 buffer which has been read into a DWORD in machine endianness,
            returns <see langword="true"/> iff the first two bytes of the buffer are
            an overlong representation of a sequence that should be represented as one byte.
            This method *does not* validate that the sequence matches the appropriate
            2-byte sequence mask (see <see cref="M:DotNetty.Common.Internal.Utf8Util.DWordBeginsWithUtf8TwoByteMask(System.UInt32)"/>).
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.Utf8Util.DWordEndsWithUtf8TwoByteMask(System.UInt32)">
            <summary>
            Given a UTF-8 buffer which has been read into a DWORD in machine endianness,
            returns <see langword="true"/> iff the last two bytes of the buffer match
            the UTF-8 2-byte sequence mask [ 110yyyyy 10xxxxxx ]. This method *does not*
            validate that the sequence is well-formed; the caller must still perform
            overlong form checking.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.Utf8Util.DWordBeginsWithValidUtf8TwoByteSequenceLittleEndian(System.UInt32)">
            <summary>
            Given a UTF-8 buffer which has been read into a DWORD on a little-endian machine,
            returns <see langword="true"/> iff the first two bytes of the buffer are a well-formed
            UTF-8 two-byte sequence. This wraps the mask check and the overlong check into a
            single operation. Returns <see langword="false"/> if running on a big-endian machine.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.Utf8Util.DWordEndsWithValidUtf8TwoByteSequenceLittleEndian(System.UInt32)">
            <summary>
            Given a UTF-8 buffer which has been read into a DWORD on a little-endian machine,
            returns <see langword="true"/> iff the last two bytes of the buffer are a well-formed
            UTF-8 two-byte sequence. This wraps the mask check and the overlong check into a
            single operation. Returns <see langword="false"/> if running on a big-endian machine.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.Utf8Util.DWordFourthByteIsAscii(System.UInt32)">
            <summary>
            Given a UTF-8 buffer which has been read into a DWORD in machine endianness,
            returns <see langword="true"/> iff the fourth byte of the buffer is ASCII.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.Utf8Util.DWordThirdByteIsAscii(System.UInt32)">
            <summary>
            Given a UTF-8 buffer which has been read into a DWORD in machine endianness,
            returns <see langword="true"/> iff the third byte of the buffer is ASCII.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.Utf8Util.GetNumberOfBytesToNextDWordAlignment(System.Byte@)">
            <summary>
            Given a memory reference, returns the number of bytes that must be added to the reference
            before the reference is DWORD-aligned. Returns a number in the range 0 - 3, inclusive.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.Utf8Util.IntPtrIsLessThanOrEqualTo(System.IntPtr,System.IntPtr)">
            <summary>
            Returns <see langword="true"/> iff (<paramref name="a"/> &lt;= <paramref name="b"/>).
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.Utf8Util.IsInRangeInclusive(System.Byte,System.Byte,System.Byte)">
            <summary>
            Returns <see langword="true"/> iff <paramref name="value"/> is between
            <paramref name="lowerBound"/> and <paramref name="upperBound"/>, inclusive.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.Utf8Util.IsInRangeInclusive(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Returns <see langword="true"/> iff <paramref name="value"/> is between
            <paramref name="lowerBound"/> and <paramref name="upperBound"/>, inclusive.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.Utf8Util.IsLowWordSurrogate(System.UInt32)">
            <summary>
            Returns <see langword="true"/> iff the low word of <paramref name="char"/> is a UTF-16 surrogate.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.Utf8Util.IsUtf8ContinuationByte(System.UInt32)">
            <summary>
            Returns <see langword="true"/> iff the low byte of <paramref name="value"/> is a UTF-8
            continuation byte (10xxxxxx).
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.Utf8Util.ReadAndFoldTwoDWordsUnaligned(System.Byte@)">
            <summary>
            Returns the OR of the next two DWORDs in the buffer.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.Utf8Util.ReadAndFoldTwoQWordsUnaligned(System.Byte@)">
            <summary>
            Returns the OR of the next two QWORDs in the buffer.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.Utf8Util.ROL32(System.UInt32,System.Int32)">
            <summary>
            Rotates a DWORD left. The JITter is smart enough to turn this into a ROL / ROR instruction.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.Utf8Util.QWordAllBytesAreAscii(System.UInt64)">
            <summary>
            Returns <see langword="true"/> iff all bytes in <paramref name="value"/> are ASCII.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Internal.Utf8Util.GetIndexOfFirstInvalidUtf8Sequence(System.ReadOnlySpan{System.Byte}@,System.Int32@,System.Int32@)">
            <summary>
            Returns the offset in <paramref name="input"/> of where the first invalid UTF-8 sequence appears,
            or -1 if the input is valid UTF-8 text. (Empty inputs are considered valid.) On method return the
            <paramref name="scalarCount"/> parameter will contain the total number of Unicode scalar values seen
            up to (but not including) the first invalid sequence, and <paramref name="surrogatePairCount"/> will
            contain the number of surrogate pairs present if this text up to (but not including) the first
            invalid sequence were represented as UTF-16. To get the total UTF-16 code unit count, add
            <paramref name="surrogatePairCount"/> to <paramref name="scalarCount"/>.
            </summary>
        </member>
        <member name="T:DotNetty.Common.ExceptionArgument">
            <summary>The convention for this enum is using the argument name as the enum name</summary>
        </member>
        <member name="T:DotNetty.Common.ExceptionResource">
            <summary>The convention for this enum is using the resource name as the enum name</summary>
        </member>
        <member name="T:DotNetty.Common.IReferenceCounted">
            <summary>
                Reference counting interface for reusable objects
            </summary>
        </member>
        <member name="P:DotNetty.Common.IReferenceCounted.ReferenceCount">
            <summary>
                Returns the reference count of this object
            </summary>
        </member>
        <member name="M:DotNetty.Common.IReferenceCounted.Retain">
            <summary>
                Increases the reference count by 1
            </summary>
        </member>
        <member name="M:DotNetty.Common.IReferenceCounted.Retain(System.Int32)">
            <summary>
                Increases the reference count by <paramref name="increment" />
            </summary>
        </member>
        <member name="M:DotNetty.Common.IReferenceCounted.Touch">
            <summary>
                Records the current access location of this object for debugging purposes.
                If this object is determined to be leaked, the information recorded by this operation will be provided to you
                via <see cref="T:DotNetty.Common.ResourceLeakDetector" />. This method is a shortcut to <see cref="M:DotNetty.Common.IReferenceCounted.Touch(System.Object)" /> with null as
                an argument.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Common.IReferenceCounted.Touch(System.Object)">
            <summary>
                Records the current access location of this object with an additonal arbitrary information for debugging
                purposes. If this object is determined to be leaked, the information recorded by this operation will be
                provided to you via <see cref="T:DotNetty.Common.ResourceLeakDetector" />.
            </summary>
        </member>
        <member name="M:DotNetty.Common.IReferenceCounted.Release">
            <summary>
                Decreases the reference count by 1 and deallocates this object if the reference count reaches 0.
            </summary>
            <returns>true if and only if the reference count is 0 and this object has been deallocated</returns>
        </member>
        <member name="M:DotNetty.Common.IReferenceCounted.Release(System.Int32)">
            <summary>
                Decreases the reference count by <paramref name="decrement" /> and deallocates this object if the reference count
                reaches 0.
            </summary>
            <returns>true if and only if the reference count is 0 and this object has been deallocated</returns>
        </member>
        <member name="T:DotNetty.Common.IResourceLeakHint">
            <summary>
            A hint object that provides human-readable message for easier resource leak tracking.
            </summary>
        </member>
        <member name="M:DotNetty.Common.IResourceLeakHint.ToHintString">
            <summary>
            Returns a human-readable message that potentially enables easier resource leak tracking.
            </summary>
        </member>
        <member name="M:DotNetty.Common.IResourceLeakTracker.Record">
            <summary>
            Records the caller's current stack trace so that the <see cref="T:DotNetty.Common.ResourceLeakDetector"/> can tell where the leaked
            resource was accessed lastly. This method is a shortcut to <see cref="M:DotNetty.Common.IResourceLeakTracker.Record(System.Object)"/> with <c>null</c> as an argument..
            </summary>
        </member>
        <member name="M:DotNetty.Common.IResourceLeakTracker.Record(System.Object)">
            <summary>
            Records the caller's current stack trace and the specified additional arbitrary information
            so that the <see cref="T:DotNetty.Common.ResourceLeakDetector"/> can tell where the leaked resource was accessed lastly.
            </summary>
            <param name="hint"></param>
        </member>
        <member name="M:DotNetty.Common.IResourceLeakTracker.Close(System.Object)">
            <summary>
            Close the leak so that <see cref="T:DotNetty.Common.IResourceLeakTracker"/> does not warn about leaked resources.
            After this method is called a leak associated with this ResourceLeakTracker should not be reported.
            </summary>
            <returns><c>true</c> if called first time, <c>false</c> if called already</returns>
        </member>
        <member name="F:DotNetty.Common.PreciseTime.StartTime">
            <summary>The initial value used for delay and computations based upon a monatomic time source.</summary>
        </member>
        <member name="M:DotNetty.Common.PreciseTime.DeadlineToDelayNanos(System.Int64)">
            <summary>
            Given an arbitrary deadline <paramref name="deadlineNanos"/>, calculate the number of nano seconds from now
            <paramref name="deadlineNanos"/> would expire.
            </summary>
            <param name="deadlineNanos">An arbitrary deadline in nano seconds.</param>
            <returns>the number of nano seconds from now <paramref name="deadlineNanos"/> would expire.</returns>
        </member>
        <member name="T:DotNetty.Common.ResourceLeakDetector.DetectionLevel">
            <summary>
            Represents the level of resource leak detection.
            </summary>
        </member>
        <member name="F:DotNetty.Common.ResourceLeakDetector.DetectionLevel.Disabled">
            <summary>
            Disables resource leak detection.
            </summary>
        </member>
        <member name="F:DotNetty.Common.ResourceLeakDetector.DetectionLevel.Simple">
            <summary>
            Enables simplistic sampling resource leak detection which reports there is a leak or not,
            at the cost of small overhead (default).
            </summary>
        </member>
        <member name="F:DotNetty.Common.ResourceLeakDetector.DetectionLevel.Advanced">
            <summary>
            Enables advanced sampling resource leak detection which reports where the leaked object was accessed
            recently at the cost of high overhead.
            </summary>
        </member>
        <member name="F:DotNetty.Common.ResourceLeakDetector.DetectionLevel.Paranoid">
            <summary>
            Enables paranoid resource leak detection which reports where the leaked object was accessed recently,
            at the cost of the highest possible overhead (for testing purposes only).
            </summary>
        </member>
        <member name="P:DotNetty.Common.ResourceLeakDetector.Enabled">
            Returns <c>true</c> if resource leak detection is enabled.
        </member>
        <member name="P:DotNetty.Common.ResourceLeakDetector.Level">
            <summary>
            Gets or sets resource leak detection level
            </summary>
        </member>
        <member name="M:DotNetty.Common.ResourceLeakDetector.Track(System.Object)">
            <summary>
                Creates a new <see cref="T:DotNetty.Common.IResourceLeakTracker" /> which is expected to be closed
                when the
                related resource is deallocated.
            </summary>
            <returns>the <see cref="T:DotNetty.Common.IResourceLeakTracker" /> or <c>null</c></returns>
        </member>
        <member name="M:DotNetty.Common.ThreadDeathWatcher.Watch(DotNetty.Common.Concurrency.XThread,System.Action)">
            <summary>
            Schedules the specified <see cref="T:System.Action"/> to run when the specified <see cref="T:DotNetty.Common.Concurrency.XThread"/> dies.
            </summary>
        </member>
        <member name="M:DotNetty.Common.ThreadDeathWatcher.Unwatch(DotNetty.Common.Concurrency.XThread,System.Action)">
            <summary>
            Cancels the task scheduled via <see cref="M:DotNetty.Common.ThreadDeathWatcher.Watch(DotNetty.Common.Concurrency.XThread,System.Action)"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Common.ThreadDeathWatcher.AwaitInactivity(System.TimeSpan)">
            <summary>
            Waits until the thread of this watcher has no threads to watch and terminates itself.
            Because a new watcher thread will be started again on <see cref="M:DotNetty.Common.ThreadDeathWatcher.Watch(DotNetty.Common.Concurrency.XThread,System.Action)"/>,
            this operation is only useful when you want to ensure that the watcher thread is terminated
            <strong>after</strong> your application is shut down and there's no chance of calling <see cref="M:DotNetty.Common.ThreadDeathWatcher.Watch(DotNetty.Common.Concurrency.XThread,System.Action)"/>
            afterwards.
            </summary>
            <param name="timeout"></param>
            <returns><c>true</c> if and only if the watcher thread has been terminated.</returns>
        </member>
        <member name="M:DotNetty.Common.ThreadLocalPool.WeakOrderQueue.Head.ReclaimAllSpaceAndUnlink">
            <summary>
            Reclaim all used space and also unlink the nodes to prevent GC nepotism.
            </summary>
        </member>
        <member name="M:DotNetty.Common.ThreadLocalPool.WeakOrderQueue.Head.NewLink">
            <summary>
            Creates a new <see cref="T:DotNetty.Common.ThreadLocalPool.WeakOrderQueue.Link"/> and returns it if we can reserve enough space for it, otherwise it
            returns <c>null</c>.
            </summary>
        </member>
        <member name="M:DotNetty.Common.ThreadLocalPool.Stack.NewWeakOrderQueue(DotNetty.Common.Concurrency.XThread,DotNetty.Common.ThreadLocalPool.DelayedThreadLocal.CountedWeakTable)">
            <summary>
            Allocate a new <see cref="T:DotNetty.Common.ThreadLocalPool.WeakOrderQueue"/> or return <c>null</c> if not possible.
            </summary>
        </member>
        <member name="T:DotNetty.Common.Utilities.AbstractConstant`1">
            <summary>Base implementation of <see cref="T:DotNetty.Common.Utilities.IConstant" />.</summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.AbstractConstant`1.#ctor(System.Int32,System.String)">
            <summary>Creates a new instance.</summary>
        </member>
        <member name="T:DotNetty.Common.Utilities.ArrayExtensions">
            <summary>
                Extension methods used for slicing byte arrays
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.ArrayExtensions.CombineBytes(System.Byte[][])">
            <summary>
                Merge the byte arrays into one byte array.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.AsciiString.ArrayChanged">
            <summary>
            During normal use cases the AsciiString should be immutable, but if the
            underlying array is shared, and changes then this needs to be called.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.AsciiString.IsHexDigit(System.Byte)">
            <summary>
            A hex digit is valid if it is in the range: [0..9] | [A..F] | [a..f]
            Otherwise, return false.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.AsciiString.IsDigit(System.Byte)">
            <summary>
            Returns <see langword="true"/> iff <paramref name="value"/> is in the range [0..9].
            Otherwise, returns <see langword="false"/>.
            </summary>
        </member>
        <member name="T:DotNetty.Common.Utilities.AtomicReference`1">
            <summary>
                Implementation of the java.concurrent.util AtomicReference type.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.AtomicReference`1.#ctor(`0)">
            <summary>
                Sets the initial value of this <see cref="T:DotNetty.Common.Utilities.AtomicReference`1" /> to <paramref name="originalValue"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.AtomicReference`1.#ctor">
            <summary>
                Default constructor
            </summary>
        </member>
        <member name="P:DotNetty.Common.Utilities.AtomicReference`1.Value">
            <summary>
                The current value of this <see cref="T:DotNetty.Common.Utilities.AtomicReference`1" />
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.AtomicReference`1.CompareAndSet(`0,`0)">
            <summary>
                If <see cref="P:DotNetty.Common.Utilities.AtomicReference`1.Value" /> equals <paramref name="expected"/>, then set the Value to
                <paramref name="newValue"/>
                Returns true if  <paramref name="newValue"/> was set, false otherwise.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.AtomicReference`1.op_Implicit(DotNetty.Common.Utilities.AtomicReference{`0})~`0">
            <summary>
                Implicit conversion operator = automatically casts the <see cref="T:DotNetty.Common.Utilities.AtomicReference`1" /> to an instance of
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.AtomicReference`1.op_Implicit(`0)~DotNetty.Common.Utilities.AtomicReference{`0}">
            <summary>
                Implicit conversion operator = allows us to cast any type directly into a <see cref="T:DotNetty.Common.Utilities.AtomicReference`1" />
                instance.
            </summary>
            <param name="newValue"></param>
            <returns></returns>
        </member>
        <member name="T:DotNetty.Common.Utilities.AttributeKey`1">
            <summary>
                Key which can be used to access <seealso cref="T:System.Attribute" /> out of the <see cref="T:DotNetty.Common.Utilities.IAttributeMap" />. Be aware that
                it is not be possible to have multiple keys with the same name.
            </summary>
            <typeparam name="T">
                the type of the <see cref="T:System.Attribute" /> which can be accessed via this <see cref="T:DotNetty.Common.Utilities.AttributeKey`1" />.
            </typeparam>
        </member>
        <member name="M:DotNetty.Common.Utilities.AttributeKey`1.ValueOf(System.String)">
            <summary>Returns the singleton instance of the {@link AttributeKey} which has the specified <c>name</c>.</summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.AttributeKey`1.Exists(System.String)">
            <summary>Returns <c>true</c> if a <see cref="T:DotNetty.Common.Utilities.AttributeKey`1" /> exists for the given <c>name</c>.</summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.AttributeKey`1.NewInstance(System.String)">
            <summary>
                Creates a new <see cref="T:DotNetty.Common.Utilities.AttributeKey`1" /> for the given <c>name</c> or fail with an
                <see cref="T:System.ArgumentException" /> if a <see cref="T:DotNetty.Common.Utilities.AttributeKey`1" /> for the given <c>name</c> exists.
            </summary>
        </member>
        <member name="T:DotNetty.Common.Utilities.IByteProcessor">
            <summary>
                Provides a mechanism to iterate over a collection of bytes.
            </summary>
        </member>
        <member name="F:DotNetty.Common.Utilities.ByteProcessor.FindNul">
            <summary>
                Aborts on a <c>NUL (0x00)</c>.
            </summary>
        </member>
        <member name="F:DotNetty.Common.Utilities.ByteProcessor.FindNonNul">
            <summary>
                Aborts on a non-<c>NUL (0x00)</c>.
            </summary>
        </member>
        <member name="F:DotNetty.Common.Utilities.ByteProcessor.FindCR">
            <summary>
                Aborts on a <c>CR ('\r')</c>.
            </summary>
        </member>
        <member name="F:DotNetty.Common.Utilities.ByteProcessor.FindNonCR">
            <summary>
                Aborts on a non-<c>CR ('\r')</c>.
            </summary>
        </member>
        <member name="F:DotNetty.Common.Utilities.ByteProcessor.FindLF">
            <summary>
                Aborts on a <c>LF ('\n')</c>.
            </summary>
        </member>
        <member name="F:DotNetty.Common.Utilities.ByteProcessor.FindNonLF">
            <summary>
                Aborts on a non-<c>LF ('\n')</c>.
            </summary>
        </member>
        <member name="F:DotNetty.Common.Utilities.ByteProcessor.FindSemicolon">
            <summary>
                Aborts on a <c>CR (';')</c>.
            </summary>
        </member>
        <member name="F:DotNetty.Common.Utilities.ByteProcessor.FindComma">
            <summary>
                Aborts on a comma <c>(',')</c>.
            </summary>
        </member>
        <member name="F:DotNetty.Common.Utilities.ByteProcessor.FindAsciiSpace">
            <summary>
                Aborts on a ascii space character (<c>' '</c>).
            </summary>
        </member>
        <member name="F:DotNetty.Common.Utilities.ByteProcessor.FindCrlf">
            <summary>
                Aborts on a <c>CR ('\r')</c> or a <c>LF ('\n')</c>.
            </summary>
        </member>
        <member name="F:DotNetty.Common.Utilities.ByteProcessor.FindNonCrlf">
            <summary>
                Aborts on a byte which is neither a <c>CR ('\r')</c> nor a <c>LF ('\n')</c>.
            </summary>
        </member>
        <member name="F:DotNetty.Common.Utilities.ByteProcessor.FindLinearWhitespace">
            <summary>
                Aborts on a linear whitespace (a <c>' '</c> or a <c>'\t'</c>).
            </summary>
        </member>
        <member name="F:DotNetty.Common.Utilities.ByteProcessor.FindNonLinearWhitespace">
            <summary>
                Aborts on a byte which is not a linear whitespace (neither <c>' '</c> nor <c>'\t'</c>).
            </summary>
        </member>
        <member name="T:DotNetty.Common.Utilities.ConstantPool">
            <summary>
                A pool of <see cref="T:DotNetty.Common.Utilities.IConstant" />s.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.ConstantPool.ValueOf``1(System.Type,System.String)">
            <summary>Shortcut of <c>this.ValueOf(firstNameComponent.Name + "#" + secondNameComponent)</c>.</summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.ConstantPool.ValueOf``1(System.String)">
            <summary>
                Returns the <see cref="T:DotNetty.Common.Utilities.IConstant" /> which is assigned to the specified <c>name</c>.
                If there's no such <see cref="T:DotNetty.Common.Utilities.IConstant" />, a new one will be created and returned.
                Once created, the subsequent calls with the same <c>name</c> will always return the previously created one
                (i.e. singleton.)
            </summary>
            <param name="name">the name of the <see cref="T:DotNetty.Common.Utilities.IConstant" /></param>
        </member>
        <member name="M:DotNetty.Common.Utilities.ConstantPool.Exists(System.String)">
            <summary>Returns <c>true</c> if a <see cref="T:DotNetty.Common.Utilities.AttributeKey`1" /> exists for the given <c>name</c>.</summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.ConstantPool.NewInstance``1(System.String)">
            <summary>
                Creates a new <see cref="T:DotNetty.Common.Utilities.IConstant" /> for the given <c>name</c> or fail with an
                <see cref="T:System.ArgumentException" /> if a <see cref="T:DotNetty.Common.Utilities.IConstant" /> for the given <c>name</c> exists.
            </summary>
        </member>
        <member name="T:DotNetty.Common.Utilities.DefaultAttributeMap">
            <summary>
                Default <see cref="T:DotNetty.Common.Utilities.IAttributeMap" /> implementation which use simple synchronization per bucket to keep the memory
                overhead
                as low as possible.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.HashedWheelTimer.#ctor">
            <summary>Creates a new timer.</summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.HashedWheelTimer.#ctor(System.TimeSpan,System.Int32,System.Int64)">
            <summary>Creates a new timer.</summary>
            <param name="tickInterval">the interval between two consecutive ticks</param>
            <param name="ticksPerWheel">the size of the wheel</param>
            <param name="maxPendingTimeouts">The maximum number of pending timeouts after which call to
            <c>newTimeout</c> will result in <see cref="T:DotNetty.Common.Concurrency.RejectedExecutionException"/> being thrown.
            No maximum pending timeouts limit is assumed if this value is 0 or negative.</param>
            <exception cref="T:System.ArgumentException">if either of <c>tickInterval</c> and <c>ticksPerWheel</c> is &lt;= 0</exception>
        </member>
        <member name="M:DotNetty.Common.Utilities.HashedWheelTimer.Start">
            <summary>
            Starts the background thread explicitly. The background thread will
            start automatically on demand even if you did not call this method.
            </summary>
            <exception cref="T:System.InvalidOperationException">if this timer has been
            stopped already.</exception>
        </member>
        <member name="M:DotNetty.Common.Utilities.HashedWheelTimer.Worker.WaitForNextTick">
            <summary>
            calculate timer firing time from startTime and current tick number,
            then wait until that goal has been reached.
            </summary>
            <returns>long.MinValue if received a shutdown request,
            current time otherwise (with long.MinValue changed by +1)
            </returns>
        </member>
        <member name="T:DotNetty.Common.Utilities.HashedWheelTimer.HashedWheelBucket">
            <summary>
            Bucket that stores HashedWheelTimeouts. These are stored in a linked-list like datastructure to allow easy
            removal of HashedWheelTimeouts in the middle. Also the HashedWheelTimeout act as nodes themself and so no
            extra object creation is needed.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.HashedWheelTimer.HashedWheelBucket.AddTimeout(DotNetty.Common.Utilities.HashedWheelTimer.HashedWheelTimeout)">
            <summary>
            Add a <see cref="T:DotNetty.Common.Utilities.HashedWheelTimer.HashedWheelTimeout"/> to this bucket.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.HashedWheelTimer.HashedWheelBucket.ExpireTimeouts(System.TimeSpan)">
            <summary>
            Expire all <see cref="T:DotNetty.Common.Utilities.HashedWheelTimer.HashedWheelTimeout"/>s for the given <c>deadline</c>.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.HashedWheelTimer.HashedWheelBucket.ClearTimeouts(System.Collections.Generic.ISet{DotNetty.Common.Utilities.ITimeout})">
            <summary>
            Clear this bucket and return all not expired / cancelled <see cref="T:DotNetty.Common.Utilities.ITimeout"/>s.
            </summary>
        </member>
        <member name="T:DotNetty.Common.Utilities.IAttribute`1">
            <summary>An attribute which allows to store a value reference. It may be updated atomically and so is thread-safe.</summary>
            <typeparam name="T">the type of the value it holds.</typeparam>
        </member>
        <member name="P:DotNetty.Common.Utilities.IAttribute`1.Key">
            <summary>
                Returns the key of this attribute.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.IAttribute`1.Get">
            <summary>
                Returns the current value, which may be <c>null</c>
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.IAttribute`1.Set(`0)">
            <summary>
                Sets the value
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.IAttribute`1.GetAndSet(`0)">
            <summary>
                Atomically sets to the given value and returns the old value which may be <c>null</c> if non was set before.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.IAttribute`1.SetIfAbsent(`0)">
            <summary>
                Atomically sets to the given value if this <see cref="T:DotNetty.Common.Utilities.IAttribute`1" />'s value is <c>null</c>.
                If it was not possible to set the value as it contains a value it will just return the current value.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.IAttribute`1.GetAndRemove">
            <summary>
                Removes this attribute from the <see cref="T:DotNetty.Common.Utilities.IAttributeMap" /> and returns the old value. Subsequent
                <see cref="M:DotNetty.Common.Utilities.IAttribute`1.Get" />
                calls will return <c>null</c>.
                If you only want to return the old value and clear the <see cref="T:DotNetty.Common.Utilities.IAttribute`1" /> while still keep it in
                <see cref="T:DotNetty.Common.Utilities.IAttributeMap" /> use <see cref="M:DotNetty.Common.Utilities.IAttribute`1.GetAndSet(`0)" /> with a value of <c>null</c>.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.IAttribute`1.CompareAndSet(`0,`0)">
            <summary>
                Atomically sets the value to the given updated value if the current value == the expected value.
                If it the set was successful it returns <c>true</c> otherwise <c>false</c>.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.IAttribute`1.Remove">
            <summary>
                Removes this attribute from the <see cref="T:DotNetty.Common.Utilities.IAttributeMap" />. Subsequent <see cref="M:DotNetty.Common.Utilities.IAttribute`1.Get" /> calls will return
                <c>null</c>.
                If you only want to remove the value and clear the <see cref="T:DotNetty.Common.Utilities.IAttribute`1" /> while still keep it in
                <see cref="T:DotNetty.Common.Utilities.IAttributeMap" /> use <see cref="M:DotNetty.Common.Utilities.IAttribute`1.Set(`0)" /> with a value of <c>null</c>.
            </summary>
        </member>
        <member name="T:DotNetty.Common.Utilities.IAttributeMap">
            <summary>Holds <see cref="T:DotNetty.Common.Utilities.IAttribute`1" />s which can be accessed via <see cref="T:DotNetty.Common.Utilities.AttributeKey`1" />.</summary>
            <remarks>Implementations must be Thread-safe.</remarks>
        </member>
        <member name="M:DotNetty.Common.Utilities.IAttributeMap.GetAttribute``1(DotNetty.Common.Utilities.AttributeKey{``0})">
            <summary>
                Get the <see cref="T:DotNetty.Common.Utilities.IAttribute`1" /> for the given <see cref="T:DotNetty.Common.Utilities.AttributeKey`1" />. This method will never return
                null, but may return an <see cref="T:DotNetty.Common.Utilities.IAttribute`1" /> which does not have a value set yet.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.IAttributeMap.HasAttribute``1(DotNetty.Common.Utilities.AttributeKey{``0})">
            <summary>
                Returns <c>true</c> if and only if the given <see cref="T:DotNetty.Common.Utilities.IAttribute`1" /> exists in this
                <see cref="T:DotNetty.Common.Utilities.IAttributeMap" />.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.ICharSequence.SubSequence(System.Int32,System.Int32)">
            Start is the inclusive start index to begin the subsequence.
            End is the exclusive end index to end the subsequence.
        </member>
        <member name="T:DotNetty.Common.Utilities.IConstant">
            <summary>
                A singleton which is safe to compare via the <c>==</c> operator. Created and managed by
                <see cref="T:DotNetty.Common.Utilities.ConstantPool" />.
            </summary>
        </member>
        <member name="P:DotNetty.Common.Utilities.IConstant.Id">
            <summary>Returns the unique number assigned to this <see cref="T:DotNetty.Common.Utilities.IConstant" />.</summary>
        </member>
        <member name="P:DotNetty.Common.Utilities.IConstant.Name">
            <summary>Returns the name of this <see cref="T:DotNetty.Common.Utilities.IConstant" />.</summary>
        </member>
        <member name="T:DotNetty.Common.Utilities.IllegalReferenceCountException">
            <inheritdoc />
            <summary>
                Exception thrown during instances where a reference count is used incorrectly
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.IntegerExtensions.NumberOfLeadingZeros(System.Int32)">
             <summary>
             Returns the number of zero bits preceding the highest-order
             ("leftmost") one-bit in the two's complement binary representation
             of the specified <see cref="T:System.Int32"/> value.  Returns 32 if the
             specified value has no one-bits in its two's complement representation,
             in other words if it is equal to zero.
            
             <para>Note that this method is closely related to the logarithm base 2.
             For all positive <see cref="T:System.Int32"/> values x:</para>
             <code>
             <li>floor(log<sub>2</sub>(x)) = 31 - numberOfLeadingZeros(x)</li>
             <para />
             <li>ceil(log<sub>2</sub>(x)) = 32 - numberOfLeadingZeros(x - 1)</li>
             </code>
             </summary>
             <remarks>参考：https://zhuanlan.zhihu.com/p/34608787 </remarks>
             <param name="i">the value whose number of leading zeros is to be computed</param>
             <returns>the number of zero bits preceding the highest-order
             ("leftmost") one-bit in the two's complement binary representation
             of the specified <see cref="T:System.Int32"/> value, or 32 if the value</returns>
        </member>
        <member name="T:DotNetty.Common.Utilities.ITimeout">
            <summary>
            A handle associated with a <see cref="T:DotNetty.Common.Utilities.ITimerTask"/> that is returned by a
            <see cref="T:DotNetty.Common.Utilities.ITimer"/>.
            </summary>
        </member>
        <member name="P:DotNetty.Common.Utilities.ITimeout.Timer">
            <summary>
            Returns the <see cref="T:DotNetty.Common.Utilities.ITimer"/> that created this handle.
            </summary>
        </member>
        <member name="P:DotNetty.Common.Utilities.ITimeout.Task">
            <summary>
            Returns the <see cref="T:DotNetty.Common.Utilities.ITimerTask"/> which is associated with this handle.
            </summary>
        </member>
        <member name="P:DotNetty.Common.Utilities.ITimeout.Expired">
            <summary>
            Returns <c>true</c> if and only if the <see cref="T:DotNetty.Common.Utilities.ITimerTask"/> associated
            with this handle has been expired.
            </summary>
        </member>
        <member name="P:DotNetty.Common.Utilities.ITimeout.Canceled">
            <summary>
            Returns <c>true</c> if and only if the <see cref="T:DotNetty.Common.Utilities.ITimerTask"/> associated
            with this handle has been canceled.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.ITimeout.Cancel">
            <summary>
            Attempts to cancel the <see cref="T:DotNetty.Common.Utilities.ITimerTask"/> associated with this handle.
            If the task has been executed or canceled already, it will return with
            no side effect.
            </summary>
            <returns><c>true</c> if the cancellation completed successfully, otherwise <c>false</c>.</returns>
        </member>
        <member name="T:DotNetty.Common.Utilities.ITimer">
            <summary>
            Schedules <see cref="T:DotNetty.Common.Utilities.ITimerTask"/>s for one-time future execution in a background
            thread.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.ITimer.NewTimeout(DotNetty.Common.Utilities.ITimerTask,System.TimeSpan)">
            <summary>
            Schedules the specified <see cref="T:DotNetty.Common.Utilities.ITimerTask"/> for one-time execution after the specified delay.
            </summary>
            <returns>a handle which is associated with the specified task</returns>
            <exception cref="T:System.InvalidOperationException">if this timer has been stopped already</exception>
            <exception cref="T:DotNetty.Common.Concurrency.RejectedExecutionException">if the pending timeouts are too many and creating new timeout
            can cause instability in the system.</exception>
        </member>
        <member name="M:DotNetty.Common.Utilities.ITimer.StopAsync">
            <summary>
            Releases all resources acquired by this <see cref="T:DotNetty.Common.Utilities.ITimer"/> and cancels all
            tasks which were scheduled but not executed yet.
            </summary>
            <returns>the handles associated with the tasks which were canceled by
            this method</returns>
        </member>
        <member name="T:DotNetty.Common.Utilities.ITimerTask">
            <summary>
            A task which is executed after the delay specified with
            <see cref="M:DotNetty.Common.Utilities.ITimer.NewTimeout(DotNetty.Common.Utilities.ITimerTask,System.TimeSpan)"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.ITimerTask.Run(DotNetty.Common.Utilities.ITimeout)">
            <summary>
            Executed after the delay specified with
            <see cref="M:DotNetty.Common.Utilities.ITimer.NewTimeout(DotNetty.Common.Utilities.ITimerTask,System.TimeSpan)"/>.
            </summary>
            <param name="timeout">a handle which is associated with this task</param>
        </member>
        <member name="M:DotNetty.Common.Utilities.ReferenceCountUtil.Retain``1(``0)">
            <summary>
            Tries to call <see cref="M:DotNetty.Common.IReferenceCounted.Retain"/> if the specified message implements
            <see cref="T:DotNetty.Common.IReferenceCounted"/>. If the specified message doesn't implement
            <see cref="T:DotNetty.Common.IReferenceCounted"/>, this method does nothing.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.ReferenceCountUtil.Retain``1(``0,System.Int32)">
            <summary>
            Tries to call <see cref="M:DotNetty.Common.IReferenceCounted.Retain(System.Int32)"/> if the specified message implements
            <see cref="T:DotNetty.Common.IReferenceCounted"/>. If the specified message doesn't implement
            <see cref="T:DotNetty.Common.IReferenceCounted"/>, this method does nothing.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.ReferenceCountUtil.Touch``1(``0)">
            <summary>
            Tries to call <see cref="M:DotNetty.Common.IReferenceCounted.Touch" /> if the specified message implements
            <see cref="T:DotNetty.Common.IReferenceCounted" />.
            If the specified message doesn't implement <see cref="T:DotNetty.Common.IReferenceCounted" />, this method does nothing.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.ReferenceCountUtil.Touch``1(``0,System.Object)">
            <summary>
            Tries to call <see cref="M:DotNetty.Common.IReferenceCounted.Touch(System.Object)" /> if the specified message implements
            <see cref="T:DotNetty.Common.IReferenceCounted" />. If the specified message doesn't implement
            <see cref="T:DotNetty.Common.IReferenceCounted" />, this method does nothing.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.ReferenceCountUtil.Release(System.Object)">
            <summary>
            Tries to call <see cref="M:DotNetty.Common.IReferenceCounted.Release" /> if the specified message implements
            <see cref="T:DotNetty.Common.IReferenceCounted"/>. If the specified message doesn't implement
            <see cref="T:DotNetty.Common.IReferenceCounted"/>, this method does nothing.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.ReferenceCountUtil.Release(System.Object,System.Int32)">
            <summary>
            Tries to call <see cref="M:DotNetty.Common.IReferenceCounted.Release(System.Int32)" /> if the specified message implements
            <see cref="T:DotNetty.Common.IReferenceCounted"/>. If the specified message doesn't implement
            <see cref="T:DotNetty.Common.IReferenceCounted"/>, this method does nothing.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.ReferenceCountUtil.SafeRelease(System.Object)">
            <summary>
            Tries to call <see cref="M:DotNetty.Common.IReferenceCounted.Release" /> if the specified message implements
            <see cref="T:DotNetty.Common.IReferenceCounted"/>. If the specified message doesn't implement
            <see cref="T:DotNetty.Common.IReferenceCounted"/>, this method does nothing. Unlike <see cref="M:DotNetty.Common.Utilities.ReferenceCountUtil.Release(System.Object)"/>, this
            method catches an exception raised by <see cref="M:DotNetty.Common.IReferenceCounted.Release" /> and logs it, rather than
            rethrowing it to the caller. It is usually recommended to use <see cref="M:DotNetty.Common.Utilities.ReferenceCountUtil.Release(System.Object)"/> instead, unless
            you absolutely need to swallow an exception.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.ReferenceCountUtil.SafeRelease(System.Object,System.Int32)">
            <summary>
            Tries to call <see cref="M:DotNetty.Common.IReferenceCounted.Release(System.Int32)" /> if the specified message implements
            <see cref="T:DotNetty.Common.IReferenceCounted"/>. If the specified message doesn't implement
            <see cref="T:DotNetty.Common.IReferenceCounted"/>, this method does nothing. Unlike <see cref="M:DotNetty.Common.Utilities.ReferenceCountUtil.Release(System.Object)"/>, this
            method catches an exception raised by <see cref="M:DotNetty.Common.IReferenceCounted.Release(System.Int32)" /> and logs it, rather
            than rethrowing it to the caller. It is usually recommended to use <see cref="M:DotNetty.Common.Utilities.ReferenceCountUtil.Release(System.Object,System.Int32)"/>
            instead, unless you absolutely need to swallow an exception.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.ReferenceCountUtil.ReleaseLater``1(``0)">
            <summary>
            Schedules the specified object to be released when the caller thread terminates. Note that this operation
            is intended to simplify reference counting of ephemeral objects during unit tests. Do not use it beyond the
            intended use case.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.ReferenceCountUtil.ReleaseLater``1(``0,System.Int32)">
            <summary>
            Schedules the specified object to be released when the caller thread terminates. Note that this operation
            is intended to simplify reference counting of ephemeral objects during unit tests. Do not use it beyond the
            intended use case.
            </summary>
        </member>
        <member name="T:DotNetty.Common.Utilities.SafeRandom">
            <summary>
            Thread-safe random number generator.
            Has same API as System.Random but is thread safe, similar to the implementation by Steven Toub: http://blogs.msdn.com/b/pfxteam/archive/2014/10/20/9434171.aspx
            </summary>
        </member>
        <member name="T:DotNetty.Common.Utilities.StringUtil">
            <summary>
                String utility class.
            </summary>
        </member>
        <member name="F:DotNetty.Common.Utilities.StringUtil.CsvNumberEscapeCharacters">
            2 - Quote character at beginning and end.
            5 - Extra allowance for anticipated escape characters that may be added.
        </member>
        <member name="M:DotNetty.Common.Utilities.StringUtil.ByteToHexStringPadded(System.Int32)">
            <summary>
                Converts the specified byte value into a 2-digit hexadecimal integer.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.StringUtil.ToHexStringPadded(System.Byte[])">
            <summary>
                Converts the specified byte array into a hexadecimal value.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.StringUtil.ToHexStringPadded(System.Byte[],System.Int32,System.Int32)">
            <summary>
                Converts the specified byte array into a hexadecimal value.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.StringUtil.ByteToHexString(System.Byte)">
            <summary>
                Converts the specified byte value into a hexadecimal integer.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.StringUtil.SimpleClassName(System.Object)">
            <summary>
                The shortcut to <see cref="M:DotNetty.Common.Utilities.StringUtil.SimpleClassName(System.Type)">SimpleClassName(o.GetType())</see>.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.StringUtil.SimpleClassName``1">
            <summary>
                The shortcut to <see cref="M:DotNetty.Common.Utilities.StringUtil.SimpleClassName(System.Type)">SimpleClassName(o.GetType())</see>.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.StringUtil.SimpleClassName(System.Type)">
            <summary>
                Generates a simplified name from a <see cref="T:System.Type" />.  Similar to {@link Class#getSimpleName()}, but it works
                fine
                with anonymous classes.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.StringUtil.EscapeCsv(DotNetty.Common.Utilities.ICharSequence,System.Boolean)">
            <summary>
                Escapes the specified value, if necessary according to
                <a href="https://tools.ietf.org/html/rfc4180#section-2">RFC-4180</a>.
            </summary>
            <param name="value">
                The value which will be escaped according to
                <a href="https://tools.ietf.org/html/rfc4180#section-2">RFC-4180</a>
            </param>
            <param name="trimWhiteSpace">
                The value will first be trimmed of its optional white-space characters, according to 
                <a href= "https://tools.ietf.org/html/rfc7230#section-7" >RFC-7230</a>
            </param>
            <returns>the escaped value if necessary, or the value unchanged</returns>
        </member>
        <member name="M:DotNetty.Common.Utilities.TaskUtil.IsSuccess(System.Threading.Tasks.Task)">
            <summary>TBD</summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.TaskUtil.IsSuccess``1(System.Threading.Tasks.Task{``0})">
            <summary>TBD</summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.TaskUtil.Ignore(System.Threading.Tasks.Task)">
            <summary>Observes and ignores a potential exception on a given Task.
            If a Task fails and throws an exception which is never observed, it will be caught by the .NET finalizer thread.
            This function awaits the given task and if the exception is thrown, it observes this exception and simply ignores it.
            This will prevent the escalation of this exception to the .NET finalizer thread.</summary>
            <param name="task">The task to be ignored.</param>
        </member>
        <member name="M:DotNetty.Common.Utilities.TaskUtil.WithTimeout(System.Threading.Tasks.Task,System.TimeSpan)">
            <summary>
            This will apply a timeout delay to the task, allowing us to exit early
            </summary>
            <param name="taskToComplete">The task we will timeout after timeSpan</param>
            <param name="timeout">Amount of time to wait before timing out</param>
            <returns>The completed task</returns>
        </member>
        <member name="M:DotNetty.Common.Utilities.TaskUtil.WithTimeout``1(System.Threading.Tasks.Task{``0},System.TimeSpan)">
            <summary>
            This will apply a timeout delay to the task, allowing us to exit early
            </summary>
            <param name="taskToComplete">The task we will timeout after timeSpan</param>
            <param name="timeSpan">Amount of time to wait before timing out</param>
            <exception cref="T:System.TimeoutException">If we time out we will get this exception</exception>
            <exception cref="T:System.TimeoutException">If we time out we will get this exception</exception>
            <returns>The value of the completed task</returns>
        </member>
        <member name="M:DotNetty.Common.Utilities.TaskUtil.WithCancellation(System.Threading.Tasks.Task,System.Threading.CancellationToken,System.String)">
            <summary>
            For making an uncancellable task cancellable, by ignoring its result.
            </summary>
            <param name="taskToComplete">The task to wait for unless cancelled</param>
            <param name="cancellationToken">A cancellation token for cancelling the wait</param>
            <param name="message">Message to set in the exception</param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Common.Utilities.TaskUtil.WithCancellation(System.Threading.Tasks.Task,System.Threading.CancellationToken)">
            <summary>
            For making an uncancellable task cancellable, by ignoring its result.
            </summary>
            <param name="taskToComplete">The task to wait for unless cancelled</param>
            <param name="cancellationToken">A cancellation token for cancelling the wait</param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Common.Utilities.TaskUtil.WithCancellation``1(System.Threading.Tasks.Task{``0},System.Threading.CancellationToken,System.String)">
            <summary>
            For making an uncancellable task cancellable, by ignoring its result.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="taskToComplete">The task to wait for unless cancelled</param>
            <param name="cancellationToken">A cancellation token for cancelling the wait</param>
            <param name="message">Message to set in the exception</param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Common.Utilities.TaskUtil.WithCancellation``1(System.Threading.Tasks.Task{``0},System.Threading.CancellationToken)">
            <summary>
            For making an uncancellable task cancellable, by ignoring its result.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="taskToComplete">The task to wait for unless cancelled</param>
            <param name="cancellationToken">A cancellation token for cancelling the wait</param>
            <returns></returns>
        </member>
        <member name="T:DotNetty.Common.Utilities.TimeUtil">
            <summary>
            Time utility class.
            </summary>
        </member>
        <member name="M:DotNetty.Common.Utilities.TimeUtil.Max(System.TimeSpan,System.TimeSpan)">
            <summary>
            Compare two timespan objects
            </summary>
            <param name="first">first timespan object</param>
            <param name="second">two timespan object</param>
        </member>
        <member name="M:DotNetty.Common.Utilities.TimeUtil.GetSystemTime">
            <summary>
            Gets the system time.
            </summary>
            <returns>The system time.</returns>
        </member>
        <member name="T:DotNetty.InlineMethod">
            <summary>Helper class for constants for inlining methods</summary>
        </member>
        <member name="F:DotNetty.InlineMethod.AggressiveInlining">
            <summary>Value for lining method</summary>
        </member>
        <member name="F:DotNetty.InlineMethod.AggressiveOptimization">
            <summary>Value for lining method</summary>
        </member>
    </members>
</doc>
